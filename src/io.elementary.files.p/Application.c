/* Application.c generated by valac 0.56.3, the Vala compiler
 * generated from Application.vala, do not modify */

/**TODO** move the volume manager here? */

#include <gio/gio.h>
#include <gtk/gtk.h>
#include <glib-object.h>
#include <glib.h>
#include <stdlib.h>
#include <string.h>
#include <granite.h>
#include "pantheon-files-core.h"
#include <gdk/gdk.h>
#include "config.h"
#include <unistd.h>
#include <glib/gi18n-lib.h>
#include <handy.h>

#define FILES_APPLICATION_MARLIN_ACCEL_MAP_SAVE_DELAY 15
#define FILES_APPLICATION_MAX_WINDOWS ((guint) 25)
#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define FILES_TYPE_APPLICATION (files_application_get_type ())
#define FILES_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_TYPE_APPLICATION, FilesApplication))
#define FILES_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_TYPE_APPLICATION, FilesApplicationClass))
#define FILES_IS_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_TYPE_APPLICATION))
#define FILES_IS_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_TYPE_APPLICATION))
#define FILES_APPLICATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_TYPE_APPLICATION, FilesApplicationClass))

typedef struct _FilesApplication FilesApplication;
typedef struct _FilesApplicationClass FilesApplicationClass;
typedef struct _FilesApplicationPrivate FilesApplicationPrivate;

#define FILES_PROGRESS_TYPE_UI_HANDLER (files_progress_ui_handler_get_type ())
#define FILES_PROGRESS_UI_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_PROGRESS_TYPE_UI_HANDLER, FilesProgressUIHandler))
#define FILES_PROGRESS_UI_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_PROGRESS_TYPE_UI_HANDLER, FilesProgressUIHandlerClass))
#define FILES_PROGRESS_IS_UI_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_PROGRESS_TYPE_UI_HANDLER))
#define FILES_PROGRESS_IS_UI_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_PROGRESS_TYPE_UI_HANDLER))
#define FILES_PROGRESS_UI_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_PROGRESS_TYPE_UI_HANDLER, FilesProgressUIHandlerClass))

typedef struct _FilesProgressUIHandler FilesProgressUIHandler;
typedef struct _FilesProgressUIHandlerClass FilesProgressUIHandlerClass;

#define FILES_TYPE_CLIPBOARD_MANAGER (files_clipboard_manager_get_type ())
#define FILES_CLIPBOARD_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_TYPE_CLIPBOARD_MANAGER, FilesClipboardManager))
#define FILES_CLIPBOARD_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_TYPE_CLIPBOARD_MANAGER, FilesClipboardManagerClass))
#define FILES_IS_CLIPBOARD_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_TYPE_CLIPBOARD_MANAGER))
#define FILES_IS_CLIPBOARD_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_TYPE_CLIPBOARD_MANAGER))
#define FILES_CLIPBOARD_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_TYPE_CLIPBOARD_MANAGER, FilesClipboardManagerClass))

typedef struct _FilesClipboardManager FilesClipboardManager;
typedef struct _FilesClipboardManagerClass FilesClipboardManagerClass;
enum  {
	FILES_APPLICATION_0_PROPERTY,
	FILES_APPLICATION_GNOME_INTERFACE_SETTINGS_PROPERTY,
	FILES_APPLICATION_GNOME_PRIVACY_SETTINGS_PROPERTY,
	FILES_APPLICATION_GTK_FILE_CHOOSER_SETTINGS_PROPERTY,
	FILES_APPLICATION_WINDOW_COUNT_PROPERTY,
	FILES_APPLICATION_NUM_PROPERTIES
};
static GParamSpec* files_application_properties[FILES_APPLICATION_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block1Data Block1Data;
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define FILES_VIEW_TYPE_WINDOW (files_view_window_get_type ())
#define FILES_VIEW_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_VIEW_TYPE_WINDOW, FilesViewWindow))
#define FILES_VIEW_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_VIEW_TYPE_WINDOW, FilesViewWindowClass))
#define FILES_VIEW_IS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_VIEW_TYPE_WINDOW))
#define FILES_VIEW_IS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_VIEW_TYPE_WINDOW))
#define FILES_VIEW_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_VIEW_TYPE_WINDOW, FilesViewWindowClass))

typedef struct _FilesViewWindow FilesViewWindow;
typedef struct _FilesViewWindowClass FilesViewWindowClass;
typedef struct _Block2Data Block2Data;
#define _g_settings_schema_unref0(var) ((var == NULL) ? NULL : (var = (g_settings_schema_unref (var), NULL)))

struct _FilesApplication {
	GtkApplication parent_instance;
	FilesApplicationPrivate * priv;
};

struct _FilesApplicationClass {
	GtkApplicationClass parent_class;
};

struct _FilesApplicationPrivate {
	GVolumeMonitor* volume_monitor;
	FilesProgressUIHandler* progress_handler;
	FilesClipboardManager* clipboard;
	GtkRecentManager* recent;
	GSettings* _gnome_interface_settings;
	GSettings* _gnome_privacy_settings;
	GSettings* _gtk_file_chooser_settings;
	gint _window_count;
	gboolean quitting;
	gchar** remaining;
};

struct _Block1Data {
	int _ref_count_;
	FilesApplication* self;
	GraniteSettings* granite_settings;
	GtkSettings* gtk_settings;
};

struct _Block2Data {
	int _ref_count_;
	FilesApplication* self;
	GFile* file;
};

VALA_EXTERN GSettings* files_app_settings;
GSettings* files_app_settings = NULL;
VALA_EXTERN GSettings* files_icon_view_settings;
GSettings* files_icon_view_settings = NULL;
VALA_EXTERN GSettings* files_list_view_settings;
GSettings* files_list_view_settings = NULL;
VALA_EXTERN GSettings* files_column_view_settings;
GSettings* files_column_view_settings = NULL;
static gint FilesApplication_private_offset;
static gpointer files_application_parent_class = NULL;

VALA_EXTERN GType files_application_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesApplication, g_object_unref)
VALA_EXTERN GType files_progress_ui_handler_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesProgressUIHandler, g_object_unref)
VALA_EXTERN GType files_clipboard_manager_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesClipboardManager, g_object_unref)
static void files_application_real_startup (GApplication* base);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void files_application_init_schemas (FilesApplication* self);
static void __lambda15_ (FilesApplication* self);
static void ___lambda15__gtk_icon_theme_changed (GtkIconTheme* _sender,
                                          gpointer self);
VALA_EXTERN FilesProgressUIHandler* files_progress_ui_handler_new (void);
VALA_EXTERN FilesProgressUIHandler* files_progress_ui_handler_construct (GType object_type);
VALA_EXTERN FilesClipboardManager* files_clipboard_manager_get_for_display (GdkDisplay* display);
static void files_application_mount_removed_callback (FilesApplication* self,
                                               GVolumeMonitor* monitor,
                                               GMount* mount);
static void _files_application_mount_removed_callback_g_volume_monitor_mount_removed (GVolumeMonitor* _sender,
                                                                               GMount* mount,
                                                                               gpointer self);
static void files_application_set_window_count (FilesApplication* self,
                                         gint value);
static void __lambda202_ (FilesApplication* self);
VALA_EXTERN gint files_application_get_window_count (FilesApplication* self);
static void ___lambda202__gtk_application_window_added (GtkApplication* _sender,
                                                 GtkWindow* window,
                                                 gpointer self);
static void __lambda203_ (FilesApplication* self);
static void ___lambda203__gtk_application_window_removed (GtkApplication* _sender,
                                                   GtkWindow* window,
                                                   gpointer self);
static void __lambda204_ (Block1Data* _data1_);
VALA_EXTERN void files_emblem_renderer_clear_cache (void);
static void ___lambda204__g_object_notify (GObject* _sender,
                                    GParamSpec* pspec,
                                    gpointer self);
VALA_EXTERN FilesClipboardManager* files_application_get_clipboard_manager (FilesApplication* self);
VALA_EXTERN GtkRecentManager* files_application_get_recent_manager (FilesApplication* self);
static gint files_application_real_command_line (GApplication* base,
                                          GApplicationCommandLine* cmd);
VALA_EXTERN gboolean files_is_admin (void);
VALA_EXTERN void files_application_quit (FilesApplication* self);
static gint _files_application_command_line (FilesApplication* self,
                                      GApplicationCommandLine* cmd);
static void _vala_array_add1 (GFile** * array,
                       gint* length,
                       gint* size,
                       GFile* value);
VALA_EXTERN GType files_view_window_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesViewWindow, g_object_unref)
static FilesViewWindow* files_application_create_window_with_tabs (FilesApplication* self,
                                                            GFile** locations,
                                                            gint locations_length1,
                                                            FilesViewMode viewmode);
VALA_EXTERN void files_view_window_open_tabs (FilesViewWindow* self,
                                  GFile** files,
                                  gint files_length1,
                                  FilesViewMode mode,
                                  gboolean ignore_duplicate);
static void files_application_real_quit_mainloop (GApplication* base);
static void __lambda137_ (FilesApplication* self,
                   GtkWindow* window);
VALA_EXTERN void files_view_window_quit (FilesViewWindow* self);
static void ___lambda137__gfunc (gconstpointer data,
                          gpointer self);
VALA_EXTERN void files_application_folder_deleted (FilesApplication* self,
                                       GFile* file);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static void __lambda108_ (Block2Data* _data2_,
                   GtkWindow* window);
static void ___lambda108__gfunc (gconstpointer data,
                          gpointer self);
VALA_EXTERN void files_view_window_mount_removed (FilesViewWindow* self,
                                      GMount* mount);
VALA_EXTERN GSettings* files_application_get_gnome_interface_settings (FilesApplication* self);
VALA_EXTERN GSettings* files_application_get_gnome_privacy_settings (FilesApplication* self);
VALA_EXTERN GSettings* files_application_get_gtk_file_chooser_settings (FilesApplication* self);
VALA_EXTERN FilesViewWindow* files_application_create_window (FilesApplication* self,
                                                  GFile* location,
                                                  FilesViewMode viewmode);
VALA_EXTERN FilesViewWindow* files_view_window_new (FilesApplication* application,
                                        GdkScreen* myscreen);
VALA_EXTERN FilesViewWindow* files_view_window_construct (GType object_type,
                                              FilesApplication* application,
                                              GdkScreen* myscreen);
VALA_EXTERN FilesApplication* files_application_new (void);
VALA_EXTERN FilesApplication* files_application_construct (GType object_type);
static void files_application_set_gnome_interface_settings (FilesApplication* self,
                                                     GSettings* value);
static void files_application_set_gnome_privacy_settings (FilesApplication* self,
                                                   GSettings* value);
static void files_application_set_gtk_file_chooser_settings (FilesApplication* self,
                                                      GSettings* value);
static GObject * files_application_constructor (GType type,
                                         guint n_construct_properties,
                                         GObjectConstructParam * construct_properties);
static void files_application_finalize (GObject * obj);
static GType files_application_get_type_once (void);
static void _vala_files_application_get_property (GObject * object,
                                           guint property_id,
                                           GValue * value,
                                           GParamSpec * pspec);
static void _vala_files_application_set_property (GObject * object,
                                           guint property_id,
                                           const GValue * value,
                                           GParamSpec * pspec);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);
static gssize _vala_array_length (gpointer array);

static inline gpointer
files_application_get_instance_private (FilesApplication* self)
{
	return G_STRUCT_MEMBER_P (self, FilesApplication_private_offset);
}

static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}

static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		FilesApplication* self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->gtk_settings);
		_g_object_unref0 (_data1_->granite_settings);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}

static void
__lambda15_ (FilesApplication* self)
{
	files_icon_info_clear_caches ();
}

static void
___lambda15__gtk_icon_theme_changed (GtkIconTheme* _sender,
                                     gpointer self)
{
	__lambda15_ ((FilesApplication*) self);
}

static void
_files_application_mount_removed_callback_g_volume_monitor_mount_removed (GVolumeMonitor* _sender,
                                                                          GMount* mount,
                                                                          gpointer self)
{
	files_application_mount_removed_callback ((FilesApplication*) self, _sender, mount);
}

static void
__lambda202_ (FilesApplication* self)
{
	gint _tmp0_;
	_tmp0_ = self->priv->_window_count;
	files_application_set_window_count (self, _tmp0_ + 1);
}

static void
___lambda202__gtk_application_window_added (GtkApplication* _sender,
                                            GtkWindow* window,
                                            gpointer self)
{
	__lambda202_ ((FilesApplication*) self);
}

static void
__lambda203_ (FilesApplication* self)
{
	gint _tmp0_;
	_tmp0_ = self->priv->_window_count;
	files_application_set_window_count (self, _tmp0_ - 1);
}

static void
___lambda203__gtk_application_window_removed (GtkApplication* _sender,
                                              GtkWindow* window,
                                              gpointer self)
{
	__lambda203_ ((FilesApplication*) self);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static void
__lambda204_ (Block1Data* _data1_)
{
	FilesApplication* self;
	GraniteSettingsColorScheme _tmp0_;
	GraniteSettingsColorScheme _tmp1_;
	self = _data1_->self;
	_tmp0_ = granite_settings_get_prefers_color_scheme (_data1_->granite_settings);
	_tmp1_ = _tmp0_;
	g_object_set (_data1_->gtk_settings, "gtk-application-prefer-dark-theme", _tmp1_ == GRANITE_SETTINGS_COLOR_SCHEME_DARK, NULL);
	files_emblem_renderer_clear_cache ();
}

static void
___lambda204__g_object_notify (GObject* _sender,
                               GParamSpec* pspec,
                               gpointer self)
{
	__lambda204_ (self);
}

static void
files_application_real_startup (GApplication* base)
{
	FilesApplication * self;
	Block1Data* _data1_;
	GtkIconTheme* _tmp0_;
	FilesProgressUIHandler* _tmp1_;
	GdkDisplay* _tmp2_;
	FilesClipboardManager* _tmp3_;
	GtkRecentManager* _tmp4_;
	FilesPluginManager* _tmp5_;
	GVolumeMonitor* _tmp6_;
	GVolumeMonitor* _tmp7_;
	GraniteSettings* _tmp8_;
	GraniteSettings* _tmp9_;
	GtkSettings* _tmp10_;
	GtkSettings* _tmp11_;
	GraniteSettingsColorScheme _tmp12_;
	GraniteSettingsColorScheme _tmp13_;
	self = (FilesApplication*) base;
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	G_APPLICATION_CLASS (files_application_parent_class)->startup ((GApplication*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_application_get_type (), GtkApplication));
	files_application_init_schemas (self);
	_tmp0_ = gtk_icon_theme_get_default ();
	g_signal_connect_object (_tmp0_, "changed", (GCallback) ___lambda15__gtk_icon_theme_changed, self, 0);
	_tmp1_ = files_progress_ui_handler_new ();
	_g_object_unref0 (self->priv->progress_handler);
	self->priv->progress_handler = _tmp1_;
	_tmp2_ = gdk_display_get_default ();
	_tmp3_ = files_clipboard_manager_get_for_display (_tmp2_);
	_g_object_unref0 (self->priv->clipboard);
	self->priv->clipboard = _tmp3_;
	_tmp4_ = gtk_recent_manager_new ();
	_g_object_unref0 (self->priv->recent);
	self->priv->recent = _tmp4_;
	_tmp5_ = files_plugin_manager_new (PLUGIN_DIR, (guint) getuid ());
	_g_object_unref0 (plugins);
	plugins = _tmp5_;
	_tmp6_ = g_volume_monitor_get ();
	_g_object_unref0 (self->priv->volume_monitor);
	self->priv->volume_monitor = _tmp6_;
	_tmp7_ = self->priv->volume_monitor;
	g_signal_connect_object (_tmp7_, "mount-removed", (GCallback) _files_application_mount_removed_callback_g_volume_monitor_mount_removed, self, 0);
	files_application_set_window_count (self, 0);
	g_signal_connect_object ((GtkApplication*) self, "window-added", (GCallback) ___lambda202__gtk_application_window_added, self, G_CONNECT_AFTER);
	g_signal_connect_object ((GtkApplication*) self, "window-removed", (GCallback) ___lambda203__gtk_application_window_removed, self, 0);
	_tmp8_ = granite_settings_get_default ();
	_tmp9_ = _g_object_ref0 (_tmp8_);
	_data1_->granite_settings = _tmp9_;
	_tmp10_ = gtk_settings_get_default ();
	_tmp11_ = _g_object_ref0 (_tmp10_);
	_data1_->gtk_settings = _tmp11_;
	_tmp12_ = granite_settings_get_prefers_color_scheme (_data1_->granite_settings);
	_tmp13_ = _tmp12_;
	g_object_set (_data1_->gtk_settings, "gtk-application-prefer-dark-theme", _tmp13_ == GRANITE_SETTINGS_COLOR_SCHEME_DARK, NULL);
	g_signal_connect_data ((GObject*) _data1_->granite_settings, "notify::prefers-color-scheme", (GCallback) ___lambda204__g_object_notify, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	block1_data_unref (_data1_);
	_data1_ = NULL;
}

FilesClipboardManager*
files_application_get_clipboard_manager (FilesApplication* self)
{
	FilesClipboardManager* _tmp0_;
	FilesClipboardManager* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->clipboard;
	result = _tmp0_;
	return result;
}

GtkRecentManager*
files_application_get_recent_manager (FilesApplication* self)
{
	GtkRecentManager* _tmp0_;
	GtkRecentManager* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->recent;
	result = _tmp0_;
	return result;
}

static gint
files_application_real_command_line (GApplication* base,
                                     GApplicationCommandLine* cmd)
{
	FilesApplication * self;
	gboolean _tmp0_ = FALSE;
	gint _result_ = 0;
	gint result;
	self = (FilesApplication*) base;
	g_return_val_if_fail (cmd != NULL, 0);
	if (files_is_admin ()) {
		const gchar* _tmp1_;
		_tmp1_ = g_getenv ("PKEXEC_UID");
		_tmp0_ = _tmp1_ == NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		g_warning ("Application.vala:123: %s", "Running Files as root using sudo is not possible. " "Please use the command: io.elementary.files-pkexec [folder]");
		files_application_quit (self);
		result = 1;
		return result;
	}
	g_application_hold ((GApplication*) self);
	_result_ = _files_application_command_line (self, cmd);
	g_application_release ((GApplication*) self);
	result = _result_;
	return result;
}

static void
_vala_array_add1 (GFile** * array,
                  gint* length,
                  gint* size,
                  GFile* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GFile*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

static gint
_files_application_command_line (FilesApplication* self,
                                 GApplicationCommandLine* cmd)
{
	gboolean version = FALSE;
	gboolean open_in_tab = FALSE;
	gboolean create_new_window = FALSE;
	gboolean kill_shell = FALSE;
	gboolean debug = FALSE;
	GOptionEntry* options = NULL;
	GOptionEntry* _tmp0_;
	gint options_length1;
	gint _options_size_;
	GOptionEntry* _tmp1_;
	gint _tmp1__length1;
	GOptionEntry _tmp2_ = {0};
	GOptionEntry* _tmp3_;
	gint _tmp3__length1;
	GOptionEntry _tmp4_ = {0};
	GOptionEntry* _tmp5_;
	gint _tmp5__length1;
	GOptionEntry _tmp6_ = {0};
	GOptionEntry* _tmp7_;
	gint _tmp7__length1;
	GOptionEntry _tmp8_ = {0};
	GOptionEntry* _tmp9_;
	gint _tmp9__length1;
	GOptionEntry _tmp10_ = {0};
	GOptionEntry* _tmp11_;
	gint _tmp11__length1;
	GOptionEntry _tmp12_ = {0};
	GOptionEntry* _tmp13_;
	gint _tmp13__length1;
	GOptionEntry _tmp14_ = {0};
	GOptionContext* context = NULL;
	GOptionContext* _tmp15_;
	GOptionContext* _tmp16_;
	GOptionEntry* _tmp17_;
	gint _tmp17__length1;
	GOptionContext* _tmp18_;
	GOptionGroup* _tmp19_;
	gchar** args = NULL;
	gint _tmp20_ = 0;
	gchar** _tmp21_;
	gint args_length1;
	gint _args_size_;
	gchar** args_aux = NULL;
	gchar** _tmp22_;
	gint _tmp22__length1;
	gint args_aux_length1;
	gint _args_aux_size_;
	GFile** files = NULL;
	gint files_length1;
	gint _files_size_;
	gchar** _tmp29_;
	gint _tmp29__length1;
	GFile** _tmp46_;
	gint _tmp46__length1;
	gint _tmp62_;
	GError* _inner_error0_ = NULL;
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (cmd != NULL, 0);
	version = FALSE;
	open_in_tab = TRUE;
	create_new_window = FALSE;
	kill_shell = FALSE;
	debug = FALSE;
	_tmp0_ = g_new0 (GOptionEntry, 7);
	options = _tmp0_;
	options_length1 = 7;
	_options_size_ = options_length1;
	_tmp1_ = options;
	_tmp1__length1 = options_length1;
	_tmp2_.long_name = "version";
	_tmp2_.short_name = '\0';
	_tmp2_.flags = (gint) 0;
	_tmp2_.arg = G_OPTION_ARG_NONE;
	_tmp2_.arg_data = &version;
	_tmp2_.description = N_ ("Show the version of the program");
	_tmp2_.arg_description = NULL;
	_tmp1_[0] = _tmp2_;
	_tmp3_ = options;
	_tmp3__length1 = options_length1;
	_tmp4_.long_name = "tab";
	_tmp4_.short_name = 't';
	_tmp4_.flags = (gint) 0;
	_tmp4_.arg = G_OPTION_ARG_NONE;
	_tmp4_.arg_data = &open_in_tab;
	_tmp4_.description = N_ ("Open one or more URIs, each in their own tab");
	_tmp4_.arg_description = NULL;
	_tmp3_[1] = _tmp4_;
	_tmp5_ = options;
	_tmp5__length1 = options_length1;
	_tmp6_.long_name = "new-window";
	_tmp6_.short_name = 'n';
	_tmp6_.flags = (gint) 0;
	_tmp6_.arg = G_OPTION_ARG_NONE;
	_tmp6_.arg_data = &create_new_window;
	_tmp6_.description = N_ ("New Window");
	_tmp6_.arg_description = NULL;
	_tmp5_[2] = _tmp6_;
	_tmp7_ = options;
	_tmp7__length1 = options_length1;
	_tmp8_.long_name = "quit";
	_tmp8_.short_name = 'q';
	_tmp8_.flags = (gint) 0;
	_tmp8_.arg = G_OPTION_ARG_NONE;
	_tmp8_.arg_data = &kill_shell;
	_tmp8_.description = N_ ("Quit Files");
	_tmp8_.arg_description = NULL;
	_tmp7_[3] = _tmp8_;
	_tmp9_ = options;
	_tmp9__length1 = options_length1;
	_tmp10_.long_name = "debug";
	_tmp10_.short_name = 'd';
	_tmp10_.flags = (gint) 0;
	_tmp10_.arg = G_OPTION_ARG_NONE;
	_tmp10_.arg_data = &debug;
	_tmp10_.description = N_ ("Enable debug logging");
	_tmp10_.arg_description = NULL;
	_tmp9_[4] = _tmp10_;
	_tmp11_ = options;
	_tmp11__length1 = options_length1;
	_tmp12_.long_name = "";
	_tmp12_.short_name = (gchar) 0;
	_tmp12_.flags = (gint) 0;
	_tmp12_.arg = G_OPTION_ARG_STRING_ARRAY;
	_tmp12_.arg_data = &self->priv->remaining;
	_tmp12_.description = NULL;
	_tmp12_.arg_description = N_ ("[URIâ€¦]");
	_tmp11_[5] = _tmp12_;
	_tmp13_ = options;
	_tmp13__length1 = options_length1;
	_tmp14_.long_name = NULL;
	_tmp13_[6] = _tmp14_;
	_tmp15_ = g_option_context_new (_ ("\n\nBrowse the file system with the file manager"));
	context = _tmp15_;
	_tmp16_ = context;
	_tmp17_ = options;
	_tmp17__length1 = options_length1;
	g_option_context_add_main_entries (_tmp16_, _tmp17_, NULL);
	_tmp18_ = context;
	_tmp19_ = gtk_get_option_group (TRUE);
	g_option_context_add_group (_tmp18_, _tmp19_);
	_tmp21_ = g_application_command_line_get_arguments (cmd, &_tmp20_);
	args = _tmp21_;
	args_length1 = _tmp20_;
	_args_size_ = args_length1;
	_tmp22_ = args;
	_tmp22__length1 = args_length1;
	args_aux = _tmp22_;
	args_aux_length1 = _tmp22__length1;
	_args_aux_size_ = args_aux_length1;
	{
		GOptionContext* _tmp23_;
		_tmp23_ = context;
		g_option_context_parse (_tmp23_, (gint*) (&args_aux_length1), &args_aux, &_inner_error0_);
		_args_aux_size_ = args_aux_length1;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			gint _tmp24_ = -1;
			if (_inner_error0_->domain == G_OPTION_ERROR) {
				goto __catch0_g_option_error;
			}
			args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
			_g_option_context_free0 (context);
			options = (g_free (options), NULL);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return _tmp24_;
		}
	}
	goto __finally0;
	__catch0_g_option_error:
	{
		GError* _error_ = NULL;
		GError* _tmp25_;
		const gchar* _tmp26_;
		_error_ = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp25_ = _error_;
		_tmp26_ = _tmp25_->message;
		g_application_command_line_printerr (cmd, "Could not parse arguments: %s\n", _tmp26_);
		result = EXIT_FAILURE;
		_g_error_free0 (_error_);
		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
		_g_option_context_free0 (context);
		options = (g_free (options), NULL);
		return result;
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gint _tmp27_ = -1;
		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
		_g_option_context_free0 (context);
		options = (g_free (options), NULL);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return _tmp27_;
	}
	if (debug) {
		g_setenv ("G_MESSAGES_DEBUG", "all", FALSE);
	}
	if (version) {
		g_application_command_line_print (cmd, "io.elementary.files %s\n", VERSION);
		result = EXIT_SUCCESS;
		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
		_g_option_context_free0 (context);
		options = (g_free (options), NULL);
		return result;
	}
	if (kill_shell) {
		gchar** _tmp28_;
		gint _tmp28__length1;
		_tmp28_ = self->priv->remaining;
		_tmp28__length1 = _vala_array_length (self->priv->remaining);
		if (_tmp28_ != NULL) {
			g_application_command_line_printerr (cmd, "%s\n", _ ("--quit cannot be used with URIs."));
			result = EXIT_FAILURE;
			args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
			_g_option_context_free0 (context);
			options = (g_free (options), NULL);
			return result;
		} else {
			files_application_quit (self);
			result = EXIT_SUCCESS;
			args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
			_g_option_context_free0 (context);
			options = (g_free (options), NULL);
			return result;
		}
	}
	files = NULL;
	files_length1 = 0;
	_files_size_ = files_length1;
	_tmp29_ = self->priv->remaining;
	_tmp29__length1 = _vala_array_length (self->priv->remaining);
	{
		gchar** filepath_collection = NULL;
		gint filepath_collection_length1 = 0;
		gint _filepath_collection_size_ = 0;
		gint filepath_it = 0;
		filepath_collection = _tmp29_;
		filepath_collection_length1 = _tmp29__length1;
		for (filepath_it = 0; filepath_it < filepath_collection_length1; filepath_it = filepath_it + 1) {
			gchar* _tmp30_;
			gchar* filepath = NULL;
			_tmp30_ = g_strdup (filepath_collection[filepath_it]);
			filepath = _tmp30_;
			{
				gchar* path = NULL;
				const gchar* _tmp31_;
				gchar* _tmp32_;
				gchar* _tmp33_;
				gchar* _tmp34_;
				gchar* _tmp35_;
				GFile* file = NULL;
				const gchar* _tmp36_;
				gint _tmp37_;
				gint _tmp38_;
				GFile* _tmp43_;
				_tmp31_ = filepath;
				_tmp32_ = g_get_current_dir ();
				_tmp33_ = _tmp32_;
				_tmp34_ = files_file_utils_sanitize_path (_tmp31_, _tmp33_, TRUE);
				_tmp35_ = _tmp34_;
				_g_free0 (_tmp33_);
				path = _tmp35_;
				file = NULL;
				_tmp36_ = path;
				_tmp37_ = strlen (_tmp36_);
				_tmp38_ = _tmp37_;
				if (_tmp38_ > 0) {
					const gchar* _tmp39_;
					gchar* _tmp40_;
					gchar* _tmp41_;
					GFile* _tmp42_;
					_tmp39_ = path;
					_tmp40_ = files_file_utils_escape_uri (_tmp39_, TRUE, TRUE);
					_tmp41_ = _tmp40_;
					_tmp42_ = g_file_new_for_uri (_tmp41_);
					_g_object_unref0 (file);
					file = _tmp42_;
					_g_free0 (_tmp41_);
				}
				_tmp43_ = file;
				if (_tmp43_ != NULL) {
					GFile* _tmp44_;
					GFile* _tmp45_;
					_tmp44_ = file;
					_tmp45_ = _g_object_ref0 (_tmp44_);
					_vala_array_add1 (&files, &files_length1, &_files_size_, _tmp45_);
				}
				_g_object_unref0 (file);
				_g_free0 (path);
				_g_free0 (filepath);
			}
		}
	}
	_tmp46_ = files;
	_tmp46__length1 = files_length1;
	if (_tmp46_ != NULL) {
		gboolean _tmp47_ = FALSE;
		if (create_new_window) {
			_tmp47_ = TRUE;
		} else {
			gint _tmp48_;
			_tmp48_ = self->priv->_window_count;
			_tmp47_ = _tmp48_ == 0;
		}
		if (_tmp47_) {
			GFile** _tmp49_;
			gint _tmp49__length1;
			FilesViewWindow* _tmp50_;
			FilesViewWindow* _tmp51_;
			_tmp49_ = files;
			_tmp49__length1 = files_length1;
			_tmp50_ = files_application_create_window_with_tabs (self, _tmp49_, (gint) _tmp49__length1, FILES_VIEW_MODE_PREFERRED);
			_tmp51_ = _tmp50_;
			_g_object_unref0 (_tmp51_);
		} else {
			FilesViewWindow* win = NULL;
			GtkWindow* _tmp52_;
			FilesViewWindow* _tmp53_;
			FilesViewWindow* _tmp54_;
			GFile** _tmp55_;
			gint _tmp55__length1;
			_tmp52_ = gtk_application_get_active_window ((GtkApplication*) self);
			_tmp53_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp52_, FILES_VIEW_TYPE_WINDOW, FilesViewWindow));
			win = _tmp53_;
			_tmp54_ = win;
			_tmp55_ = files;
			_tmp55__length1 = files_length1;
			files_view_window_open_tabs (_tmp54_, _tmp55_, (gint) _tmp55__length1, FILES_VIEW_MODE_PREFERRED, TRUE);
			_g_object_unref0 (win);
		}
	} else {
		gboolean _tmp56_ = FALSE;
		if (create_new_window) {
			_tmp56_ = TRUE;
		} else {
			gint _tmp57_;
			_tmp57_ = self->priv->_window_count;
			_tmp56_ = _tmp57_ == 0;
		}
		if (_tmp56_) {
			GFile** _tmp58_;
			GFile** _tmp59_;
			gint _tmp59__length1;
			FilesViewWindow* _tmp60_;
			FilesViewWindow* _tmp61_;
			_tmp58_ = g_new0 (GFile*, 0 + 1);
			_tmp59_ = _tmp58_;
			_tmp59__length1 = 0;
			_tmp60_ = files_application_create_window_with_tabs (self, _tmp59_, (gint) 0, FILES_VIEW_MODE_PREFERRED);
			_tmp61_ = _tmp60_;
			_g_object_unref0 (_tmp61_);
			_tmp59_ = (_vala_array_free (_tmp59_, _tmp59__length1, (GDestroyNotify) g_object_unref), NULL);
		}
	}
	_tmp62_ = self->priv->_window_count;
	if (_tmp62_ > 0) {
		GtkWindow* _tmp63_;
		_tmp63_ = gtk_application_get_active_window ((GtkApplication*) self);
		gtk_window_present (_tmp63_);
		result = EXIT_SUCCESS;
		files = (_vala_array_free (files, files_length1, (GDestroyNotify) g_object_unref), NULL);
		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
		_g_option_context_free0 (context);
		options = (g_free (options), NULL);
		return result;
	} else {
		result = EXIT_FAILURE;
		files = (_vala_array_free (files, files_length1, (GDestroyNotify) g_object_unref), NULL);
		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
		_g_option_context_free0 (context);
		options = (g_free (options), NULL);
		return result;
	}
}

static void
files_application_real_quit_mainloop (GApplication* base)
{
	FilesApplication * self;
	self = (FilesApplication*) base;
	g_warning ("Application.vala:242: Quitting mainloop");
	files_icon_info_clear_caches ();
	G_APPLICATION_CLASS (files_application_parent_class)->quit_mainloop ((GApplication*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_application_get_type (), GtkApplication));
}

static void
__lambda137_ (FilesApplication* self,
              GtkWindow* window)
{
	g_return_if_fail (window != NULL);
	files_view_window_quit (G_TYPE_CHECK_INSTANCE_CAST (window, FILES_VIEW_TYPE_WINDOW, FilesViewWindow));
}

static void
___lambda137__gfunc (gconstpointer data,
                     gpointer self)
{
	__lambda137_ ((FilesApplication*) self, (GtkWindow*) data);
}

void
files_application_quit (FilesApplication* self)
{
	GList* window_list = NULL;
	GList* _tmp0_;
	GList* _tmp1_;
	g_return_if_fail (self != NULL);
	if (self->priv->quitting) {
		return;
	}
	self->priv->quitting = TRUE;
	_tmp0_ = gtk_application_get_windows ((GtkApplication*) self);
	window_list = _tmp0_;
	_tmp1_ = window_list;
	g_list_foreach (_tmp1_, ___lambda137__gfunc, self);
	g_application_quit ((GApplication*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_application_get_type (), GtkApplication));
}

static Block2Data*
block2_data_ref (Block2Data* _data2_)
{
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}

static void
block2_data_unref (void * _userdata_)
{
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		FilesApplication* self;
		self = _data2_->self;
		_g_object_unref0 (_data2_->file);
		_g_object_unref0 (self);
		g_slice_free (Block2Data, _data2_);
	}
}

static void
__lambda108_ (Block2Data* _data2_,
              GtkWindow* window)
{
	FilesApplication* self;
	self = _data2_->self;
	g_return_if_fail (window != NULL);
	g_signal_emit_by_name (G_TYPE_CHECK_INSTANCE_CAST (window, FILES_VIEW_TYPE_WINDOW, FilesViewWindow), "folder-deleted", _data2_->file);
}

static void
___lambda108__gfunc (gconstpointer data,
                     gpointer self)
{
	__lambda108_ (self, (GtkWindow*) data);
}

void
files_application_folder_deleted (FilesApplication* self,
                                  GFile* file)
{
	Block2Data* _data2_;
	GFile* _tmp0_;
	GList* window_list = NULL;
	GList* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	_data2_->self = g_object_ref (self);
	_tmp0_ = _g_object_ref0 (file);
	_g_object_unref0 (_data2_->file);
	_data2_->file = _tmp0_;
	_tmp1_ = gtk_application_get_windows ((GtkApplication*) self);
	window_list = _tmp1_;
	g_list_foreach (window_list, ___lambda108__gfunc, _data2_);
	block2_data_unref (_data2_);
	_data2_ = NULL;
}

static void
files_application_mount_removed_callback (FilesApplication* self,
                                          GVolumeMonitor* monitor,
                                          GMount* mount)
{
	GList* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (monitor != NULL);
	g_return_if_fail (mount != NULL);
	_tmp0_ = gtk_application_get_windows ((GtkApplication*) self);
	{
		GList* window_collection = NULL;
		GList* window_it = NULL;
		window_collection = _tmp0_;
		for (window_it = window_collection; window_it != NULL; window_it = window_it->next) {
			GtkWindow* _tmp1_;
			GtkWindow* window = NULL;
			_tmp1_ = _g_object_ref0 ((GtkWindow*) window_it->data);
			window = _tmp1_;
			{
				GtkWindow* _tmp2_;
				_tmp2_ = window;
				files_view_window_mount_removed (G_TYPE_CHECK_INSTANCE_CAST (_tmp2_, FILES_VIEW_TYPE_WINDOW, FilesViewWindow), mount);
				_g_object_unref0 (window);
			}
		}
	}
}

static void
files_application_init_schemas (FilesApplication* self)
{
	FilesPreferences* prefs = NULL;
	FilesPreferences* _tmp0_;
	GSettings* _tmp1_;
	GSettingsSchema* _tmp2_;
	GSettingsSchema* _tmp3_;
	GSettingsSchema* _tmp4_;
	gboolean _tmp5_;
	GSettings* _tmp8_;
	FilesPreferences* _tmp9_;
	GSettings* _tmp10_;
	FilesPreferences* _tmp11_;
	GSettings* _tmp12_;
	FilesPreferences* _tmp13_;
	GSettings* _tmp14_;
	FilesPreferences* _tmp15_;
	GSettings* _tmp16_;
	FilesPreferences* _tmp17_;
	FilesPreferences* _tmp18_;
	GSettings* _tmp19_;
	FilesPreferences* _tmp20_;
	FilesPreferences* _tmp21_;
	GSettings* _tmp22_;
	FilesPreferences* _tmp23_;
	g_return_if_fail (self != NULL);
	_tmp0_ = files_preferences_get_default ();
	prefs = _tmp0_;
	_tmp1_ = files_app_settings;
	g_object_get (_tmp1_, "settings-schema", &_tmp2_, NULL);
	_tmp3_ = _tmp2_;
	_tmp4_ = _tmp3_;
	_tmp5_ = g_settings_schema_has_key (_tmp4_, "singleclick-select");
	_g_settings_schema_unref0 (_tmp4_);
	if (_tmp5_) {
		GSettings* _tmp6_;
		FilesPreferences* _tmp7_;
		_tmp6_ = files_app_settings;
		_tmp7_ = prefs;
		g_settings_bind (_tmp6_, "singleclick-select", (GObject*) _tmp7_, "singleclick-select", G_SETTINGS_BIND_DEFAULT);
	}
	_tmp8_ = files_app_settings;
	_tmp9_ = prefs;
	g_settings_bind (_tmp8_, "show-hiddenfiles", (GObject*) _tmp9_, "show-hidden-files", G_SETTINGS_BIND_DEFAULT);
	_tmp10_ = files_app_settings;
	_tmp11_ = prefs;
	g_settings_bind (_tmp10_, "show-remote-thumbnails", (GObject*) _tmp11_, "show-remote-thumbnails", G_SETTINGS_BIND_DEFAULT);
	_tmp12_ = files_app_settings;
	_tmp13_ = prefs;
	g_settings_bind (_tmp12_, "show-local-thumbnails", (GObject*) _tmp13_, "show-local-thumbnails", G_SETTINGS_BIND_DEFAULT);
	_tmp14_ = files_app_settings;
	_tmp15_ = prefs;
	g_settings_bind (_tmp14_, "date-format", (GObject*) _tmp15_, "date-format", G_SETTINGS_BIND_DEFAULT);
	_tmp16_ = self->priv->_gnome_interface_settings;
	_tmp17_ = files_preferences_get_default ();
	_tmp18_ = _tmp17_;
	g_settings_bind (_tmp16_, "clock-format", (GObject*) _tmp18_, "clock-format", G_SETTINGS_BIND_GET);
	_g_object_unref0 (_tmp18_);
	_tmp19_ = self->priv->_gnome_privacy_settings;
	_tmp20_ = files_preferences_get_default ();
	_tmp21_ = _tmp20_;
	g_settings_bind (_tmp19_, "remember-recent-files", (GObject*) _tmp21_, "remember-history", G_SETTINGS_BIND_GET);
	_g_object_unref0 (_tmp21_);
	_tmp22_ = self->priv->_gtk_file_chooser_settings;
	_tmp23_ = prefs;
	g_settings_bind (_tmp22_, "sort-directories-first", (GObject*) _tmp23_, "sort-directories-first", G_SETTINGS_BIND_DEFAULT);
	_g_object_unref0 (prefs);
}

FilesViewWindow*
files_application_create_window (FilesApplication* self,
                                 GFile* location,
                                 FilesViewMode viewmode)
{
	GFile* _tmp0_;
	GFile** _tmp1_;
	GFile** _tmp2_;
	gint _tmp2__length1;
	FilesViewWindow* _tmp3_;
	FilesViewWindow* _tmp4_;
	FilesViewWindow* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = _g_object_ref0 (location);
	_tmp1_ = g_new0 (GFile*, 1 + 1);
	_tmp1_[0] = _tmp0_;
	_tmp2_ = _tmp1_;
	_tmp2__length1 = 1;
	_tmp3_ = files_application_create_window_with_tabs (self, _tmp2_, (gint) 1, viewmode);
	_tmp4_ = _tmp3_;
	_tmp2_ = (_vala_array_free (_tmp2_, _tmp2__length1, (GDestroyNotify) g_object_unref), NULL);
	result = _tmp4_;
	return result;
}

static FilesViewWindow*
files_application_create_window_with_tabs (FilesApplication* self,
                                           GFile** locations,
                                           gint locations_length1,
                                           FilesViewMode viewmode)
{
	GList* _tmp0_;
	FilesViewWindow* win = NULL;
	GdkScreen* _tmp1_;
	FilesViewWindow* _tmp2_;
	FilesViewWindow* _tmp3_;
	FilesPluginManager* _tmp4_;
	FilesViewWindow* _tmp5_;
	FilesViewWindow* _tmp6_;
	FilesViewWindow* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = gtk_application_get_windows ((GtkApplication*) self);
	if (g_list_length (_tmp0_) >= FILES_APPLICATION_MAX_WINDOWS) {
		result = NULL;
		return result;
	}
	_tmp1_ = gdk_screen_get_default ();
	_tmp2_ = files_view_window_new (self, _tmp1_);
	g_object_ref_sink (_tmp2_);
	win = _tmp2_;
	_tmp3_ = win;
	gtk_application_add_window ((GtkApplication*) self, G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, gtk_window_get_type ()) ? ((GtkWindow*) _tmp3_) : NULL);
	_tmp4_ = plugins;
	_tmp5_ = win;
	files_plugin_manager_interface_loaded (_tmp4_, G_TYPE_CHECK_INSTANCE_TYPE (_tmp5_, gtk_widget_get_type ()) ? ((GtkWidget*) _tmp5_) : NULL);
	_tmp6_ = win;
	files_view_window_open_tabs (_tmp6_, locations, (gint) locations_length1, viewmode, FALSE);
	result = win;
	return result;
}

FilesApplication*
files_application_construct (GType object_type)
{
	FilesApplication * self = NULL;
	self = (FilesApplication*) g_object_new (object_type, NULL);
	return self;
}

FilesApplication*
files_application_new (void)
{
	return files_application_construct (FILES_TYPE_APPLICATION);
}

GSettings*
files_application_get_gnome_interface_settings (FilesApplication* self)
{
	GSettings* result;
	GSettings* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_gnome_interface_settings;
	result = _tmp0_;
	return result;
}

static void
files_application_set_gnome_interface_settings (FilesApplication* self,
                                                GSettings* value)
{
	GSettings* old_value;
	g_return_if_fail (self != NULL);
	old_value = files_application_get_gnome_interface_settings (self);
	if (old_value != value) {
		GSettings* _tmp0_;
		_tmp0_ = _g_object_ref0 (value);
		_g_object_unref0 (self->priv->_gnome_interface_settings);
		self->priv->_gnome_interface_settings = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, files_application_properties[FILES_APPLICATION_GNOME_INTERFACE_SETTINGS_PROPERTY]);
	}
}

GSettings*
files_application_get_gnome_privacy_settings (FilesApplication* self)
{
	GSettings* result;
	GSettings* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_gnome_privacy_settings;
	result = _tmp0_;
	return result;
}

static void
files_application_set_gnome_privacy_settings (FilesApplication* self,
                                              GSettings* value)
{
	GSettings* old_value;
	g_return_if_fail (self != NULL);
	old_value = files_application_get_gnome_privacy_settings (self);
	if (old_value != value) {
		GSettings* _tmp0_;
		_tmp0_ = _g_object_ref0 (value);
		_g_object_unref0 (self->priv->_gnome_privacy_settings);
		self->priv->_gnome_privacy_settings = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, files_application_properties[FILES_APPLICATION_GNOME_PRIVACY_SETTINGS_PROPERTY]);
	}
}

GSettings*
files_application_get_gtk_file_chooser_settings (FilesApplication* self)
{
	GSettings* result;
	GSettings* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_gtk_file_chooser_settings;
	result = _tmp0_;
	return result;
}

static void
files_application_set_gtk_file_chooser_settings (FilesApplication* self,
                                                 GSettings* value)
{
	GSettings* old_value;
	g_return_if_fail (self != NULL);
	old_value = files_application_get_gtk_file_chooser_settings (self);
	if (old_value != value) {
		GSettings* _tmp0_;
		_tmp0_ = _g_object_ref0 (value);
		_g_object_unref0 (self->priv->_gtk_file_chooser_settings);
		self->priv->_gtk_file_chooser_settings = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, files_application_properties[FILES_APPLICATION_GTK_FILE_CHOOSER_SETTINGS_PROPERTY]);
	}
}

gint
files_application_get_window_count (FilesApplication* self)
{
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_window_count;
	return result;
}

static void
files_application_set_window_count (FilesApplication* self,
                                    gint value)
{
	gint old_value;
	g_return_if_fail (self != NULL);
	old_value = files_application_get_window_count (self);
	if (old_value != value) {
		self->priv->_window_count = value;
		g_object_notify_by_pspec ((GObject *) self, files_application_properties[FILES_APPLICATION_WINDOW_COUNT_PROPERTY]);
	}
}

static GObject *
files_application_constructor (GType type,
                               guint n_construct_properties,
                               GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	FilesApplication * self;
	GSettings* _tmp0_;
	GSettings* _tmp1_;
	GSettings* _tmp2_;
	GSettings* _tmp3_;
	GSettings* _tmp4_;
	GSettings* _tmp5_;
	GApplicationFlags _tmp6_;
	GApplicationFlags _tmp7_;
	parent_class = G_OBJECT_CLASS (files_application_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_TYPE_APPLICATION, FilesApplication);
	_tmp0_ = g_settings_new ("org.gnome.desktop.interface");
	_tmp1_ = _tmp0_;
	files_application_set_gnome_interface_settings (self, _tmp1_);
	_g_object_unref0 (_tmp1_);
	_tmp2_ = g_settings_new ("org.gnome.desktop.privacy");
	_tmp3_ = _tmp2_;
	files_application_set_gnome_privacy_settings (self, _tmp3_);
	_g_object_unref0 (_tmp3_);
	_tmp4_ = g_settings_new ("org.gtk.Settings.FileChooser");
	_tmp5_ = _tmp4_;
	files_application_set_gtk_file_chooser_settings (self, _tmp5_);
	_g_object_unref0 (_tmp5_);
	g_application_set_application_id ((GApplication*) self, FILES_APP_ID);
	_tmp6_ = g_application_get_flags ((GApplication*) self);
	_tmp7_ = _tmp6_;
	g_application_set_flags ((GApplication*) self, _tmp7_ | G_APPLICATION_HANDLES_COMMAND_LINE);
	return obj;
}

static void
files_application_class_init (FilesApplicationClass * klass,
                              gpointer klass_data)
{
	GSettings* _tmp0_;
	GSettings* _tmp1_;
	GSettings* _tmp2_;
	GSettings* _tmp3_;
	files_application_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &FilesApplication_private_offset);
	((GApplicationClass *) klass)->startup = (void (*) (GApplication*)) files_application_real_startup;
	((GApplicationClass *) klass)->command_line = (gint (*) (GApplication*, GApplicationCommandLine*)) files_application_real_command_line;
	((GApplicationClass *) klass)->quit_mainloop = (void (*) (GApplication*)) files_application_real_quit_mainloop;
	G_OBJECT_CLASS (klass)->get_property = _vala_files_application_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_files_application_set_property;
	G_OBJECT_CLASS (klass)->constructor = files_application_constructor;
	G_OBJECT_CLASS (klass)->finalize = files_application_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_APPLICATION_GNOME_INTERFACE_SETTINGS_PROPERTY, files_application_properties[FILES_APPLICATION_GNOME_INTERFACE_SETTINGS_PROPERTY] = g_param_spec_object ("gnome-interface-settings", "gnome-interface-settings", "gnome-interface-settings", g_settings_get_type (), G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_APPLICATION_GNOME_PRIVACY_SETTINGS_PROPERTY, files_application_properties[FILES_APPLICATION_GNOME_PRIVACY_SETTINGS_PROPERTY] = g_param_spec_object ("gnome-privacy-settings", "gnome-privacy-settings", "gnome-privacy-settings", g_settings_get_type (), G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_APPLICATION_GTK_FILE_CHOOSER_SETTINGS_PROPERTY, files_application_properties[FILES_APPLICATION_GTK_FILE_CHOOSER_SETTINGS_PROPERTY] = g_param_spec_object ("gtk-file-chooser-settings", "gtk-file-chooser-settings", "gtk-file-chooser-settings", g_settings_get_type (), G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_APPLICATION_WINDOW_COUNT_PROPERTY, files_application_properties[FILES_APPLICATION_WINDOW_COUNT_PROPERTY] = g_param_spec_int ("window-count", "window-count", "window-count", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	_tmp0_ = g_settings_new ("io.elementary.files.preferences");
	_g_object_unref0 (files_app_settings);
	files_app_settings = _tmp0_;
	_tmp1_ = g_settings_new ("io.elementary.files.icon-view");
	_g_object_unref0 (files_icon_view_settings);
	files_icon_view_settings = _tmp1_;
	_tmp2_ = g_settings_new ("io.elementary.files.list-view");
	_g_object_unref0 (files_list_view_settings);
	files_list_view_settings = _tmp2_;
	_tmp3_ = g_settings_new ("io.elementary.files.column-view");
	_g_object_unref0 (files_column_view_settings);
	files_column_view_settings = _tmp3_;
}

static void
files_application_instance_init (FilesApplication * self,
                                 gpointer klass)
{
	self->priv = files_application_get_instance_private (self);
	self->priv->quitting = FALSE;
	self->priv->remaining = NULL;
}

static void
files_application_finalize (GObject * obj)
{
	FilesApplication * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_TYPE_APPLICATION, FilesApplication);
	_g_object_unref0 (self->priv->volume_monitor);
	_g_object_unref0 (self->priv->progress_handler);
	_g_object_unref0 (self->priv->clipboard);
	_g_object_unref0 (self->priv->recent);
	_g_object_unref0 (self->priv->_gnome_interface_settings);
	_g_object_unref0 (self->priv->_gnome_privacy_settings);
	_g_object_unref0 (self->priv->_gtk_file_chooser_settings);
	self->priv->remaining = (_vala_array_free (self->priv->remaining, _vala_array_length (self->priv->remaining), (GDestroyNotify) g_free), NULL);
	G_OBJECT_CLASS (files_application_parent_class)->finalize (obj);
}

static GType
files_application_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FilesApplicationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) files_application_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FilesApplication), 0, (GInstanceInitFunc) files_application_instance_init, NULL };
	GType files_application_type_id;
	files_application_type_id = g_type_register_static (gtk_application_get_type (), "FilesApplication", &g_define_type_info, 0);
	FilesApplication_private_offset = g_type_add_instance_private (files_application_type_id, sizeof (FilesApplicationPrivate));
	return files_application_type_id;
}

GType
files_application_get_type (void)
{
	static volatile gsize files_application_type_id__once = 0;
	if (g_once_init_enter (&files_application_type_id__once)) {
		GType files_application_type_id;
		files_application_type_id = files_application_get_type_once ();
		g_once_init_leave (&files_application_type_id__once, files_application_type_id);
	}
	return files_application_type_id__once;
}

static void
_vala_files_application_get_property (GObject * object,
                                      guint property_id,
                                      GValue * value,
                                      GParamSpec * pspec)
{
	FilesApplication * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FILES_TYPE_APPLICATION, FilesApplication);
	switch (property_id) {
		case FILES_APPLICATION_GNOME_INTERFACE_SETTINGS_PROPERTY:
		g_value_set_object (value, files_application_get_gnome_interface_settings (self));
		break;
		case FILES_APPLICATION_GNOME_PRIVACY_SETTINGS_PROPERTY:
		g_value_set_object (value, files_application_get_gnome_privacy_settings (self));
		break;
		case FILES_APPLICATION_GTK_FILE_CHOOSER_SETTINGS_PROPERTY:
		g_value_set_object (value, files_application_get_gtk_file_chooser_settings (self));
		break;
		case FILES_APPLICATION_WINDOW_COUNT_PROPERTY:
		g_value_set_int (value, files_application_get_window_count (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_files_application_set_property (GObject * object,
                                      guint property_id,
                                      const GValue * value,
                                      GParamSpec * pspec)
{
	FilesApplication * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FILES_TYPE_APPLICATION, FilesApplication);
	switch (property_id) {
		case FILES_APPLICATION_GNOME_INTERFACE_SETTINGS_PROPERTY:
		files_application_set_gnome_interface_settings (self, g_value_get_object (value));
		break;
		case FILES_APPLICATION_GNOME_PRIVACY_SETTINGS_PROPERTY:
		files_application_set_gnome_privacy_settings (self, g_value_get_object (value));
		break;
		case FILES_APPLICATION_GTK_FILE_CHOOSER_SETTINGS_PROPERTY:
		files_application_set_gtk_file_chooser_settings (self, g_value_get_object (value));
		break;
		case FILES_APPLICATION_WINDOW_COUNT_PROPERTY:
		files_application_set_window_count (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gssize
_vala_array_length (gpointer array)
{
	gssize length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

