/* ViewContainer.c generated by valac 0.56.3, the Vala compiler
 * generated from ViewContainer.vala, do not modify */

#include <gtk/gtk.h>
#include <glib-object.h>
#include "pantheon-files-core.h"
#include <glib.h>
#include <handy.h>
#include <granite.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>
#include <glib/gi18n-lib.h>
#include <gee.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define FILES_VIEW_TYPE_VIEW_CONTAINER (files_view_view_container_get_type ())
#define FILES_VIEW_VIEW_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_VIEW_TYPE_VIEW_CONTAINER, FilesViewViewContainer))
#define FILES_VIEW_VIEW_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_VIEW_TYPE_VIEW_CONTAINER, FilesViewViewContainerClass))
#define FILES_VIEW_IS_VIEW_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_VIEW_TYPE_VIEW_CONTAINER))
#define FILES_VIEW_IS_VIEW_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_VIEW_TYPE_VIEW_CONTAINER))
#define FILES_VIEW_VIEW_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_VIEW_TYPE_VIEW_CONTAINER, FilesViewViewContainerClass))

typedef struct _FilesViewViewContainer FilesViewViewContainer;
typedef struct _FilesViewViewContainerClass FilesViewViewContainerClass;
typedef struct _FilesViewViewContainerPrivate FilesViewViewContainerPrivate;

#define FILES_VIEW_TYPE_WINDOW (files_view_window_get_type ())
#define FILES_VIEW_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_VIEW_TYPE_WINDOW, FilesViewWindow))
#define FILES_VIEW_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_VIEW_TYPE_WINDOW, FilesViewWindowClass))
#define FILES_VIEW_IS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_VIEW_TYPE_WINDOW))
#define FILES_VIEW_IS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_VIEW_TYPE_WINDOW))
#define FILES_VIEW_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_VIEW_TYPE_WINDOW, FilesViewWindowClass))

typedef struct _FilesViewWindow FilesViewWindow;
typedef struct _FilesViewWindowClass FilesViewWindowClass;

#define FILES_VIEW_TYPE_OVERLAY_BAR (files_view_overlay_bar_get_type ())
#define FILES_VIEW_OVERLAY_BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_VIEW_TYPE_OVERLAY_BAR, FilesViewOverlayBar))
#define FILES_VIEW_OVERLAY_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_VIEW_TYPE_OVERLAY_BAR, FilesViewOverlayBarClass))
#define FILES_VIEW_IS_OVERLAY_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_VIEW_TYPE_OVERLAY_BAR))
#define FILES_VIEW_IS_OVERLAY_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_VIEW_TYPE_OVERLAY_BAR))
#define FILES_VIEW_OVERLAY_BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_VIEW_TYPE_OVERLAY_BAR, FilesViewOverlayBarClass))

typedef struct _FilesViewOverlayBar FilesViewOverlayBar;
typedef struct _FilesViewOverlayBarClass FilesViewOverlayBarClass;

#define FILES_VIEW_TYPE_BROWSER (files_view_browser_get_type ())
#define FILES_VIEW_BROWSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_VIEW_TYPE_BROWSER, FilesViewBrowser))
#define FILES_VIEW_BROWSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_VIEW_TYPE_BROWSER, FilesViewBrowserClass))
#define FILES_VIEW_IS_BROWSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_VIEW_TYPE_BROWSER))
#define FILES_VIEW_IS_BROWSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_VIEW_TYPE_BROWSER))
#define FILES_VIEW_BROWSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_VIEW_TYPE_BROWSER, FilesViewBrowserClass))

typedef struct _FilesViewBrowser FilesViewBrowser;
typedef struct _FilesViewBrowserClass FilesViewBrowserClass;
enum  {
	FILES_VIEW_VIEW_CONTAINER_0_PROPERTY,
	FILES_VIEW_VIEW_CONTAINER_ID_PROPERTY,
	FILES_VIEW_VIEW_CONTAINER_CAN_SHOW_FOLDER_PROPERTY,
	FILES_VIEW_VIEW_CONTAINER_WINDOW_PROPERTY,
	FILES_VIEW_VIEW_CONTAINER_LOCATION_PROPERTY,
	FILES_VIEW_VIEW_CONTAINER_URI_PROPERTY,
	FILES_VIEW_VIEW_CONTAINER_SLOT_PROPERTY,
	FILES_VIEW_VIEW_CONTAINER_LOCKED_FOCUS_PROPERTY,
	FILES_VIEW_VIEW_CONTAINER_CAN_GO_BACK_PROPERTY,
	FILES_VIEW_VIEW_CONTAINER_CAN_GO_FORWARD_PROPERTY,
	FILES_VIEW_VIEW_CONTAINER_IS_FROZEN_PROPERTY,
	FILES_VIEW_VIEW_CONTAINER_IS_LOADING_PROPERTY,
	FILES_VIEW_VIEW_CONTAINER_CONTENT_PROPERTY,
	FILES_VIEW_VIEW_CONTAINER_TAB_NAME_PROPERTY,
	FILES_VIEW_VIEW_CONTAINER_NUM_PROPERTIES
};
static GParamSpec* files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define FILES_VIEW_TYPE_MILLER (files_view_miller_get_type ())
#define FILES_VIEW_MILLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_VIEW_TYPE_MILLER, FilesViewMiller))
#define FILES_VIEW_MILLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_VIEW_TYPE_MILLER, FilesViewMillerClass))
#define FILES_VIEW_IS_MILLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_VIEW_TYPE_MILLER))
#define FILES_VIEW_IS_MILLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_VIEW_TYPE_MILLER))
#define FILES_VIEW_MILLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_VIEW_TYPE_MILLER, FilesViewMillerClass))

typedef struct _FilesViewMiller FilesViewMiller;
typedef struct _FilesViewMillerClass FilesViewMillerClass;

#define FILES_VIEW_TYPE_SLOT (files_view_slot_get_type ())
#define FILES_VIEW_SLOT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_VIEW_TYPE_SLOT, FilesViewSlot))
#define FILES_VIEW_SLOT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_VIEW_TYPE_SLOT, FilesViewSlotClass))
#define FILES_VIEW_IS_SLOT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_VIEW_TYPE_SLOT))
#define FILES_VIEW_IS_SLOT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_VIEW_TYPE_SLOT))
#define FILES_VIEW_SLOT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_VIEW_TYPE_SLOT, FilesViewSlotClass))

typedef struct _FilesViewSlot FilesViewSlot;
typedef struct _FilesViewSlotClass FilesViewSlotClass;

#define FILES_VIEW_TYPE_WELCOME (files_view_welcome_get_type ())
#define FILES_VIEW_WELCOME(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_VIEW_TYPE_WELCOME, FilesViewWelcome))
#define FILES_VIEW_WELCOME_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_VIEW_TYPE_WELCOME, FilesViewWelcomeClass))
#define FILES_VIEW_IS_WELCOME(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_VIEW_TYPE_WELCOME))
#define FILES_VIEW_IS_WELCOME_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_VIEW_TYPE_WELCOME))
#define FILES_VIEW_WELCOME_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_VIEW_TYPE_WELCOME, FilesViewWelcomeClass))

typedef struct _FilesViewWelcome FilesViewWelcome;
typedef struct _FilesViewWelcomeClass FilesViewWelcomeClass;

#define FILES_VIEW_TYPE_PRIVACY_MODE_ON (files_view_privacy_mode_on_get_type ())
#define FILES_VIEW_PRIVACY_MODE_ON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_VIEW_TYPE_PRIVACY_MODE_ON, FilesViewPrivacyModeOn))
#define FILES_VIEW_PRIVACY_MODE_ON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_VIEW_TYPE_PRIVACY_MODE_ON, FilesViewPrivacyModeOnClass))
#define FILES_VIEW_IS_PRIVACY_MODE_ON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_VIEW_TYPE_PRIVACY_MODE_ON))
#define FILES_VIEW_IS_PRIVACY_MODE_ON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_VIEW_TYPE_PRIVACY_MODE_ON))
#define FILES_VIEW_PRIVACY_MODE_ON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_VIEW_TYPE_PRIVACY_MODE_ON, FilesViewPrivacyModeOnClass))

typedef struct _FilesViewPrivacyModeOn FilesViewPrivacyModeOn;
typedef struct _FilesViewPrivacyModeOnClass FilesViewPrivacyModeOnClass;

#define FILES_VIEW_TYPE_DIRECTORY_NOT_FOUND (files_view_directory_not_found_get_type ())
#define FILES_VIEW_DIRECTORY_NOT_FOUND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_VIEW_TYPE_DIRECTORY_NOT_FOUND, FilesViewDirectoryNotFound))
#define FILES_VIEW_DIRECTORY_NOT_FOUND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_VIEW_TYPE_DIRECTORY_NOT_FOUND, FilesViewDirectoryNotFoundClass))
#define FILES_VIEW_IS_DIRECTORY_NOT_FOUND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_VIEW_TYPE_DIRECTORY_NOT_FOUND))
#define FILES_VIEW_IS_DIRECTORY_NOT_FOUND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_VIEW_TYPE_DIRECTORY_NOT_FOUND))
#define FILES_VIEW_DIRECTORY_NOT_FOUND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_VIEW_TYPE_DIRECTORY_NOT_FOUND, FilesViewDirectoryNotFoundClass))

typedef struct _FilesViewDirectoryNotFound FilesViewDirectoryNotFound;
typedef struct _FilesViewDirectoryNotFoundClass FilesViewDirectoryNotFoundClass;
enum  {
	FILES_VIEW_VIEW_CONTAINER_TAB_NAME_CHANGED_SIGNAL,
	FILES_VIEW_VIEW_CONTAINER_LOADING_SIGNAL,
	FILES_VIEW_VIEW_CONTAINER_ACTIVE_SIGNAL,
	FILES_VIEW_VIEW_CONTAINER_NUM_SIGNALS
};
static guint files_view_view_container_signals[FILES_VIEW_VIEW_CONTAINER_NUM_SIGNALS] = {0};
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _FilesViewViewContainer {
	GtkBox parent_instance;
	FilesViewViewContainerPrivate * priv;
	GtkWidget* content_item;
	FilesAbstractSlot* view;
	FilesViewMode view_mode;
};

struct _FilesViewViewContainerClass {
	GtkBoxClass parent_class;
};

struct _FilesViewViewContainerPrivate {
	gint _id;
	gboolean _can_show_folder;
	FilesViewWindow* _window;
	gboolean _is_loading;
	FilesViewOverlayBar* overlay_statusbar;
	FilesViewBrowser* browser;
	GList* selected_locations;
	gchar* label;
};

static gint FilesViewViewContainer_private_offset;
static gpointer files_view_view_container_parent_class = NULL;
static gint files_view_view_container_container_id;
static gint files_view_view_container_container_id = 0;

VALA_EXTERN GType files_view_view_container_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesViewViewContainer, g_object_unref)
VALA_EXTERN GType files_view_window_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesViewWindow, g_object_unref)
VALA_EXTERN GType files_view_overlay_bar_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesViewOverlayBar, g_object_unref)
VALA_EXTERN GType files_view_browser_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesViewBrowser, g_object_unref)
static void _g_object_unref0_ (gpointer var);
static inline void _g_list_free__g_object_unref0_ (GList* self);
VALA_EXTERN gint files_view_view_container_get_next_container_id (void);
VALA_EXTERN FilesViewViewContainer* files_view_view_container_new (FilesViewWindow* win);
VALA_EXTERN FilesViewViewContainer* files_view_view_container_construct (GType object_type,
                                                             FilesViewWindow* win);
VALA_EXTERN void files_view_view_container_set_window (FilesViewViewContainer* self,
                                           FilesViewWindow* value);
VALA_EXTERN FilesViewBrowser* files_view_browser_new (void);
VALA_EXTERN FilesViewBrowser* files_view_browser_construct (GType object_type);
static void files_view_view_container_connect_signals (FilesViewViewContainer* self);
static void __lambda134_ (FilesViewViewContainer* self,
                   gboolean loading);
static void files_view_view_container_set_is_loading (FilesViewViewContainer* self,
                                               gboolean value);
static void ___lambda134__files_view_view_container_loading (FilesViewViewContainer* _sender,
                                                      gboolean is_loading,
                                                      gpointer self);
static gboolean files_view_view_container_on_button_press_event (FilesViewViewContainer* self,
                                                          GdkEventButton* event);
static gboolean _files_view_view_container_on_button_press_event_gtk_widget_button_press_event (GtkWidget* _sender,
                                                                                         GdkEventButton* event,
                                                                                         gpointer self);
static void files_view_view_container_connect_window_signals (FilesViewViewContainer* self);
VALA_EXTERN FilesViewWindow* files_view_view_container_get_window (FilesViewViewContainer* self);
static void files_view_view_container_on_folder_deleted (FilesViewViewContainer* self,
                                                  GFile* deleted);
static void _files_view_view_container_on_folder_deleted_files_view_window_folder_deleted (FilesViewWindow* _sender,
                                                                                    GFile* location,
                                                                                    gpointer self);
static void files_view_view_container_disconnect_signals (FilesViewViewContainer* self);
static void files_view_view_container_disconnect_slot_signals (FilesViewViewContainer* self,
                                                        FilesAbstractSlot* aslot);
static void files_view_view_container_disconnect_window_signals (FilesViewViewContainer* self);
VALA_EXTERN GFile* files_view_view_container_get_location (FilesViewViewContainer* self);
VALA_EXTERN gboolean files_view_view_container_go_up (FilesViewViewContainer* self);
VALA_EXTERN void files_view_view_container_close (FilesViewViewContainer* self);
VALA_EXTERN void files_view_window_remove_content (FilesViewWindow* self,
                                       FilesViewViewContainer* view_container);
static void files_view_view_container_open_location (FilesViewViewContainer* self,
                                              GFile* loc,
                                              FilesOpenFlag flag);
VALA_EXTERN void files_view_view_container_go_back (FilesViewViewContainer* self,
                                        gint n);
VALA_EXTERN gchar* files_view_browser_go_back (FilesViewBrowser* self,
                                   guint n);
VALA_EXTERN void files_view_view_container_go_forward (FilesViewViewContainer* self,
                                           gint n);
VALA_EXTERN gchar* files_view_browser_go_forward (FilesViewBrowser* self,
                                      guint n);
VALA_EXTERN void files_view_view_container_add_view (FilesViewViewContainer* self,
                                         FilesViewMode mode,
                                         GFile* loc,
                                         GFile** to_select,
                                         gint to_select_length1);
VALA_EXTERN FilesViewMiller* files_view_miller_new (GFile* loc,
                                        FilesViewViewContainer* ctab,
                                        FilesViewMode mode);
VALA_EXTERN FilesViewMiller* files_view_miller_construct (GType object_type,
                                              GFile* loc,
                                              FilesViewViewContainer* ctab,
                                              FilesViewMode mode);
VALA_EXTERN GType files_view_miller_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesViewMiller, g_object_unref)
VALA_EXTERN FilesViewSlot* files_view_slot_new (GFile* _location,
                                    FilesViewViewContainer* _ctab,
                                    FilesViewMode _mode);
VALA_EXTERN FilesViewSlot* files_view_slot_construct (GType object_type,
                                          GFile* _location,
                                          FilesViewViewContainer* _ctab,
                                          FilesViewMode _mode);
VALA_EXTERN GType files_view_slot_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesViewSlot, g_object_unref)
VALA_EXTERN FilesViewOverlayBar* files_view_overlay_bar_new (GtkOverlay* overlay);
VALA_EXTERN FilesViewOverlayBar* files_view_overlay_bar_construct (GType object_type,
                                                       GtkOverlay* overlay);
static void files_view_view_container_connect_slot_signals (FilesViewViewContainer* self,
                                                     FilesAbstractSlot* aslot);
static void files_view_view_container_directory_is_loading (FilesViewViewContainer* self,
                                                     GFile* loc);
VALA_EXTERN FilesAbstractSlot* files_view_view_container_get_slot (FilesViewViewContainer* self);
VALA_EXTERN void files_view_view_container_change_view_mode (FilesViewViewContainer* self,
                                                 FilesViewMode mode,
                                                 GFile* loc);
VALA_EXTERN FilesAbstractSlot* files_view_view_container_get_current_slot (FilesViewViewContainer* self);
static void files_view_view_container_store_selection (FilesViewViewContainer* self);
VALA_EXTERN void files_view_view_container_set_active_state (FilesViewViewContainer* self,
                                                 gboolean is_active,
                                                 gboolean animate);
static void files_view_view_container_on_slot_active (FilesViewViewContainer* self,
                                               FilesAbstractSlot* aslot,
                                               gboolean scroll,
                                               gboolean animate);
static void _files_view_view_container_on_slot_active_files_abstract_slot_active (FilesAbstractSlot* _sender,
                                                                           gboolean scroll,
                                                                           gboolean animate,
                                                                           gpointer self);
VALA_EXTERN void files_view_view_container_on_slot_path_changed (FilesViewViewContainer* self,
                                                     FilesAbstractSlot* slot);
static void _files_view_view_container_on_slot_path_changed_files_abstract_slot_path_changed (FilesAbstractSlot* _sender,
                                                                                       gpointer self);
static void files_view_view_container_on_slot_new_container_request (FilesViewViewContainer* self,
                                                              GFile* loc,
                                                              FilesOpenFlag flag);
static void _files_view_view_container_on_slot_new_container_request_files_abstract_slot_new_container_request (FilesAbstractSlot* _sender,
                                                                                                         GFile* loc,
                                                                                                         FilesOpenFlag flag,
                                                                                                         gpointer self);
static void files_view_view_container_on_slot_selection_changed (FilesViewViewContainer* self,
                                                          GList* files);
static void _files_view_view_container_on_slot_selection_changed_files_abstract_slot_selection_changed (FilesAbstractSlot* _sender,
                                                                                                 GList* files,
                                                                                                 gpointer self);
VALA_EXTERN void files_view_view_container_on_slot_directory_loaded (FilesViewViewContainer* self,
                                                         FilesDirectory* dir);
static void _files_view_view_container_on_slot_directory_loaded_files_abstract_slot_directory_loaded (FilesAbstractSlot* _sender,
                                                                                               FilesDirectory* dir,
                                                                                               gpointer self);
static void files_view_view_container_refresh_slot_info (FilesViewViewContainer* self,
                                                  GFile* loc);
VALA_EXTERN void files_view_window_uri_path_change_request (FilesViewWindow* self,
                                                const gchar* p,
                                                FilesOpenFlag flag);
VALA_EXTERN void files_view_overlay_bar_cancel (FilesViewOverlayBar* self);
static void files_view_view_container_set_can_show_folder (FilesViewViewContainer* self,
                                                    gboolean value);
static void files_view_view_container_update_tab_name (FilesViewViewContainer* self);
VALA_EXTERN const gchar* files_view_view_container_get_uri (FilesViewViewContainer* self);
static void files_view_view_container_set_tab_name (FilesViewViewContainer* self,
                                             const gchar* value);
VALA_EXTERN gboolean files_view_view_container_get_can_show_folder (FilesViewViewContainer* self);
VALA_EXTERN FilesViewPrivacyModeOn* files_view_privacy_mode_on_new (FilesViewViewContainer* tab);
VALA_EXTERN FilesViewPrivacyModeOn* files_view_privacy_mode_on_construct (GType object_type,
                                                              FilesViewViewContainer* tab);
VALA_EXTERN GType files_view_welcome_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesViewWelcome, g_object_unref)
VALA_EXTERN GType files_view_privacy_mode_on_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesViewPrivacyModeOn, g_object_unref)
VALA_EXTERN void files_view_view_container_set_content (FilesViewViewContainer* self,
                                            GtkWidget* value);
VALA_EXTERN FilesViewDirectoryNotFound* files_view_directory_not_found_new (FilesDirectory* dir,
                                                                FilesViewViewContainer* tab);
VALA_EXTERN FilesViewDirectoryNotFound* files_view_directory_not_found_construct (GType object_type,
                                                                      FilesDirectory* dir,
                                                                      FilesViewViewContainer* tab);
VALA_EXTERN GType files_view_directory_not_found_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesViewDirectoryNotFound, g_object_unref)
VALA_EXTERN FilesViewWelcome* files_view_welcome_new (const gchar* primary,
                                          const gchar* secondary);
VALA_EXTERN FilesViewWelcome* files_view_welcome_construct (GType object_type,
                                                const gchar* primary,
                                                const gchar* secondary);
VALA_EXTERN void files_view_view_container_focus_location_if_in_current_directory (FilesViewViewContainer* self,
                                                                       GFile* loc,
                                                                       gboolean unselect_others);
VALA_EXTERN void files_view_browser_record_uri (FilesViewBrowser* self,
                                    const gchar* uri);
static void ___lambda135_ (FilesViewViewContainer* self,
                    FilesFile* file);
static void ____lambda135__gfunc (gconstpointer data,
                           gpointer self);
static void files_view_view_container_set_all_selected (FilesViewViewContainer* self,
                                                 gboolean select_all);
VALA_EXTERN void files_view_view_container_focus_location (FilesViewViewContainer* self,
                                               GFile* loc,
                                               gboolean no_path_change,
                                               gboolean unselect_others);
VALA_EXTERN gchar* files_view_view_container_get_root_uri (FilesViewViewContainer* self);
VALA_EXTERN gchar* files_view_view_container_get_tip_uri (FilesViewViewContainer* self);
VALA_EXTERN void files_view_view_container_reload (FilesViewViewContainer* self);
VALA_EXTERN GeeList* files_view_view_container_get_go_back_path_list (FilesViewViewContainer* self);
VALA_EXTERN GeeList* files_view_browser_go_back_list (FilesViewBrowser* self);
VALA_EXTERN GeeList* files_view_view_container_get_go_forward_path_list (FilesViewViewContainer* self);
VALA_EXTERN GeeList* files_view_browser_go_forward_list (FilesViewBrowser* self);
VALA_EXTERN void files_view_view_container_grab_focus (FilesViewViewContainer* self);
VALA_EXTERN void files_view_view_container_set_is_frozen (FilesViewViewContainer* self,
                                              gboolean value);
VALA_EXTERN GtkWidget* files_view_view_container_get_content (FilesViewViewContainer* self);
VALA_EXTERN void files_view_overlay_bar_selection_changed (FilesViewOverlayBar* self,
                                               GList* files);
VALA_EXTERN gint files_view_view_container_get_id (FilesViewViewContainer* self);
static void files_view_view_container_set_id (FilesViewViewContainer* self,
                                       gint value);
VALA_EXTERN gboolean files_view_view_container_get_locked_focus (FilesViewViewContainer* self);
VALA_EXTERN gboolean files_view_view_container_get_can_go_back (FilesViewViewContainer* self);
VALA_EXTERN gboolean files_view_browser_get_can_go_back (FilesViewBrowser* self);
VALA_EXTERN gboolean files_view_view_container_get_can_go_forward (FilesViewViewContainer* self);
VALA_EXTERN gboolean files_view_browser_get_can_go_forward (FilesViewBrowser* self);
VALA_EXTERN gboolean files_view_view_container_get_is_frozen (FilesViewViewContainer* self);
VALA_EXTERN gboolean files_view_view_container_get_is_loading (FilesViewViewContainer* self);
VALA_EXTERN const gchar* files_view_view_container_get_tab_name (FilesViewViewContainer* self);
static GObject * files_view_view_container_constructor (GType type,
                                                 guint n_construct_properties,
                                                 GObjectConstructParam * construct_properties);
static void files_view_view_container_finalize (GObject * obj);
static GType files_view_view_container_get_type_once (void);
static void _vala_files_view_view_container_get_property (GObject * object,
                                                   guint property_id,
                                                   GValue * value,
                                                   GParamSpec * pspec);
static void _vala_files_view_view_container_set_property (GObject * object,
                                                   guint property_id,
                                                   const GValue * value,
                                                   GParamSpec * pspec);

static inline gpointer
files_view_view_container_get_instance_private (FilesViewViewContainer* self)
{
	return G_STRUCT_MEMBER_P (self, FilesViewViewContainer_private_offset);
}

static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}

static inline void
_g_list_free__g_object_unref0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_object_unref0_);
}

gint
files_view_view_container_get_next_container_id (void)
{
	gint _tmp0_;
	gint result;
	files_view_view_container_container_id = files_view_view_container_container_id + 1;
	_tmp0_ = files_view_view_container_container_id;
	result = _tmp0_;
	return result;
}

FilesViewViewContainer*
files_view_view_container_construct (GType object_type,
                                     FilesViewWindow* win)
{
	FilesViewViewContainer * self = NULL;
	FilesViewBrowser* _tmp0_;
	g_return_val_if_fail (win != NULL, NULL);
	self = (FilesViewViewContainer*) g_object_new (object_type, NULL);
	files_view_view_container_set_window (self, win);
	_tmp0_ = files_view_browser_new ();
	_g_object_unref0 (self->priv->browser);
	self->priv->browser = _tmp0_;
	gtk_widget_set_events ((GtkWidget*) self, (gint) (GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK));
	files_view_view_container_connect_signals (self);
	return self;
}

FilesViewViewContainer*
files_view_view_container_new (FilesViewWindow* win)
{
	return files_view_view_container_construct (FILES_VIEW_TYPE_VIEW_CONTAINER, win);
}

static void
__lambda134_ (FilesViewViewContainer* self,
              gboolean loading)
{
	files_view_view_container_set_is_loading (self, loading);
}

static void
___lambda134__files_view_view_container_loading (FilesViewViewContainer* _sender,
                                                 gboolean is_loading,
                                                 gpointer self)
{
	__lambda134_ ((FilesViewViewContainer*) self, is_loading);
}

static gboolean
_files_view_view_container_on_button_press_event_gtk_widget_button_press_event (GtkWidget* _sender,
                                                                                GdkEventButton* event,
                                                                                gpointer self)
{
	gboolean result;
	result = files_view_view_container_on_button_press_event ((FilesViewViewContainer*) self, event);
	return result;
}

static void
files_view_view_container_connect_signals (FilesViewViewContainer* self)
{
	g_return_if_fail (self != NULL);
	g_signal_connect_object (self, "loading", (GCallback) ___lambda134__files_view_view_container_loading, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "button-press-event", (GCallback) _files_view_view_container_on_button_press_event_gtk_widget_button_press_event, self, 0);
}

static void
_files_view_view_container_on_folder_deleted_files_view_window_folder_deleted (FilesViewWindow* _sender,
                                                                               GFile* location,
                                                                               gpointer self)
{
	files_view_view_container_on_folder_deleted ((FilesViewViewContainer*) self, location);
}

static void
files_view_view_container_connect_window_signals (FilesViewViewContainer* self)
{
	FilesViewWindow* _tmp0_;
	FilesViewWindow* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = files_view_view_container_get_window (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_ != NULL) {
		FilesViewWindow* _tmp2_;
		FilesViewWindow* _tmp3_;
		_tmp2_ = files_view_view_container_get_window (self);
		_tmp3_ = _tmp2_;
		g_signal_connect_object (_tmp3_, "folder-deleted", (GCallback) _files_view_view_container_on_folder_deleted_files_view_window_folder_deleted, self, 0);
	}
}

static void
files_view_view_container_disconnect_signals (FilesViewViewContainer* self)
{
	FilesAbstractSlot* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->view;
	files_view_view_container_disconnect_slot_signals (self, _tmp0_);
	files_view_view_container_disconnect_window_signals (self);
}

static void
files_view_view_container_disconnect_window_signals (FilesViewViewContainer* self)
{
	FilesViewWindow* _tmp0_;
	FilesViewWindow* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = files_view_view_container_get_window (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_ != NULL) {
		FilesViewWindow* _tmp2_;
		FilesViewWindow* _tmp3_;
		guint _tmp4_;
		_tmp2_ = files_view_view_container_get_window (self);
		_tmp3_ = _tmp2_;
		g_signal_parse_name ("folder-deleted", FILES_VIEW_TYPE_WINDOW, &_tmp4_, NULL, FALSE);
		g_signal_handlers_disconnect_matched (_tmp3_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp4_, 0, NULL, (GCallback) _files_view_view_container_on_folder_deleted_files_view_window_folder_deleted, self);
	}
}

static void
files_view_view_container_on_folder_deleted (FilesViewViewContainer* self,
                                             GFile* deleted)
{
	GFile* _tmp0_;
	GFile* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (deleted != NULL);
	_tmp0_ = files_view_view_container_get_location (self);
	_tmp1_ = _tmp0_;
	if (g_file_equal (deleted, _tmp1_)) {
		if (!files_view_view_container_go_up (self)) {
			FilesViewWindow* _tmp2_;
			FilesViewWindow* _tmp3_;
			files_view_view_container_close (self);
			_tmp2_ = files_view_view_container_get_window (self);
			_tmp3_ = _tmp2_;
			files_view_window_remove_content (_tmp3_, self);
		}
	}
}

void
files_view_view_container_close (FilesViewViewContainer* self)
{
	FilesAbstractSlot* _tmp0_;
	g_return_if_fail (self != NULL);
	files_view_view_container_disconnect_signals (self);
	_tmp0_ = self->view;
	files_abstract_slot_close (_tmp0_);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

gboolean
files_view_view_container_go_up (FilesViewViewContainer* self)
{
	GFile* _tmp0_;
	GFile* _tmp1_;
	GFile* _tmp2_;
	GFile* parent = NULL;
	GFile* _tmp3_;
	GFile* _tmp4_;
	GFile* _tmp5_;
	FilesAbstractSlot* _tmp6_;
	FilesDirectory* _tmp7_;
	FilesDirectory* _tmp8_;
	GFile* _tmp21_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	(self->priv->selected_locations == NULL) ? NULL : (self->priv->selected_locations = (_g_list_free__g_object_unref0_ (self->priv->selected_locations), NULL));
	self->priv->selected_locations = NULL;
	_tmp0_ = files_view_view_container_get_location (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	self->priv->selected_locations = g_list_append (self->priv->selected_locations, _tmp2_);
	_tmp3_ = files_view_view_container_get_location (self);
	_tmp4_ = _tmp3_;
	_tmp5_ = _g_object_ref0 (_tmp4_);
	parent = _tmp5_;
	_tmp6_ = self->view;
	_tmp7_ = files_abstract_slot_get_directory (_tmp6_);
	_tmp8_ = _tmp7_;
	if (files_directory_has_parent (_tmp8_)) {
		FilesAbstractSlot* _tmp9_;
		FilesDirectory* _tmp10_;
		FilesDirectory* _tmp11_;
		GFile* _tmp12_;
		_tmp9_ = self->view;
		_tmp10_ = files_abstract_slot_get_directory (_tmp9_);
		_tmp11_ = _tmp10_;
		_tmp12_ = files_directory_get_parent (_tmp11_);
		_g_object_unref0 (parent);
		parent = _tmp12_;
	} else {
		gchar* parent_path = NULL;
		GFile* _tmp13_;
		GFile* _tmp14_;
		gchar* _tmp15_;
		gchar* _tmp16_;
		gchar* _tmp17_;
		gchar* _tmp18_;
		const gchar* _tmp19_;
		GFile* _tmp20_;
		_tmp13_ = files_view_view_container_get_location (self);
		_tmp14_ = _tmp13_;
		_tmp15_ = g_file_get_uri (_tmp14_);
		_tmp16_ = _tmp15_;
		_tmp17_ = files_file_utils_get_parent_path_from_path (_tmp16_, TRUE);
		_tmp18_ = _tmp17_;
		_g_free0 (_tmp16_);
		parent_path = _tmp18_;
		_tmp19_ = parent_path;
		_tmp20_ = files_file_utils_get_file_for_path (_tmp19_);
		_g_object_unref0 (parent);
		parent = _tmp20_;
		_g_free0 (parent_path);
	}
	_tmp21_ = parent;
	if (_tmp21_ != NULL) {
		GFile* _tmp22_;
		_tmp22_ = parent;
		files_view_view_container_open_location (self, _tmp22_, FILES_OPEN_FLAG_NEW_ROOT);
		result = TRUE;
		_g_object_unref0 (parent);
		return result;
	} else {
		result = FALSE;
		_g_object_unref0 (parent);
		return result;
	}
}

void
files_view_view_container_go_back (FilesViewViewContainer* self,
                                   gint n)
{
	gchar* path = NULL;
	FilesViewBrowser* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->browser;
	_tmp1_ = files_view_browser_go_back (_tmp0_, (guint) n);
	path = _tmp1_;
	_tmp2_ = path;
	if (_tmp2_ != NULL) {
		GFile* _tmp3_;
		GFile* _tmp4_;
		GFile* _tmp5_;
		const gchar* _tmp6_;
		GFile* _tmp7_;
		GFile* _tmp8_;
		(self->priv->selected_locations == NULL) ? NULL : (self->priv->selected_locations = (_g_list_free__g_object_unref0_ (self->priv->selected_locations), NULL));
		self->priv->selected_locations = NULL;
		_tmp3_ = files_view_view_container_get_location (self);
		_tmp4_ = _tmp3_;
		_tmp5_ = _g_object_ref0 (_tmp4_);
		self->priv->selected_locations = g_list_append (self->priv->selected_locations, _tmp5_);
		_tmp6_ = path;
		_tmp7_ = g_file_new_for_commandline_arg (_tmp6_);
		_tmp8_ = _tmp7_;
		files_view_view_container_open_location (self, _tmp8_, FILES_OPEN_FLAG_NEW_ROOT);
		_g_object_unref0 (_tmp8_);
	}
	_g_free0 (path);
}

void
files_view_view_container_go_forward (FilesViewViewContainer* self,
                                      gint n)
{
	gchar* path = NULL;
	FilesViewBrowser* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->browser;
	_tmp1_ = files_view_browser_go_forward (_tmp0_, (guint) n);
	path = _tmp1_;
	_tmp2_ = path;
	if (_tmp2_ != NULL) {
		const gchar* _tmp3_;
		GFile* _tmp4_;
		GFile* _tmp5_;
		_tmp3_ = path;
		_tmp4_ = g_file_new_for_commandline_arg (_tmp3_);
		_tmp5_ = _tmp4_;
		files_view_view_container_open_location (self, _tmp5_, FILES_OPEN_FLAG_NEW_ROOT);
		_g_object_unref0 (_tmp5_);
	}
	_g_free0 (path);
}

void
files_view_view_container_add_view (FilesViewViewContainer* self,
                                    FilesViewMode mode,
                                    GFile* loc,
                                    GFile** to_select,
                                    gint to_select_length1)
{
	FilesAbstractSlot* _tmp5_;
	GtkOverlay* _tmp6_;
	GtkOverlay* _tmp7_;
	FilesViewOverlayBar* _tmp8_ = NULL;
	FilesAbstractSlot* _tmp9_;
	FilesAbstractSlot* _tmp10_;
	FilesAbstractSlot* _tmp11_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (loc != NULL);
	self->view_mode = mode;
	if (to_select != NULL) {
		(self->priv->selected_locations == NULL) ? NULL : (self->priv->selected_locations = (_g_list_free__g_object_unref0_ (self->priv->selected_locations), NULL));
		self->priv->selected_locations = NULL;
		{
			GFile** f_collection = NULL;
			gint f_collection_length1 = 0;
			gint _f_collection_size_ = 0;
			gint f_it = 0;
			f_collection = to_select;
			f_collection_length1 = to_select_length1;
			for (f_it = 0; f_it < f_collection_length1; f_it = f_it + 1) {
				GFile* _tmp0_;
				GFile* f = NULL;
				_tmp0_ = _g_object_ref0 (f_collection[f_it]);
				f = _tmp0_;
				{
					GFile* _tmp1_;
					GFile* _tmp2_;
					_tmp1_ = f;
					_tmp2_ = _g_object_ref0 (_tmp1_);
					self->priv->selected_locations = g_list_prepend (self->priv->selected_locations, _tmp2_);
					_g_object_unref0 (f);
				}
			}
		}
	}
	if (mode == FILES_VIEW_MODE_MILLER_COLUMNS) {
		FilesViewMiller* _tmp3_;
		_tmp3_ = files_view_miller_new (loc, self, mode);
		_g_object_unref0 (self->view);
		self->view = (FilesAbstractSlot*) _tmp3_;
	} else {
		FilesViewSlot* _tmp4_;
		_tmp4_ = files_view_slot_new (loc, self, mode);
		_g_object_unref0 (self->view);
		self->view = (FilesAbstractSlot*) _tmp4_;
	}
	_tmp5_ = self->view;
	_tmp6_ = files_abstract_slot_get_overlay (_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = files_view_overlay_bar_new (_tmp7_);
	gtk_widget_set_no_show_all ((GtkWidget*) _tmp8_, TRUE);
	g_object_ref_sink (_tmp8_);
	_g_object_unref0 (self->priv->overlay_statusbar);
	self->priv->overlay_statusbar = _tmp8_;
	_tmp9_ = self->view;
	files_view_view_container_connect_slot_signals (self, _tmp9_);
	files_view_view_container_directory_is_loading (self, loc);
	_tmp10_ = files_view_view_container_get_slot (self);
	_tmp11_ = _tmp10_;
	files_abstract_slot_initialize_directory (_tmp11_);
	gtk_widget_show_all ((GtkWidget*) self);
}

/** By default changes the view mode to @mode at the same location.
            @loc - new location to show.
        **/
void
files_view_view_container_change_view_mode (FilesViewViewContainer* self,
                                            FilesViewMode mode,
                                            GFile* loc)
{
	FilesAbstractSlot* aslot = NULL;
	FilesAbstractSlot* _tmp0_;
	FilesAbstractSlot* _tmp1_;
	FilesAbstractSlot* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = files_view_view_container_get_current_slot (self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	aslot = _tmp1_;
	_tmp2_ = aslot;
	if (_tmp2_ == NULL) {
		_g_object_unref0 (aslot);
		return;
	}
	if (mode != self->view_mode) {
		FilesAbstractSlot* _tmp3_;
		FilesAbstractSlot* _tmp4_;
		GFile* _tmp5_ = NULL;
		_tmp3_ = aslot;
		files_abstract_slot_close (_tmp3_);
		self->view_mode = mode;
		g_signal_emit (self, files_view_view_container_signals[FILES_VIEW_VIEW_CONTAINER_LOADING_SIGNAL], 0, FALSE);
		files_view_view_container_store_selection (self);
		_tmp4_ = self->view;
		files_view_view_container_disconnect_slot_signals (self, _tmp4_);
		_tmp5_ = loc;
		if (_tmp5_ == NULL) {
			GFile* _tmp6_;
			GFile* _tmp7_;
			_tmp6_ = files_view_view_container_get_location (self);
			_tmp7_ = _tmp6_;
			_tmp5_ = _tmp7_;
		}
		files_view_view_container_add_view (self, mode, _tmp5_, NULL, (gint) 0);
		files_view_view_container_set_active_state (self, TRUE, TRUE);
	}
	_g_object_unref0 (aslot);
}

static void
_files_view_view_container_on_slot_active_files_abstract_slot_active (FilesAbstractSlot* _sender,
                                                                      gboolean scroll,
                                                                      gboolean animate,
                                                                      gpointer self)
{
	files_view_view_container_on_slot_active ((FilesViewViewContainer*) self, _sender, scroll, animate);
}

static void
_files_view_view_container_on_slot_path_changed_files_abstract_slot_path_changed (FilesAbstractSlot* _sender,
                                                                                  gpointer self)
{
	files_view_view_container_on_slot_path_changed ((FilesViewViewContainer*) self, _sender);
}

static void
_files_view_view_container_on_slot_new_container_request_files_abstract_slot_new_container_request (FilesAbstractSlot* _sender,
                                                                                                    GFile* loc,
                                                                                                    FilesOpenFlag flag,
                                                                                                    gpointer self)
{
	files_view_view_container_on_slot_new_container_request ((FilesViewViewContainer*) self, loc, flag);
}

static void
_files_view_view_container_on_slot_selection_changed_files_abstract_slot_selection_changed (FilesAbstractSlot* _sender,
                                                                                            GList* files,
                                                                                            gpointer self)
{
	files_view_view_container_on_slot_selection_changed ((FilesViewViewContainer*) self, files);
}

static void
_files_view_view_container_on_slot_directory_loaded_files_abstract_slot_directory_loaded (FilesAbstractSlot* _sender,
                                                                                          FilesDirectory* dir,
                                                                                          gpointer self)
{
	files_view_view_container_on_slot_directory_loaded ((FilesViewViewContainer*) self, dir);
}

static void
files_view_view_container_connect_slot_signals (FilesViewViewContainer* self,
                                                FilesAbstractSlot* aslot)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (aslot != NULL);
	g_signal_connect_object (aslot, "active", (GCallback) _files_view_view_container_on_slot_active_files_abstract_slot_active, self, 0);
	g_signal_connect_object (aslot, "path-changed", (GCallback) _files_view_view_container_on_slot_path_changed_files_abstract_slot_path_changed, self, 0);
	g_signal_connect_object (aslot, "new-container-request", (GCallback) _files_view_view_container_on_slot_new_container_request_files_abstract_slot_new_container_request, self, 0);
	g_signal_connect_object (aslot, "selection-changed", (GCallback) _files_view_view_container_on_slot_selection_changed_files_abstract_slot_selection_changed, self, 0);
	g_signal_connect_object (aslot, "directory-loaded", (GCallback) _files_view_view_container_on_slot_directory_loaded_files_abstract_slot_directory_loaded, self, 0);
}

static void
files_view_view_container_disconnect_slot_signals (FilesViewViewContainer* self,
                                                   FilesAbstractSlot* aslot)
{
	guint _tmp0_;
	guint _tmp1_;
	guint _tmp2_;
	guint _tmp3_;
	guint _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (aslot != NULL);
	g_signal_parse_name ("active", FILES_TYPE_ABSTRACT_SLOT, &_tmp0_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (aslot, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp0_, 0, NULL, (GCallback) _files_view_view_container_on_slot_active_files_abstract_slot_active, self);
	g_signal_parse_name ("path-changed", FILES_TYPE_ABSTRACT_SLOT, &_tmp1_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (aslot, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _files_view_view_container_on_slot_path_changed_files_abstract_slot_path_changed, self);
	g_signal_parse_name ("new-container-request", FILES_TYPE_ABSTRACT_SLOT, &_tmp2_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (aslot, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp2_, 0, NULL, (GCallback) _files_view_view_container_on_slot_new_container_request_files_abstract_slot_new_container_request, self);
	g_signal_parse_name ("selection-changed", FILES_TYPE_ABSTRACT_SLOT, &_tmp3_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (aslot, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp3_, 0, NULL, (GCallback) _files_view_view_container_on_slot_selection_changed_files_abstract_slot_selection_changed, self);
	g_signal_parse_name ("directory-loaded", FILES_TYPE_ABSTRACT_SLOT, &_tmp4_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (aslot, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp4_, 0, NULL, (GCallback) _files_view_view_container_on_slot_directory_loaded_files_abstract_slot_directory_loaded, self);
}

static void
files_view_view_container_on_slot_active (FilesViewViewContainer* self,
                                          FilesAbstractSlot* aslot,
                                          gboolean scroll,
                                          gboolean animate)
{
	FilesAbstractSlot* _tmp0_;
	FilesAbstractSlot* _tmp1_;
	GFile* _tmp2_;
	GFile* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (aslot != NULL);
	_tmp0_ = files_view_view_container_get_slot (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = files_abstract_slot_get_location (_tmp1_);
	_tmp3_ = _tmp2_;
	files_view_view_container_refresh_slot_info (self, _tmp3_);
}

static void
files_view_view_container_open_location (FilesViewViewContainer* self,
                                         GFile* loc,
                                         FilesOpenFlag flag)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (loc != NULL);
	switch ((FilesOpenFlag) flag) {
		case FILES_OPEN_FLAG_NEW_TAB:
		case FILES_OPEN_FLAG_NEW_WINDOW:
		{
			FilesViewWindow* _tmp0_;
			FilesViewWindow* _tmp1_;
			gchar* _tmp2_;
			gchar* _tmp3_;
			_tmp0_ = files_view_view_container_get_window (self);
			_tmp1_ = _tmp0_;
			_tmp2_ = g_file_get_uri (loc);
			_tmp3_ = _tmp2_;
			files_view_window_uri_path_change_request (_tmp1_, _tmp3_, flag);
			_g_free0 (_tmp3_);
			break;
		}
		case FILES_OPEN_FLAG_NEW_ROOT:
		{
			FilesAbstractSlot* _tmp4_;
			_tmp4_ = self->view;
			files_abstract_slot_user_path_change_request (_tmp4_, loc, TRUE);
			break;
		}
		default:
		{
			FilesAbstractSlot* _tmp5_;
			_tmp5_ = self->view;
			files_abstract_slot_user_path_change_request (_tmp5_, loc, FALSE);
			break;
		}
	}
}

static void
files_view_view_container_on_slot_new_container_request (FilesViewViewContainer* self,
                                                         GFile* loc,
                                                         FilesOpenFlag flag)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (loc != NULL);
	files_view_view_container_open_location (self, loc, flag);
}

void
files_view_view_container_on_slot_path_changed (FilesViewViewContainer* self,
                                                FilesAbstractSlot* slot)
{
	GFile* _tmp0_;
	GFile* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (slot != NULL);
	_tmp0_ = files_abstract_slot_get_location (slot);
	_tmp1_ = _tmp0_;
	files_view_view_container_directory_is_loading (self, _tmp1_);
}

static void
files_view_view_container_directory_is_loading (FilesViewViewContainer* self,
                                                GFile* loc)
{
	FilesViewOverlayBar* _tmp0_;
	FilesViewOverlayBar* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (loc != NULL);
	_tmp0_ = self->priv->overlay_statusbar;
	files_view_overlay_bar_cancel (_tmp0_);
	_tmp1_ = self->priv->overlay_statusbar;
	gtk_widget_set_halign ((GtkWidget*) _tmp1_, GTK_ALIGN_END);
	files_view_view_container_refresh_slot_info (self, loc);
	files_view_view_container_set_can_show_folder (self, FALSE);
	g_signal_emit (self, files_view_view_container_signals[FILES_VIEW_VIEW_CONTAINER_LOADING_SIGNAL], 0, TRUE);
}

static void
files_view_view_container_refresh_slot_info (FilesViewViewContainer* self,
                                             GFile* loc)
{
	FilesViewWindow* _tmp0_;
	FilesViewWindow* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (loc != NULL);
	files_view_view_container_update_tab_name (self);
	_tmp0_ = files_view_view_container_get_window (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_file_get_uri (loc);
	_tmp3_ = _tmp2_;
	g_signal_emit_by_name (_tmp1_, "loading-uri", _tmp3_);
	_g_free0 (_tmp3_);
}

static void
files_view_view_container_update_tab_name (FilesViewViewContainer* self)
{
	gchar* tab_name = NULL;
	gchar* _tmp0_;
	gchar* protocol = NULL;
	gchar* path = NULL;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	const gchar* _tmp6_;
	const gchar* _tmp19_;
	FilesViewOverlayBar* _tmp20_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (FILES_INVALID_TAB_NAME);
	tab_name = _tmp0_;
	_tmp1_ = files_view_view_container_get_uri (self);
	_tmp2_ = _tmp1_;
	files_file_utils_split_protocol_from_path (_tmp2_, &_tmp3_, &_tmp4_);
	_g_free0 (protocol);
	protocol = _tmp3_;
	_g_free0 (path);
	path = _tmp4_;
	_tmp6_ = path;
	if (g_strcmp0 (_tmp6_, "") == 0) {
		_tmp5_ = TRUE;
	} else {
		const gchar* _tmp7_;
		_tmp7_ = path;
		_tmp5_ = g_strcmp0 (_tmp7_, G_DIR_SEPARATOR_S) == 0;
	}
	if (_tmp5_) {
		const gchar* _tmp8_;
		gchar* _tmp9_;
		_tmp8_ = protocol;
		_tmp9_ = files_protocol_to_name (_tmp8_);
		_g_free0 (tab_name);
		tab_name = _tmp9_;
	} else {
		gboolean _tmp10_ = FALSE;
		const gchar* _tmp11_;
		_tmp11_ = protocol;
		if (g_strcmp0 (_tmp11_, "") == 0) {
			const gchar* _tmp12_;
			const gchar* _tmp13_;
			_tmp12_ = path;
			_tmp13_ = g_get_home_dir ();
			_tmp10_ = g_strcmp0 (_tmp12_, _tmp13_) == 0;
		} else {
			_tmp10_ = FALSE;
		}
		if (_tmp10_) {
			gchar* _tmp14_;
			_tmp14_ = g_strdup (_ ("Home"));
			_g_free0 (tab_name);
			tab_name = _tmp14_;
		} else {
			const gchar* _tmp15_;
			gchar* _tmp16_;
			gchar* _tmp17_;
			gchar* _tmp18_;
			_tmp15_ = path;
			_tmp16_ = g_uri_unescape_string (_tmp15_, NULL);
			_tmp17_ = _tmp16_;
			_tmp18_ = g_path_get_basename (_tmp17_);
			_g_free0 (tab_name);
			tab_name = _tmp18_;
			_g_free0 (_tmp17_);
		}
	}
	_tmp19_ = tab_name;
	files_view_view_container_set_tab_name (self, _tmp19_);
	_tmp20_ = self->priv->overlay_statusbar;
	gtk_widget_hide ((GtkWidget*) _tmp20_);
	_g_free0 (path);
	_g_free0 (protocol);
	_g_free0 (tab_name);
}

void
files_view_view_container_on_slot_directory_loaded (FilesViewViewContainer* self,
                                                    FilesDirectory* dir)
{
	gboolean _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	gboolean _tmp81_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	_tmp0_ = files_directory_get_can_load (dir);
	_tmp1_ = _tmp0_;
	files_view_view_container_set_can_show_folder (self, _tmp1_);
	_tmp2_ = self->priv->_can_show_folder;
	if (!_tmp2_) {
		gboolean _tmp3_ = FALSE;
		gboolean _tmp4_;
		gboolean _tmp5_;
		_tmp4_ = files_directory_get_is_recent (dir);
		_tmp5_ = _tmp4_;
		if (_tmp5_) {
			FilesPreferences* _tmp6_;
			FilesPreferences* _tmp7_;
			gboolean _tmp8_;
			gboolean _tmp9_;
			_tmp6_ = files_preferences_get_default ();
			_tmp7_ = _tmp6_;
			_tmp8_ = files_preferences_get_remember_history (_tmp7_);
			_tmp9_ = _tmp8_;
			_tmp3_ = !_tmp9_;
			_g_object_unref0 (_tmp7_);
		} else {
			_tmp3_ = FALSE;
		}
		if (_tmp3_) {
			FilesViewPrivacyModeOn* _tmp10_;
			FilesViewPrivacyModeOn* _tmp11_;
			_tmp10_ = files_view_privacy_mode_on_new (self);
			g_object_ref_sink (_tmp10_);
			_tmp11_ = _tmp10_;
			files_view_view_container_set_content (self, (GtkWidget*) _tmp11_);
			_g_object_unref0 (_tmp11_);
		} else {
			FilesFile* _tmp12_;
			FilesFile* _tmp13_;
			_tmp12_ = files_directory_get_file (dir);
			_tmp13_ = _tmp12_;
			if (!_tmp13_->exists) {
				gboolean _tmp14_;
				gboolean _tmp15_;
				_tmp14_ = files_directory_get_is_trash (dir);
				_tmp15_ = _tmp14_;
				if (!_tmp15_) {
					FilesAbstractSlot* _tmp16_;
					FilesAbstractSlot* _tmp17_;
					FilesDirectory* _tmp18_;
					FilesDirectory* _tmp19_;
					FilesViewDirectoryNotFound* _tmp20_;
					FilesViewDirectoryNotFound* _tmp21_;
					_tmp16_ = files_view_view_container_get_slot (self);
					_tmp17_ = _tmp16_;
					_tmp18_ = files_abstract_slot_get_directory (_tmp17_);
					_tmp19_ = _tmp18_;
					_tmp20_ = files_view_directory_not_found_new (_tmp19_, self);
					g_object_ref_sink (_tmp20_);
					_tmp21_ = _tmp20_;
					files_view_view_container_set_content (self, (GtkWidget*) _tmp21_);
					_g_object_unref0 (_tmp21_);
				} else {
					FilesViewWelcome* _tmp22_;
					FilesViewWelcome* _tmp23_;
					_tmp22_ = files_view_welcome_new (_ ("This Folder Does Not Exist"), _ ("You cannot create a folder here."));
					g_object_ref_sink (_tmp22_);
					_tmp23_ = _tmp22_;
					files_view_view_container_set_content (self, (GtkWidget*) _tmp23_);
					_g_object_unref0 (_tmp23_);
				}
			} else {
				if (!dir->network_available) {
					gchar* _tmp24_;
					gchar* _tmp25_;
					const gchar* _tmp26_;
					const gchar* _tmp27_;
					gchar* _tmp28_;
					gchar* _tmp29_;
					FilesViewWelcome* _tmp30_;
					FilesViewWelcome* _tmp31_;
					_tmp24_ = g_strconcat (_ ("A working network is needed to reach this folder"), "\n\n", NULL);
					_tmp25_ = _tmp24_;
					_tmp26_ = files_directory_get_last_error_message (dir);
					_tmp27_ = _tmp26_;
					_tmp28_ = g_strconcat (_tmp25_, _tmp27_, NULL);
					_tmp29_ = _tmp28_;
					_tmp30_ = files_view_welcome_new (_ ("The network is unavailable"), _tmp29_);
					g_object_ref_sink (_tmp30_);
					_tmp31_ = _tmp30_;
					files_view_view_container_set_content (self, (GtkWidget*) _tmp31_);
					_g_object_unref0 (_tmp31_);
					_g_free0 (_tmp29_);
					_g_free0 (_tmp25_);
				} else {
					if (dir->permission_denied) {
						FilesViewWelcome* _tmp32_;
						FilesViewWelcome* _tmp33_;
						_tmp32_ = files_view_welcome_new (_ ("This Folder Does Not Belong to You"), _ ("You don't have permission to view this folder."));
						g_object_ref_sink (_tmp32_);
						_tmp33_ = _tmp32_;
						files_view_view_container_set_content (self, (GtkWidget*) _tmp33_);
						_g_object_unref0 (_tmp33_);
					} else {
						FilesFile* _tmp34_;
						FilesFile* _tmp35_;
						_tmp34_ = files_directory_get_file (dir);
						_tmp35_ = _tmp34_;
						if (!_tmp35_->is_connected) {
							gchar* _tmp36_;
							gchar* _tmp37_;
							const gchar* _tmp38_;
							const gchar* _tmp39_;
							gchar* _tmp40_;
							gchar* _tmp41_;
							FilesViewWelcome* _tmp42_;
							FilesViewWelcome* _tmp43_;
							_tmp36_ = g_strconcat (_ ("Could not connect to the server for this folder."), "\n\n", NULL);
							_tmp37_ = _tmp36_;
							_tmp38_ = files_directory_get_last_error_message (dir);
							_tmp39_ = _tmp38_;
							_tmp40_ = g_strconcat (_tmp37_, _tmp39_, NULL);
							_tmp41_ = _tmp40_;
							_tmp42_ = files_view_welcome_new (_ ("Unable to Mount Folder"), _tmp41_);
							g_object_ref_sink (_tmp42_);
							_tmp43_ = _tmp42_;
							files_view_view_container_set_content (self, (GtkWidget*) _tmp43_);
							_g_object_unref0 (_tmp43_);
							_g_free0 (_tmp41_);
							_g_free0 (_tmp37_);
						} else {
							FilesAbstractSlot* _tmp44_;
							FilesAbstractSlot* _tmp45_;
							FilesDirectory* _tmp46_;
							FilesDirectory* _tmp47_;
							FilesDirectoryState _tmp48_;
							FilesDirectoryState _tmp49_;
							_tmp44_ = files_view_view_container_get_slot (self);
							_tmp45_ = _tmp44_;
							_tmp46_ = files_abstract_slot_get_directory (_tmp45_);
							_tmp47_ = _tmp46_;
							_tmp48_ = files_directory_get_state (_tmp47_);
							_tmp49_ = _tmp48_;
							if (_tmp49_ == FILES_DIRECTORY_STATE_TIMED_OUT) {
								gchar* _tmp50_;
								gchar* _tmp51_;
								const gchar* _tmp52_;
								const gchar* _tmp53_;
								gchar* _tmp54_;
								gchar* _tmp55_;
								FilesViewWelcome* _tmp56_;
								FilesViewWelcome* _tmp57_;
								_tmp50_ = g_strconcat (_ ("The operation timed out."), "\n\n", NULL);
								_tmp51_ = _tmp50_;
								_tmp52_ = files_directory_get_last_error_message (dir);
								_tmp53_ = _tmp52_;
								_tmp54_ = g_strconcat (_tmp51_, _tmp53_, NULL);
								_tmp55_ = _tmp54_;
								_tmp56_ = files_view_welcome_new (_ ("Unable to Display Folder Contents"), _tmp55_);
								g_object_ref_sink (_tmp56_);
								_tmp57_ = _tmp56_;
								files_view_view_container_set_content (self, (GtkWidget*) _tmp57_);
								_g_object_unref0 (_tmp57_);
								_g_free0 (_tmp55_);
								_g_free0 (_tmp51_);
							} else {
								gchar* _tmp58_;
								gchar* _tmp59_;
								const gchar* _tmp60_;
								const gchar* _tmp61_;
								gchar* _tmp62_;
								gchar* _tmp63_;
								FilesViewWelcome* _tmp64_;
								FilesViewWelcome* _tmp65_;
								_tmp58_ = g_strconcat (_ ("The server for this folder could not be located."), "\n\n", NULL);
								_tmp59_ = _tmp58_;
								_tmp60_ = files_directory_get_last_error_message (dir);
								_tmp61_ = _tmp60_;
								_tmp62_ = g_strconcat (_tmp59_, _tmp61_, NULL);
								_tmp63_ = _tmp62_;
								_tmp64_ = files_view_welcome_new (_ ("Unable to Show Folder"), _tmp63_);
								g_object_ref_sink (_tmp64_);
								_tmp65_ = _tmp64_;
								files_view_view_container_set_content (self, (GtkWidget*) _tmp65_);
								_g_object_unref0 (_tmp65_);
								_g_free0 (_tmp63_);
								_g_free0 (_tmp59_);
							}
						}
					}
				}
			}
		}
	} else {
		GList* _tmp66_;
		_tmp66_ = self->priv->selected_locations;
		if (_tmp66_ != NULL) {
			FilesAbstractSlot* _tmp67_;
			GList* _tmp68_;
			GList* _tmp69_;
			GList* _tmp70_;
			gconstpointer _tmp71_;
			_tmp67_ = self->view;
			_tmp68_ = self->priv->selected_locations;
			_tmp69_ = self->priv->selected_locations;
			_tmp70_ = g_list_first (_tmp69_);
			_tmp71_ = _tmp70_->data;
			files_abstract_slot_select_glib_files (_tmp67_, _tmp68_, (GFile*) _tmp71_);
			(self->priv->selected_locations == NULL) ? NULL : (self->priv->selected_locations = (_g_list_free__g_object_unref0_ (self->priv->selected_locations), NULL));
			self->priv->selected_locations = NULL;
		} else {
			GFile* _tmp72_;
			GFile* _tmp73_;
			_tmp72_ = files_directory_get_selected_file (dir);
			_tmp73_ = _tmp72_;
			if (_tmp73_ != NULL) {
				GFile* _tmp74_;
				GFile* _tmp75_;
				_tmp74_ = files_directory_get_selected_file (dir);
				_tmp75_ = _tmp74_;
				if (g_file_query_exists (_tmp75_, NULL)) {
					GFile* _tmp76_;
					GFile* _tmp77_;
					_tmp76_ = files_directory_get_selected_file (dir);
					_tmp77_ = _tmp76_;
					files_view_view_container_focus_location_if_in_current_directory (self, _tmp77_, FALSE);
				} else {
					FilesViewWelcome* _tmp78_;
					FilesViewWelcome* _tmp79_;
					_tmp78_ = files_view_welcome_new (_ ("File not Found"), _ ("The file selected no longer exists."));
					g_object_ref_sink (_tmp78_);
					_tmp79_ = _tmp78_;
					files_view_view_container_set_content (self, (GtkWidget*) _tmp79_);
					_g_object_unref0 (_tmp79_);
					files_view_view_container_set_can_show_folder (self, FALSE);
				}
			} else {
				FilesAbstractSlot* _tmp80_;
				_tmp80_ = self->view;
				files_abstract_slot_focus_first_for_empty_selection (_tmp80_, FALSE);
			}
		}
	}
	_tmp81_ = self->priv->_can_show_folder;
	if (_tmp81_) {
		FilesAbstractSlot* _tmp82_;
		FilesAbstractSlot* _tmp83_;
		GtkWidget* _tmp84_;
		GtkWidget* _tmp85_;
		FilesFile* directory = NULL;
		FilesFile* _tmp86_;
		FilesFile* _tmp87_;
		FilesFile* _tmp88_;
		FilesViewBrowser* _tmp89_;
		FilesFile* _tmp90_;
		const gchar* _tmp91_;
		const gchar* _tmp92_;
		FilesPluginManager* _tmp93_;
		FilesViewWindow* _tmp94_;
		FilesViewWindow* _tmp95_;
		FilesAbstractSlot* _tmp96_;
		FilesFile* _tmp97_;
		_tmp82_ = self->view;
		_vala_assert (_tmp82_ != NULL, "view != null");
		_tmp83_ = self->view;
		_tmp84_ = files_abstract_slot_get_content_box (_tmp83_);
		_tmp85_ = _tmp84_;
		files_view_view_container_set_content (self, _tmp85_);
		_g_object_unref0 (_tmp85_);
		_tmp86_ = files_directory_get_file (dir);
		_tmp87_ = _tmp86_;
		_tmp88_ = _g_object_ref0 (_tmp87_);
		directory = _tmp88_;
		_tmp89_ = self->priv->browser;
		_tmp90_ = directory;
		_tmp91_ = files_file_get_uri (_tmp90_);
		_tmp92_ = _tmp91_;
		files_view_browser_record_uri (_tmp89_, _tmp92_);
		_tmp93_ = plugins;
		_tmp94_ = files_view_view_container_get_window (self);
		_tmp95_ = _tmp94_;
		_tmp96_ = self->view;
		_tmp97_ = directory;
		files_plugin_manager_directory_loaded (_tmp93_, (GtkApplicationWindow*) _tmp95_, _tmp96_, _tmp97_);
		_g_object_unref0 (directory);
	} else {
		FilesViewBrowser* _tmp98_;
		_tmp98_ = self->priv->browser;
		files_view_browser_record_uri (_tmp98_, NULL);
	}
	g_signal_emit (self, files_view_view_container_signals[FILES_VIEW_VIEW_CONTAINER_LOADING_SIGNAL], 0, FALSE);
}

static void
___lambda135_ (FilesViewViewContainer* self,
               FilesFile* file)
{
	GFile* _tmp0_;
	GFile* _tmp1_;
	GFile* _tmp2_;
	g_return_if_fail (file != NULL);
	_tmp0_ = files_file_get_location (file);
	_tmp1_ = _tmp0_;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	self->priv->selected_locations = g_list_prepend (self->priv->selected_locations, _tmp2_);
}

static void
____lambda135__gfunc (gconstpointer data,
                      gpointer self)
{
	___lambda135_ ((FilesViewViewContainer*) self, (FilesFile*) data);
}

static void
files_view_view_container_store_selection (FilesViewViewContainer* self)
{
	GList* selected_files = NULL;
	FilesAbstractSlot* _tmp0_;
	GList* _tmp1_;
	GList* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->view;
	_tmp1_ = files_abstract_slot_get_selected_files (_tmp0_);
	selected_files = _tmp1_;
	(self->priv->selected_locations == NULL) ? NULL : (self->priv->selected_locations = (_g_list_free__g_object_unref0_ (self->priv->selected_locations), NULL));
	self->priv->selected_locations = NULL;
	_tmp2_ = selected_files;
	if (_tmp2_ != NULL) {
		GList* _tmp3_;
		_tmp3_ = selected_files;
		g_list_foreach (_tmp3_, ____lambda135__gfunc, self);
	}
}

FilesAbstractSlot*
files_view_view_container_get_current_slot (FilesViewViewContainer* self)
{
	FilesAbstractSlot* _tmp0_ = NULL;
	FilesAbstractSlot* _tmp1_;
	FilesAbstractSlot* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = self->view;
	if (_tmp1_ != NULL) {
		FilesAbstractSlot* _tmp2_;
		FilesAbstractSlot* _tmp3_;
		_tmp2_ = self->view;
		_tmp3_ = files_abstract_slot_get_current_slot (_tmp2_);
		_tmp0_ = _tmp3_;
	} else {
		_tmp0_ = NULL;
	}
	result = _tmp0_;
	return result;
}

void
files_view_view_container_set_active_state (FilesViewViewContainer* self,
                                            gboolean is_active,
                                            gboolean animate)
{
	FilesAbstractSlot* aslot = NULL;
	FilesAbstractSlot* _tmp0_;
	FilesAbstractSlot* _tmp1_;
	FilesAbstractSlot* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = files_view_view_container_get_current_slot (self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	aslot = _tmp1_;
	_tmp2_ = aslot;
	if (_tmp2_ != NULL) {
		FilesAbstractSlot* _tmp3_;
		_tmp3_ = aslot;
		files_abstract_slot_set_active_state (_tmp3_, is_active, animate);
		if (is_active) {
			g_signal_emit (self, files_view_view_container_signals[FILES_VIEW_VIEW_CONTAINER_ACTIVE_SIGNAL], 0);
		}
	}
	_g_object_unref0 (aslot);
}

static void
files_view_view_container_set_all_selected (FilesViewViewContainer* self,
                                            gboolean select_all)
{
	FilesAbstractSlot* aslot = NULL;
	FilesAbstractSlot* _tmp0_;
	FilesAbstractSlot* _tmp1_;
	FilesAbstractSlot* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = files_view_view_container_get_current_slot (self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	aslot = _tmp1_;
	_tmp2_ = aslot;
	if (_tmp2_ != NULL) {
		FilesAbstractSlot* _tmp3_;
		_tmp3_ = aslot;
		files_abstract_slot_set_all_selected (_tmp3_, select_all);
	}
	_g_object_unref0 (aslot);
}

void
files_view_view_container_focus_location (FilesViewViewContainer* self,
                                          GFile* loc,
                                          gboolean no_path_change,
                                          gboolean unselect_others)
{
	FilesAbstractSlot* aslot = NULL;
	FilesAbstractSlot* _tmp0_;
	FilesAbstractSlot* _tmp1_;
	FilesAbstractSlot* _tmp2_;
	gboolean _tmp3_ = FALSE;
	FilesAbstractSlot* _tmp4_;
	GFileInfo* info = NULL;
	FilesAbstractSlot* _tmp9_;
	GFileInfo* _tmp10_;
	GFileType filetype = 0;
	GFileInfo* _tmp11_;
	g_return_if_fail (self != NULL);
	_tmp0_ = files_view_view_container_get_current_slot (self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	aslot = _tmp1_;
	_tmp2_ = aslot;
	if (_tmp2_ == NULL) {
		_g_object_unref0 (aslot);
		return;
	}
	if (loc == NULL) {
		files_view_view_container_set_all_selected (self, FALSE);
		_g_object_unref0 (aslot);
		return;
	}
	_tmp4_ = self->view;
	if (!FILES_VIEW_IS_MILLER (_tmp4_)) {
		const gchar* _tmp5_;
		const gchar* _tmp6_;
		gchar* _tmp7_;
		gchar* _tmp8_;
		_tmp5_ = files_view_view_container_get_uri (self);
		_tmp6_ = _tmp5_;
		_tmp7_ = g_file_get_uri (loc);
		_tmp8_ = _tmp7_;
		_tmp3_ = files_file_utils_same_location (_tmp6_, _tmp8_);
		_g_free0 (_tmp8_);
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		_g_object_unref0 (aslot);
		return;
	}
	_tmp9_ = aslot;
	_tmp10_ = files_abstract_slot_lookup_file_info (_tmp9_, loc);
	info = _tmp10_;
	filetype = G_FILE_TYPE_UNKNOWN;
	_tmp11_ = info;
	if (_tmp11_ != NULL) {
		GFileInfo* _tmp12_;
		gboolean _tmp13_ = FALSE;
		_tmp12_ = info;
		filetype = g_file_info_get_file_type (_tmp12_);
		if (filetype != G_FILE_TYPE_DIRECTORY) {
			_tmp13_ = TRUE;
		} else {
			_tmp13_ = no_path_change;
		}
		if (_tmp13_) {
			GList* list = NULL;
			GFile* _tmp15_;
			FilesAbstractSlot* _tmp16_;
			GList* _tmp17_;
			if (unselect_others) {
				FilesAbstractSlot* _tmp14_;
				_tmp14_ = aslot;
				files_abstract_slot_set_all_selected (_tmp14_, FALSE);
				(self->priv->selected_locations == NULL) ? NULL : (self->priv->selected_locations = (_g_list_free__g_object_unref0_ (self->priv->selected_locations), NULL));
				self->priv->selected_locations = NULL;
			}
			list = NULL;
			_tmp15_ = _g_object_ref0 (loc);
			list = g_list_prepend (list, _tmp15_);
			_tmp16_ = aslot;
			_tmp17_ = list;
			files_abstract_slot_select_glib_files (_tmp16_, _tmp17_, loc);
			(list == NULL) ? NULL : (list = (_g_list_free__g_object_unref0_ (list), NULL));
			_g_object_unref0 (info);
			_g_object_unref0 (aslot);
			return;
		}
	} else {
		if (no_path_change) {
			FilesAbstractSlot* _tmp18_;
			_tmp18_ = self->view;
			files_abstract_slot_focus_first_for_empty_selection (_tmp18_, FALSE);
			_g_object_unref0 (info);
			_g_object_unref0 (aslot);
			return;
		}
	}
	if (loc != NULL) {
		files_view_view_container_open_location (self, loc, FILES_OPEN_FLAG_NEW_ROOT);
	}
	_g_object_unref0 (info);
	_g_object_unref0 (aslot);
}

void
files_view_view_container_focus_location_if_in_current_directory (FilesViewViewContainer* self,
                                                                  GFile* loc,
                                                                  gboolean unselect_others)
{
	g_return_if_fail (self != NULL);
	files_view_view_container_focus_location (self, loc, TRUE, unselect_others);
}

gchar*
files_view_view_container_get_root_uri (FilesViewViewContainer* self)
{
	gchar* path = NULL;
	gchar* _tmp0_;
	FilesAbstractSlot* _tmp1_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("");
	path = _tmp0_;
	_tmp1_ = self->view;
	if (_tmp1_ != NULL) {
		gchar* _tmp2_ = NULL;
		FilesAbstractSlot* _tmp3_;
		gchar* _tmp4_;
		gchar* _tmp6_;
		_tmp3_ = self->view;
		_tmp4_ = files_abstract_slot_get_root_uri (_tmp3_);
		_tmp2_ = _tmp4_;
		if (_tmp2_ == NULL) {
			gchar* _tmp5_;
			_tmp5_ = g_strdup ("");
			_g_free0 (_tmp2_);
			_tmp2_ = _tmp5_;
		}
		_tmp6_ = _tmp2_;
		_tmp2_ = NULL;
		_g_free0 (path);
		path = _tmp6_;
		_g_free0 (_tmp2_);
	}
	result = path;
	return result;
}

gchar*
files_view_view_container_get_tip_uri (FilesViewViewContainer* self)
{
	gchar* path = NULL;
	gchar* _tmp0_;
	FilesAbstractSlot* _tmp1_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("");
	path = _tmp0_;
	_tmp1_ = self->view;
	if (_tmp1_ != NULL) {
		gchar* _tmp2_ = NULL;
		FilesAbstractSlot* _tmp3_;
		gchar* _tmp4_;
		gchar* _tmp6_;
		_tmp3_ = self->view;
		_tmp4_ = files_abstract_slot_get_tip_uri (_tmp3_);
		_tmp2_ = _tmp4_;
		if (_tmp2_ == NULL) {
			gchar* _tmp5_;
			_tmp5_ = g_strdup ("");
			_g_free0 (_tmp2_);
			_tmp2_ = _tmp5_;
		}
		_tmp6_ = _tmp2_;
		_tmp2_ = NULL;
		_g_free0 (path);
		path = _tmp6_;
		_g_free0 (_tmp2_);
	}
	result = path;
	return result;
}

void
files_view_view_container_reload (FilesViewViewContainer* self)
{
	FilesAbstractSlot* slot = NULL;
	FilesAbstractSlot* _tmp0_;
	FilesAbstractSlot* _tmp1_;
	FilesAbstractSlot* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = files_view_view_container_get_current_slot (self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	slot = _tmp1_;
	_tmp2_ = slot;
	if (_tmp2_ != NULL) {
		FilesAbstractSlot* _tmp3_;
		_tmp3_ = slot;
		files_abstract_slot_reload (_tmp3_, FALSE);
	}
	_g_object_unref0 (slot);
}

GeeList*
files_view_view_container_get_go_back_path_list (FilesViewViewContainer* self)
{
	FilesViewBrowser* _tmp0_;
	FilesViewBrowser* _tmp1_;
	GeeList* _tmp2_;
	GeeList* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->browser;
	_vala_assert (_tmp0_ != NULL, "browser != null");
	_tmp1_ = self->priv->browser;
	_tmp2_ = files_view_browser_go_back_list (_tmp1_);
	result = _tmp2_;
	return result;
}

GeeList*
files_view_view_container_get_go_forward_path_list (FilesViewViewContainer* self)
{
	FilesViewBrowser* _tmp0_;
	FilesViewBrowser* _tmp1_;
	GeeList* _tmp2_;
	GeeList* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->browser;
	_vala_assert (_tmp0_ != NULL, "browser != null");
	_tmp1_ = self->priv->browser;
	_tmp2_ = files_view_browser_go_forward_list (_tmp1_);
	result = _tmp2_;
	return result;
}

void
files_view_view_container_grab_focus (FilesViewViewContainer* self)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	g_return_if_fail (self != NULL);
	files_view_view_container_set_is_frozen (self, FALSE);
	_tmp1_ = self->priv->_can_show_folder;
	if (_tmp1_) {
		FilesAbstractSlot* _tmp2_;
		_tmp2_ = self->view;
		_tmp0_ = _tmp2_ != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		FilesAbstractSlot* _tmp3_;
		_tmp3_ = self->view;
		files_abstract_slot_grab_focus (_tmp3_);
	} else {
		GtkWidget* _tmp4_;
		GtkWidget* _tmp5_;
		_tmp4_ = files_view_view_container_get_content (self);
		_tmp5_ = _tmp4_;
		gtk_widget_grab_focus (_tmp5_);
	}
}

static void
files_view_view_container_on_slot_selection_changed (FilesViewViewContainer* self,
                                                     GList* files)
{
	FilesViewOverlayBar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->overlay_statusbar;
	files_view_overlay_bar_selection_changed (_tmp0_, files);
}

static gboolean
files_view_view_container_on_button_press_event (FilesViewViewContainer* self,
                                                 GdkEventButton* event)
{
	GdkModifierType state = 0U;
	GdkModifierType _tmp0_ = 0U;
	guint button = 0U;
	guint _tmp1_ = 0U;
	GdkModifierType mods = 0U;
	gboolean _result_ = FALSE;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	gdk_event_get_state ((GdkEvent*) event, &_tmp0_);
	state = _tmp0_;
	gdk_event_get_button ((GdkEvent*) event, &_tmp1_);
	button = _tmp1_;
	mods = state & gtk_accelerator_get_default_mod_mask ();
	_result_ = FALSE;
	switch (button) {
		case 6:
		case 8:
		{
			if (mods == 0) {
				_result_ = TRUE;
				files_view_view_container_go_back (self, 1);
			}
			break;
		}
		case 7:
		case 9:
		{
			if (mods == 0) {
				_result_ = TRUE;
				files_view_view_container_go_forward (self, 1);
			}
			break;
		}
		default:
		{
			break;
		}
	}
	result = _result_;
	return result;
}

gint
files_view_view_container_get_id (FilesViewViewContainer* self)
{
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_id;
	return result;
}

static void
files_view_view_container_set_id (FilesViewViewContainer* self,
                                  gint value)
{
	gint old_value;
	g_return_if_fail (self != NULL);
	old_value = files_view_view_container_get_id (self);
	if (old_value != value) {
		self->priv->_id = value;
		g_object_notify_by_pspec ((GObject *) self, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_ID_PROPERTY]);
	}
}

gboolean
files_view_view_container_get_can_show_folder (FilesViewViewContainer* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_can_show_folder;
	return result;
}

static void
files_view_view_container_set_can_show_folder (FilesViewViewContainer* self,
                                               gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = files_view_view_container_get_can_show_folder (self);
	if (old_value != value) {
		self->priv->_can_show_folder = value;
		g_object_notify_by_pspec ((GObject *) self, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_CAN_SHOW_FOLDER_PROPERTY]);
	}
}

FilesViewWindow*
files_view_view_container_get_window (FilesViewViewContainer* self)
{
	FilesViewWindow* result;
	FilesViewWindow* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_window;
	result = _tmp0_;
	return result;
}

void
files_view_view_container_set_window (FilesViewViewContainer* self,
                                      FilesViewWindow* value)
{
	FilesViewWindow* _tmp0_;
	FilesViewWindow* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_window;
	if (_tmp0_ != NULL) {
		files_view_view_container_disconnect_window_signals (self);
	}
	_tmp1_ = _g_object_ref0 (value);
	_g_object_unref0 (self->priv->_window);
	self->priv->_window = _tmp1_;
	files_view_view_container_connect_window_signals (self);
	g_object_notify_by_pspec ((GObject *) self, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_WINDOW_PROPERTY]);
}

GFile*
files_view_view_container_get_location (FilesViewViewContainer* self)
{
	GFile* result;
	GFile* _tmp0_ = NULL;
	FilesAbstractSlot* _tmp1_;
	FilesAbstractSlot* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = files_view_view_container_get_slot (self);
	_tmp2_ = _tmp1_;
	if (_tmp2_ != NULL) {
		FilesAbstractSlot* _tmp3_;
		FilesAbstractSlot* _tmp4_;
		GFile* _tmp5_;
		GFile* _tmp6_;
		_tmp3_ = files_view_view_container_get_slot (self);
		_tmp4_ = _tmp3_;
		_tmp5_ = files_abstract_slot_get_location (_tmp4_);
		_tmp6_ = _tmp5_;
		_tmp0_ = _tmp6_;
	} else {
		_tmp0_ = NULL;
	}
	result = _tmp0_;
	return result;
}

const gchar*
files_view_view_container_get_uri (FilesViewViewContainer* self)
{
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	FilesAbstractSlot* _tmp1_;
	FilesAbstractSlot* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = files_view_view_container_get_slot (self);
	_tmp2_ = _tmp1_;
	if (_tmp2_ != NULL) {
		FilesAbstractSlot* _tmp3_;
		FilesAbstractSlot* _tmp4_;
		const gchar* _tmp5_;
		const gchar* _tmp6_;
		_tmp3_ = files_view_view_container_get_slot (self);
		_tmp4_ = _tmp3_;
		_tmp5_ = files_abstract_slot_get_uri (_tmp4_);
		_tmp6_ = _tmp5_;
		_tmp0_ = _tmp6_;
	} else {
		_tmp0_ = "";
	}
	result = _tmp0_;
	return result;
}

FilesAbstractSlot*
files_view_view_container_get_slot (FilesViewViewContainer* self)
{
	FilesAbstractSlot* result;
	FilesAbstractSlot* _tmp0_ = NULL;
	FilesAbstractSlot* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = self->view;
	if (_tmp1_ != NULL) {
		FilesAbstractSlot* _tmp2_;
		FilesAbstractSlot* _tmp3_;
		_tmp2_ = self->view;
		_tmp3_ = files_abstract_slot_get_current_slot (_tmp2_);
		_tmp0_ = _tmp3_;
	} else {
		_tmp0_ = NULL;
	}
	result = _tmp0_;
	return result;
}

gboolean
files_view_view_container_get_locked_focus (FilesViewViewContainer* self)
{
	gboolean result;
	gboolean _tmp0_ = FALSE;
	FilesAbstractSlot* _tmp1_;
	FilesAbstractSlot* _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = files_view_view_container_get_slot (self);
	_tmp2_ = _tmp1_;
	if (_tmp2_ != NULL) {
		FilesAbstractSlot* _tmp3_;
		FilesAbstractSlot* _tmp4_;
		gboolean _tmp5_;
		gboolean _tmp6_;
		_tmp3_ = files_view_view_container_get_slot (self);
		_tmp4_ = _tmp3_;
		_tmp5_ = files_abstract_slot_get_locked_focus (_tmp4_);
		_tmp6_ = _tmp5_;
		_tmp0_ = _tmp6_;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}

gboolean
files_view_view_container_get_can_go_back (FilesViewViewContainer* self)
{
	gboolean result;
	FilesViewBrowser* _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->browser;
	result = files_view_browser_get_can_go_back (_tmp0_);
	return result;
}

gboolean
files_view_view_container_get_can_go_forward (FilesViewViewContainer* self)
{
	gboolean result;
	FilesViewBrowser* _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->browser;
	result = files_view_browser_get_can_go_forward (_tmp0_);
	return result;
}

gboolean
files_view_view_container_get_is_frozen (FilesViewViewContainer* self)
{
	gboolean result;
	gboolean _tmp0_ = FALSE;
	FilesAbstractSlot* _tmp1_;
	FilesAbstractSlot* _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = files_view_view_container_get_slot (self);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == NULL) {
		_tmp0_ = TRUE;
	} else {
		FilesAbstractSlot* _tmp3_;
		FilesAbstractSlot* _tmp4_;
		gboolean _tmp5_;
		gboolean _tmp6_;
		_tmp3_ = files_view_view_container_get_slot (self);
		_tmp4_ = _tmp3_;
		_tmp5_ = files_abstract_slot_get_is_frozen (_tmp4_);
		_tmp6_ = _tmp5_;
		_tmp0_ = _tmp6_;
	}
	result = _tmp0_;
	return result;
}

void
files_view_view_container_set_is_frozen (FilesViewViewContainer* self,
                                         gboolean value)
{
	FilesAbstractSlot* _tmp0_;
	FilesAbstractSlot* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = files_view_view_container_get_slot (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_ != NULL) {
		FilesAbstractSlot* _tmp2_;
		FilesAbstractSlot* _tmp3_;
		_tmp2_ = files_view_view_container_get_slot (self);
		_tmp3_ = _tmp2_;
		files_abstract_slot_set_is_frozen (_tmp3_, value);
	}
	g_object_notify_by_pspec ((GObject *) self, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_IS_FROZEN_PROPERTY]);
}

gboolean
files_view_view_container_get_is_loading (FilesViewViewContainer* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_loading;
	return result;
}

static void
files_view_view_container_set_is_loading (FilesViewViewContainer* self,
                                          gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = files_view_view_container_get_is_loading (self);
	if (old_value != value) {
		self->priv->_is_loading = value;
		g_object_notify_by_pspec ((GObject *) self, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_IS_LOADING_PROPERTY]);
	}
}

GtkWidget*
files_view_view_container_get_content (FilesViewViewContainer* self)
{
	GtkWidget* result;
	GtkWidget* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->content_item;
	result = _tmp0_;
	return result;
}

void
files_view_view_container_set_content (FilesViewViewContainer* self,
                                       GtkWidget* value)
{
	GtkWidget* _tmp0_;
	GtkWidget* _tmp2_;
	GtkWidget* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->content_item;
	if (_tmp0_ != NULL) {
		GtkWidget* _tmp1_;
		_tmp1_ = self->content_item;
		gtk_container_remove ((GtkContainer*) self, _tmp1_);
	}
	_tmp2_ = _g_object_ref0 (value);
	_g_object_unref0 (self->content_item);
	self->content_item = _tmp2_;
	_tmp3_ = self->content_item;
	if (_tmp3_ != NULL) {
		GtkWidget* _tmp4_;
		GtkWidget* _tmp5_;
		_tmp4_ = self->content_item;
		gtk_container_add ((GtkContainer*) self, _tmp4_);
		_tmp5_ = self->content_item;
		gtk_widget_show_all (_tmp5_);
	}
	g_object_notify_by_pspec ((GObject *) self, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_CONTENT_PROPERTY]);
}

const gchar*
files_view_view_container_get_tab_name (FilesViewViewContainer* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->label;
	result = _tmp0_;
	return result;
}

static void
files_view_view_container_set_tab_name (FilesViewViewContainer* self,
                                        const gchar* value)
{
	const gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->label;
	if (g_strcmp0 (_tmp0_, value) != 0) {
		gchar* _tmp1_;
		_tmp1_ = g_strdup (value);
		_g_free0 (self->priv->label);
		self->priv->label = _tmp1_;
		g_signal_emit (self, files_view_view_container_signals[FILES_VIEW_VIEW_CONTAINER_TAB_NAME_CHANGED_SIGNAL], 0, value);
	}
	g_object_notify_by_pspec ((GObject *) self, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_TAB_NAME_PROPERTY]);
}

static GObject *
files_view_view_container_constructor (GType type,
                                       guint n_construct_properties,
                                       GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	FilesViewViewContainer * self;
	parent_class = G_OBJECT_CLASS (files_view_view_container_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_VIEW_TYPE_VIEW_CONTAINER, FilesViewViewContainer);
	files_view_view_container_set_id (self, files_view_view_container_get_next_container_id ());
	return obj;
}

static void
files_view_view_container_class_init (FilesViewViewContainerClass * klass,
                                      gpointer klass_data)
{
	files_view_view_container_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &FilesViewViewContainer_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_files_view_view_container_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_files_view_view_container_set_property;
	G_OBJECT_CLASS (klass)->constructor = files_view_view_container_constructor;
	G_OBJECT_CLASS (klass)->finalize = files_view_view_container_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_VIEW_VIEW_CONTAINER_ID_PROPERTY, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_ID_PROPERTY] = g_param_spec_int ("id", "id", "id", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_VIEW_VIEW_CONTAINER_CAN_SHOW_FOLDER_PROPERTY, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_CAN_SHOW_FOLDER_PROPERTY] = g_param_spec_boolean ("can-show-folder", "can-show-folder", "can-show-folder", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_VIEW_VIEW_CONTAINER_WINDOW_PROPERTY, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_WINDOW_PROPERTY] = g_param_spec_object ("window", "window", "window", FILES_VIEW_TYPE_WINDOW, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_VIEW_VIEW_CONTAINER_LOCATION_PROPERTY, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_LOCATION_PROPERTY] = g_param_spec_object ("location", "location", "location", g_file_get_type (), G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_VIEW_VIEW_CONTAINER_URI_PROPERTY, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_URI_PROPERTY] = g_param_spec_string ("uri", "uri", "uri", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_VIEW_VIEW_CONTAINER_SLOT_PROPERTY, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_SLOT_PROPERTY] = g_param_spec_object ("slot", "slot", "slot", FILES_TYPE_ABSTRACT_SLOT, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_VIEW_VIEW_CONTAINER_LOCKED_FOCUS_PROPERTY, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_LOCKED_FOCUS_PROPERTY] = g_param_spec_boolean ("locked-focus", "locked-focus", "locked-focus", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_VIEW_VIEW_CONTAINER_CAN_GO_BACK_PROPERTY, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_CAN_GO_BACK_PROPERTY] = g_param_spec_boolean ("can-go-back", "can-go-back", "can-go-back", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_VIEW_VIEW_CONTAINER_CAN_GO_FORWARD_PROPERTY, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_CAN_GO_FORWARD_PROPERTY] = g_param_spec_boolean ("can-go-forward", "can-go-forward", "can-go-forward", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_VIEW_VIEW_CONTAINER_IS_FROZEN_PROPERTY, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_IS_FROZEN_PROPERTY] = g_param_spec_boolean ("is-frozen", "is-frozen", "is-frozen", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_VIEW_VIEW_CONTAINER_IS_LOADING_PROPERTY, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_IS_LOADING_PROPERTY] = g_param_spec_boolean ("is-loading", "is-loading", "is-loading", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_VIEW_VIEW_CONTAINER_CONTENT_PROPERTY, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_CONTENT_PROPERTY] = g_param_spec_object ("content", "content", "content", gtk_widget_get_type (), G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_VIEW_VIEW_CONTAINER_TAB_NAME_PROPERTY, files_view_view_container_properties[FILES_VIEW_VIEW_CONTAINER_TAB_NAME_PROPERTY] = g_param_spec_string ("tab-name", "tab-name", "tab-name", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	files_view_view_container_signals[FILES_VIEW_VIEW_CONTAINER_TAB_NAME_CHANGED_SIGNAL] = g_signal_new ("tab-name-changed", FILES_VIEW_TYPE_VIEW_CONTAINER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	files_view_view_container_signals[FILES_VIEW_VIEW_CONTAINER_LOADING_SIGNAL] = g_signal_new ("loading", FILES_VIEW_TYPE_VIEW_CONTAINER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__BOOLEAN, G_TYPE_NONE, 1, G_TYPE_BOOLEAN);
	files_view_view_container_signals[FILES_VIEW_VIEW_CONTAINER_ACTIVE_SIGNAL] = g_signal_new ("active", FILES_VIEW_TYPE_VIEW_CONTAINER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	files_view_view_container_container_id = -1;
}

static void
files_view_view_container_instance_init (FilesViewViewContainer * self,
                                         gpointer klass)
{
	gchar* _tmp0_;
	self->priv = files_view_view_container_get_instance_private (self);
	self->priv->_can_show_folder = FALSE;
	self->priv->_window = NULL;
	self->view = NULL;
	self->view_mode = FILES_VIEW_MODE_INVALID;
	self->priv->_is_loading = FALSE;
	self->priv->selected_locations = NULL;
	_tmp0_ = g_strdup ("");
	self->priv->label = _tmp0_;
}

static void
files_view_view_container_finalize (GObject * obj)
{
	FilesViewViewContainer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_VIEW_TYPE_VIEW_CONTAINER, FilesViewViewContainer);
	g_debug ("ViewContainer.vala:132: ViewContainer destruct");
	_g_object_unref0 (self->content_item);
	_g_object_unref0 (self->priv->_window);
	_g_object_unref0 (self->view);
	_g_object_unref0 (self->priv->overlay_statusbar);
	_g_object_unref0 (self->priv->browser);
	(self->priv->selected_locations == NULL) ? NULL : (self->priv->selected_locations = (_g_list_free__g_object_unref0_ (self->priv->selected_locations), NULL));
	_g_free0 (self->priv->label);
	G_OBJECT_CLASS (files_view_view_container_parent_class)->finalize (obj);
}

static GType
files_view_view_container_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FilesViewViewContainerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) files_view_view_container_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FilesViewViewContainer), 0, (GInstanceInitFunc) files_view_view_container_instance_init, NULL };
	GType files_view_view_container_type_id;
	files_view_view_container_type_id = g_type_register_static (gtk_box_get_type (), "FilesViewViewContainer", &g_define_type_info, 0);
	FilesViewViewContainer_private_offset = g_type_add_instance_private (files_view_view_container_type_id, sizeof (FilesViewViewContainerPrivate));
	return files_view_view_container_type_id;
}

GType
files_view_view_container_get_type (void)
{
	static volatile gsize files_view_view_container_type_id__once = 0;
	if (g_once_init_enter (&files_view_view_container_type_id__once)) {
		GType files_view_view_container_type_id;
		files_view_view_container_type_id = files_view_view_container_get_type_once ();
		g_once_init_leave (&files_view_view_container_type_id__once, files_view_view_container_type_id);
	}
	return files_view_view_container_type_id__once;
}

static void
_vala_files_view_view_container_get_property (GObject * object,
                                              guint property_id,
                                              GValue * value,
                                              GParamSpec * pspec)
{
	FilesViewViewContainer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FILES_VIEW_TYPE_VIEW_CONTAINER, FilesViewViewContainer);
	switch (property_id) {
		case FILES_VIEW_VIEW_CONTAINER_ID_PROPERTY:
		g_value_set_int (value, files_view_view_container_get_id (self));
		break;
		case FILES_VIEW_VIEW_CONTAINER_CAN_SHOW_FOLDER_PROPERTY:
		g_value_set_boolean (value, files_view_view_container_get_can_show_folder (self));
		break;
		case FILES_VIEW_VIEW_CONTAINER_WINDOW_PROPERTY:
		g_value_set_object (value, files_view_view_container_get_window (self));
		break;
		case FILES_VIEW_VIEW_CONTAINER_LOCATION_PROPERTY:
		g_value_set_object (value, files_view_view_container_get_location (self));
		break;
		case FILES_VIEW_VIEW_CONTAINER_URI_PROPERTY:
		g_value_set_string (value, files_view_view_container_get_uri (self));
		break;
		case FILES_VIEW_VIEW_CONTAINER_SLOT_PROPERTY:
		g_value_set_object (value, files_view_view_container_get_slot (self));
		break;
		case FILES_VIEW_VIEW_CONTAINER_LOCKED_FOCUS_PROPERTY:
		g_value_set_boolean (value, files_view_view_container_get_locked_focus (self));
		break;
		case FILES_VIEW_VIEW_CONTAINER_CAN_GO_BACK_PROPERTY:
		g_value_set_boolean (value, files_view_view_container_get_can_go_back (self));
		break;
		case FILES_VIEW_VIEW_CONTAINER_CAN_GO_FORWARD_PROPERTY:
		g_value_set_boolean (value, files_view_view_container_get_can_go_forward (self));
		break;
		case FILES_VIEW_VIEW_CONTAINER_IS_FROZEN_PROPERTY:
		g_value_set_boolean (value, files_view_view_container_get_is_frozen (self));
		break;
		case FILES_VIEW_VIEW_CONTAINER_IS_LOADING_PROPERTY:
		g_value_set_boolean (value, files_view_view_container_get_is_loading (self));
		break;
		case FILES_VIEW_VIEW_CONTAINER_CONTENT_PROPERTY:
		g_value_set_object (value, files_view_view_container_get_content (self));
		break;
		case FILES_VIEW_VIEW_CONTAINER_TAB_NAME_PROPERTY:
		g_value_set_string (value, files_view_view_container_get_tab_name (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_files_view_view_container_set_property (GObject * object,
                                              guint property_id,
                                              const GValue * value,
                                              GParamSpec * pspec)
{
	FilesViewViewContainer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FILES_VIEW_TYPE_VIEW_CONTAINER, FilesViewViewContainer);
	switch (property_id) {
		case FILES_VIEW_VIEW_CONTAINER_ID_PROPERTY:
		files_view_view_container_set_id (self, g_value_get_int (value));
		break;
		case FILES_VIEW_VIEW_CONTAINER_CAN_SHOW_FOLDER_PROPERTY:
		files_view_view_container_set_can_show_folder (self, g_value_get_boolean (value));
		break;
		case FILES_VIEW_VIEW_CONTAINER_WINDOW_PROPERTY:
		files_view_view_container_set_window (self, g_value_get_object (value));
		break;
		case FILES_VIEW_VIEW_CONTAINER_IS_FROZEN_PROPERTY:
		files_view_view_container_set_is_frozen (self, g_value_get_boolean (value));
		break;
		case FILES_VIEW_VIEW_CONTAINER_IS_LOADING_PROPERTY:
		files_view_view_container_set_is_loading (self, g_value_get_boolean (value));
		break;
		case FILES_VIEW_VIEW_CONTAINER_CONTENT_PROPERTY:
		files_view_view_container_set_content (self, g_value_get_object (value));
		break;
		case FILES_VIEW_VIEW_CONTAINER_TAB_NAME_PROPERTY:
		files_view_view_container_set_tab_name (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

