/* AbstractEditableLabel.c generated by valac 0.56.3, the Vala compiler
 * generated from AbstractEditableLabel.vala, do not modify */

#include <gtk/gtk.h>
#include <glib-object.h>
#include <gdk/gdk.h>
#include <glib.h>
#include <stdlib.h>
#include <string.h>
#include <pango/pango.h>
#include <float.h>
#include <math.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define FILES_TYPE_ABSTRACT_EDITABLE_LABEL (files_abstract_editable_label_get_type ())
#define FILES_ABSTRACT_EDITABLE_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_TYPE_ABSTRACT_EDITABLE_LABEL, FilesAbstractEditableLabel))
#define FILES_ABSTRACT_EDITABLE_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_TYPE_ABSTRACT_EDITABLE_LABEL, FilesAbstractEditableLabelClass))
#define FILES_IS_ABSTRACT_EDITABLE_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_TYPE_ABSTRACT_EDITABLE_LABEL))
#define FILES_IS_ABSTRACT_EDITABLE_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_TYPE_ABSTRACT_EDITABLE_LABEL))
#define FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_TYPE_ABSTRACT_EDITABLE_LABEL, FilesAbstractEditableLabelClass))

typedef struct _FilesAbstractEditableLabel FilesAbstractEditableLabel;
typedef struct _FilesAbstractEditableLabelClass FilesAbstractEditableLabelClass;
typedef struct _FilesAbstractEditableLabelPrivate FilesAbstractEditableLabelPrivate;
enum  {
	FILES_ABSTRACT_EDITABLE_LABEL_0_PROPERTY,
	FILES_ABSTRACT_EDITABLE_LABEL_EDITING_CANCELED_PROPERTY,
	FILES_ABSTRACT_EDITABLE_LABEL_SMALL_SIZE_PROPERTY,
	FILES_ABSTRACT_EDITABLE_LABEL_YALIGN_PROPERTY,
	FILES_ABSTRACT_EDITABLE_LABEL_XALIGN_PROPERTY,
	FILES_ABSTRACT_EDITABLE_LABEL_DRAW_OUTLINE_PROPERTY,
	FILES_ABSTRACT_EDITABLE_LABEL_NUM_PROPERTIES
};
static GParamSpec* files_abstract_editable_label_properties[FILES_ABSTRACT_EDITABLE_LABEL_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _FilesAbstractEditableLabel {
	GtkFrame parent_instance;
	FilesAbstractEditableLabelPrivate * priv;
	gchar* original_name;
};

struct _FilesAbstractEditableLabelClass {
	GtkFrameClass parent_class;
	gboolean (*on_key_press_event) (FilesAbstractEditableLabel* self, GdkEventKey* event);
	void (*set_text) (FilesAbstractEditableLabel* self, const gchar* text);
	void (*set_line_wrap) (FilesAbstractEditableLabel* self, gboolean wrap);
	void (*set_line_wrap_mode) (FilesAbstractEditableLabel* self, PangoWrapMode mode);
	void (*set_justify) (FilesAbstractEditableLabel* self, GtkJustification jtype);
	void (*set_padding) (FilesAbstractEditableLabel* self, gint xpad, gint ypad);
	void (*set_size_request) (FilesAbstractEditableLabel* self, gint width, gint height);
	GtkWidget* (*create_editable_widget) (FilesAbstractEditableLabel* self);
	gchar* (*get_text) (FilesAbstractEditableLabel* self);
	void (*select_region) (FilesAbstractEditableLabel* self, gint start_pos, gint end_pos);
	void (*do_delete_text) (FilesAbstractEditableLabel* self, gint start_pos, gint end_pos);
	void (*do_insert_text) (FilesAbstractEditableLabel* self, const gchar* new_text, gint new_text_length, gint* position);
	gchar* (*get_chars) (FilesAbstractEditableLabel* self, gint start_pos, gint end_pos);
	gint (*get_position) (FilesAbstractEditableLabel* self);
	gboolean (*get_selection_bounds) (FilesAbstractEditableLabel* self, gint* start_pos, gint* end_pos);
	void (*set_position) (FilesAbstractEditableLabel* self, gint position);
	GtkWidget* (*get_real_editable) (FilesAbstractEditableLabel* self);
	void (*start_editing) (FilesAbstractEditableLabel* self, GdkEvent* event);
};

struct _FilesAbstractEditableLabelPrivate {
	gboolean _editing_canceled;
	gboolean _small_size;
	gfloat _yalign;
	gfloat _xalign;
	gboolean _draw_outline;
	GtkWidget* editable_widget;
};

static gint FilesAbstractEditableLabel_private_offset;
static gpointer files_abstract_editable_label_parent_class = NULL;
static GtkEditableInterface * files_abstract_editable_label_gtk_editable_parent_iface = NULL;
static GtkCellEditableIface * files_abstract_editable_label_gtk_cell_editable_parent_iface = NULL;

VALA_EXTERN GType files_abstract_editable_label_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesAbstractEditableLabel, g_object_unref)
VALA_EXTERN gboolean files_abstract_editable_label_on_key_press_event (FilesAbstractEditableLabel* self,
                                                           GdkEventKey* event);
VALA_EXTERN void files_abstract_editable_label_set_text (FilesAbstractEditableLabel* self,
                                             const gchar* text);
VALA_EXTERN void files_abstract_editable_label_set_line_wrap (FilesAbstractEditableLabel* self,
                                                  gboolean wrap);
VALA_EXTERN void files_abstract_editable_label_set_line_wrap_mode (FilesAbstractEditableLabel* self,
                                                       PangoWrapMode mode);
VALA_EXTERN void files_abstract_editable_label_set_justify (FilesAbstractEditableLabel* self,
                                                GtkJustification jtype);
VALA_EXTERN void files_abstract_editable_label_set_padding (FilesAbstractEditableLabel* self,
                                                gint xpad,
                                                gint ypad);
VALA_EXTERN void files_abstract_editable_label_set_size_request (FilesAbstractEditableLabel* self,
                                                     gint width,
                                                     gint height);
VALA_EXTERN GtkWidget* files_abstract_editable_label_create_editable_widget (FilesAbstractEditableLabel* self);
VALA_EXTERN gchar* files_abstract_editable_label_get_text (FilesAbstractEditableLabel* self);
VALA_EXTERN void files_abstract_editable_label_select_region (FilesAbstractEditableLabel* self,
                                                  gint start_pos,
                                                  gint end_pos);
VALA_EXTERN void files_abstract_editable_label_do_delete_text (FilesAbstractEditableLabel* self,
                                                   gint start_pos,
                                                   gint end_pos);
VALA_EXTERN void files_abstract_editable_label_do_insert_text (FilesAbstractEditableLabel* self,
                                                   const gchar* new_text,
                                                   gint new_text_length,
                                                   gint* position);
VALA_EXTERN gchar* files_abstract_editable_label_get_chars (FilesAbstractEditableLabel* self,
                                                gint start_pos,
                                                gint end_pos);
VALA_EXTERN gint files_abstract_editable_label_get_position (FilesAbstractEditableLabel* self);
VALA_EXTERN gboolean files_abstract_editable_label_get_selection_bounds (FilesAbstractEditableLabel* self,
                                                             gint* start_pos,
                                                             gint* end_pos);
VALA_EXTERN void files_abstract_editable_label_set_position (FilesAbstractEditableLabel* self,
                                                 gint position);
VALA_EXTERN GtkWidget* files_abstract_editable_label_get_real_editable (FilesAbstractEditableLabel* self);
VALA_EXTERN void files_abstract_editable_label_start_editing (FilesAbstractEditableLabel* self,
                                                  GdkEvent* event);
VALA_EXTERN FilesAbstractEditableLabel* files_abstract_editable_label_construct (GType object_type);
static gboolean _files_abstract_editable_label_on_key_press_event_gtk_widget_key_press_event (GtkWidget* _sender,
                                                                                       GdkEventKey* event,
                                                                                       gpointer self);
static gboolean files_abstract_editable_label_real_on_key_press_event (FilesAbstractEditableLabel* self,
                                                                GdkEventKey* event);
VALA_EXTERN void files_abstract_editable_label_end_editing (FilesAbstractEditableLabel* self,
                                                gboolean cancelled);
VALA_EXTERN void files_abstract_editable_label_set_editing_canceled (FilesAbstractEditableLabel* self,
                                                         gboolean value);
static void files_abstract_editable_label_real_set_text (FilesAbstractEditableLabel* self,
                                                  const gchar* text);
static void files_abstract_editable_label_real_set_line_wrap (FilesAbstractEditableLabel* self,
                                                       gboolean wrap);
static void files_abstract_editable_label_real_set_line_wrap_mode (FilesAbstractEditableLabel* self,
                                                            PangoWrapMode mode);
static void files_abstract_editable_label_real_set_justify (FilesAbstractEditableLabel* self,
                                                     GtkJustification jtype);
static void files_abstract_editable_label_real_set_padding (FilesAbstractEditableLabel* self,
                                                     gint xpad,
                                                     gint ypad);
static void files_abstract_editable_label_real_set_size_request (FilesAbstractEditableLabel* self,
                                                          gint width,
                                                          gint height);
static GtkWidget* files_abstract_editable_label_real_create_editable_widget (FilesAbstractEditableLabel* self);
static gchar* files_abstract_editable_label_real_get_text (FilesAbstractEditableLabel* self);
static void files_abstract_editable_label_real_select_region (FilesAbstractEditableLabel* self,
                                                       gint start_pos,
                                                       gint end_pos);
static void files_abstract_editable_label_real_do_delete_text (FilesAbstractEditableLabel* self,
                                                        gint start_pos,
                                                        gint end_pos);
static void files_abstract_editable_label_real_do_insert_text (FilesAbstractEditableLabel* self,
                                                        const gchar* new_text,
                                                        gint new_text_length,
                                                        gint* position);
static gchar* files_abstract_editable_label_real_get_chars (FilesAbstractEditableLabel* self,
                                                     gint start_pos,
                                                     gint end_pos);
static gint files_abstract_editable_label_real_get_position (FilesAbstractEditableLabel* self);
static gboolean files_abstract_editable_label_real_get_selection_bounds (FilesAbstractEditableLabel* self,
                                                                  gint* start_pos,
                                                                  gint* end_pos);
static void files_abstract_editable_label_real_set_position (FilesAbstractEditableLabel* self,
                                                      gint position);
static GtkWidget* files_abstract_editable_label_real_get_real_editable (FilesAbstractEditableLabel* self);
static void files_abstract_editable_label_real_start_editing (FilesAbstractEditableLabel* self,
                                                       GdkEvent* event);
VALA_EXTERN gboolean files_abstract_editable_label_get_editing_canceled (FilesAbstractEditableLabel* self);
VALA_EXTERN gboolean files_abstract_editable_label_get_small_size (FilesAbstractEditableLabel* self);
VALA_EXTERN void files_abstract_editable_label_set_small_size (FilesAbstractEditableLabel* self,
                                                   gboolean value);
VALA_EXTERN gfloat files_abstract_editable_label_get_yalign (FilesAbstractEditableLabel* self);
VALA_EXTERN void files_abstract_editable_label_set_yalign (FilesAbstractEditableLabel* self,
                                               gfloat value);
VALA_EXTERN gfloat files_abstract_editable_label_get_xalign (FilesAbstractEditableLabel* self);
VALA_EXTERN void files_abstract_editable_label_set_xalign (FilesAbstractEditableLabel* self,
                                               gfloat value);
VALA_EXTERN gboolean files_abstract_editable_label_get_draw_outline (FilesAbstractEditableLabel* self);
VALA_EXTERN void files_abstract_editable_label_set_draw_outline (FilesAbstractEditableLabel* self,
                                                     gboolean value);
static void files_abstract_editable_label_finalize (GObject * obj);
static GType files_abstract_editable_label_get_type_once (void);
static void _vala_files_abstract_editable_label_get_property (GObject * object,
                                                       guint property_id,
                                                       GValue * value,
                                                       GParamSpec * pspec);
static void _vala_files_abstract_editable_label_set_property (GObject * object,
                                                       guint property_id,
                                                       const GValue * value,
                                                       GParamSpec * pspec);

static inline gpointer
files_abstract_editable_label_get_instance_private (FilesAbstractEditableLabel* self)
{
	return G_STRUCT_MEMBER_P (self, FilesAbstractEditableLabel_private_offset);
}

static gboolean
_files_abstract_editable_label_on_key_press_event_gtk_widget_key_press_event (GtkWidget* _sender,
                                                                              GdkEventKey* event,
                                                                              gpointer self)
{
	gboolean result;
	result = files_abstract_editable_label_on_key_press_event ((FilesAbstractEditableLabel*) self, event);
	return result;
}

FilesAbstractEditableLabel*
files_abstract_editable_label_construct (GType object_type)
{
	FilesAbstractEditableLabel * self = NULL;
	GtkWidget* _tmp0_;
	GtkWidget* _tmp1_;
	GtkWidget* _tmp2_;
	GtkWidget* _tmp3_;
	self = (FilesAbstractEditableLabel*) g_object_new (object_type, NULL);
	_tmp0_ = files_abstract_editable_label_create_editable_widget (self);
	_g_object_unref0 (self->priv->editable_widget);
	self->priv->editable_widget = _tmp0_;
	_tmp1_ = self->priv->editable_widget;
	gtk_container_add ((GtkContainer*) self, _tmp1_);
	gtk_widget_show_all ((GtkWidget*) self);
	_tmp2_ = files_abstract_editable_label_get_real_editable (self);
	_tmp3_ = _tmp2_;
	g_signal_connect_object (_tmp3_, "key-press-event", (GCallback) _files_abstract_editable_label_on_key_press_event_gtk_widget_key_press_event, self, 0);
	_g_object_unref0 (_tmp3_);
	return self;
}

static gboolean
files_abstract_editable_label_real_on_key_press_event (FilesAbstractEditableLabel* self,
                                                       GdkEventKey* event)
{
	GdkModifierType state = 0U;
	GdkModifierType _tmp0_ = 0U;
	guint keyval = 0U;
	guint _tmp1_ = 0U;
	GdkModifierType mods = 0U;
	gboolean only_control_pressed = FALSE;
	gboolean result;
	g_return_val_if_fail (event != NULL, FALSE);
	gdk_event_get_state ((GdkEvent*) event, &_tmp0_);
	state = _tmp0_;
	gdk_event_get_keyval ((GdkEvent*) event, &_tmp1_);
	keyval = _tmp1_;
	mods = state & gtk_accelerator_get_default_mod_mask ();
	only_control_pressed = mods == GDK_CONTROL_MASK;
	switch (keyval) {
		case GDK_KEY_Return:
		case GDK_KEY_KP_Enter:
		{
			if (mods == 0) {
				files_abstract_editable_label_end_editing (self, FALSE);
				result = TRUE;
				return result;
			}
			break;
		}
		case GDK_KEY_Escape:
		{
			files_abstract_editable_label_end_editing (self, TRUE);
			result = TRUE;
			return result;
		}
		case GDK_KEY_z:
		{
			if (only_control_pressed) {
				const gchar* _tmp2_;
				_tmp2_ = self->original_name;
				files_abstract_editable_label_set_text (self, _tmp2_);
				result = TRUE;
				return result;
			}
			break;
		}
		default:
		{
			break;
		}
	}
	result = FALSE;
	return result;
}

gboolean
files_abstract_editable_label_on_key_press_event (FilesAbstractEditableLabel* self,
                                                  GdkEventKey* event)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->on_key_press_event) {
		return _klass_->on_key_press_event (self, event);
	}
	return FALSE;
}

void
files_abstract_editable_label_end_editing (FilesAbstractEditableLabel* self,
                                           gboolean cancelled)
{
	g_return_if_fail (self != NULL);
	files_abstract_editable_label_set_editing_canceled (self, cancelled);
	gtk_cell_editable_remove_widget ((GtkCellEditable*) self);
	gtk_cell_editable_editing_done ((GtkCellEditable*) self);
}

static void
files_abstract_editable_label_real_set_text (FilesAbstractEditableLabel* self,
                                             const gchar* text)
{
	gchar* _tmp0_;
	g_return_if_fail (text != NULL);
	_tmp0_ = g_strdup (text);
	_g_free0 (self->original_name);
	self->original_name = _tmp0_;
}

void
files_abstract_editable_label_set_text (FilesAbstractEditableLabel* self,
                                        const gchar* text)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->set_text) {
		_klass_->set_text (self, text);
	}
}

static void
files_abstract_editable_label_real_set_line_wrap (FilesAbstractEditableLabel* self,
                                                  gboolean wrap)
{
}

void
files_abstract_editable_label_set_line_wrap (FilesAbstractEditableLabel* self,
                                             gboolean wrap)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->set_line_wrap) {
		_klass_->set_line_wrap (self, wrap);
	}
}

static void
files_abstract_editable_label_real_set_line_wrap_mode (FilesAbstractEditableLabel* self,
                                                       PangoWrapMode mode)
{
}

void
files_abstract_editable_label_set_line_wrap_mode (FilesAbstractEditableLabel* self,
                                                  PangoWrapMode mode)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->set_line_wrap_mode) {
		_klass_->set_line_wrap_mode (self, mode);
	}
}

static void
files_abstract_editable_label_real_set_justify (FilesAbstractEditableLabel* self,
                                                GtkJustification jtype)
{
}

void
files_abstract_editable_label_set_justify (FilesAbstractEditableLabel* self,
                                           GtkJustification jtype)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->set_justify) {
		_klass_->set_justify (self, jtype);
	}
}

static void
files_abstract_editable_label_real_set_padding (FilesAbstractEditableLabel* self,
                                                gint xpad,
                                                gint ypad)
{
}

void
files_abstract_editable_label_set_padding (FilesAbstractEditableLabel* self,
                                           gint xpad,
                                           gint ypad)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->set_padding) {
		_klass_->set_padding (self, xpad, ypad);
	}
}

static void
files_abstract_editable_label_real_set_size_request (FilesAbstractEditableLabel* self,
                                                     gint width,
                                                     gint height)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_editable_label_set_size_request'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_editable_label_set_size_request (FilesAbstractEditableLabel* self,
                                                gint width,
                                                gint height)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->set_size_request) {
		_klass_->set_size_request (self, width, height);
	}
}

static GtkWidget*
files_abstract_editable_label_real_create_editable_widget (FilesAbstractEditableLabel* self)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_editable_label_create_editable_widget'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}

GtkWidget*
files_abstract_editable_label_create_editable_widget (FilesAbstractEditableLabel* self)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_val_if_fail (self != NULL, NULL);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->create_editable_widget) {
		return _klass_->create_editable_widget (self);
	}
	return NULL;
}

static gchar*
files_abstract_editable_label_real_get_text (FilesAbstractEditableLabel* self)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_editable_label_get_text'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}

gchar*
files_abstract_editable_label_get_text (FilesAbstractEditableLabel* self)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_val_if_fail (self != NULL, NULL);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->get_text) {
		return _klass_->get_text (self);
	}
	return NULL;
}

static void
files_abstract_editable_label_real_select_region (FilesAbstractEditableLabel* self,
                                                  gint start_pos,
                                                  gint end_pos)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_editable_label_select_region'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_editable_label_select_region (FilesAbstractEditableLabel* self,
                                             gint start_pos,
                                             gint end_pos)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->select_region) {
		_klass_->select_region (self, start_pos, end_pos);
	}
}

static void
files_abstract_editable_label_real_do_delete_text (FilesAbstractEditableLabel* self,
                                                   gint start_pos,
                                                   gint end_pos)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_editable_label_do_delete_text'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_editable_label_do_delete_text (FilesAbstractEditableLabel* self,
                                              gint start_pos,
                                              gint end_pos)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->do_delete_text) {
		_klass_->do_delete_text (self, start_pos, end_pos);
	}
}

static void
files_abstract_editable_label_real_do_insert_text (FilesAbstractEditableLabel* self,
                                                   const gchar* new_text,
                                                   gint new_text_length,
                                                   gint* position)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_editable_label_do_insert_text'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_editable_label_do_insert_text (FilesAbstractEditableLabel* self,
                                              const gchar* new_text,
                                              gint new_text_length,
                                              gint* position)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->do_insert_text) {
		_klass_->do_insert_text (self, new_text, new_text_length, position);
	}
}

static gchar*
files_abstract_editable_label_real_get_chars (FilesAbstractEditableLabel* self,
                                              gint start_pos,
                                              gint end_pos)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_editable_label_get_chars'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}

gchar*
files_abstract_editable_label_get_chars (FilesAbstractEditableLabel* self,
                                         gint start_pos,
                                         gint end_pos)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_val_if_fail (self != NULL, NULL);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->get_chars) {
		return _klass_->get_chars (self, start_pos, end_pos);
	}
	return NULL;
}

static gint
files_abstract_editable_label_real_get_position (FilesAbstractEditableLabel* self)
{
	gint _tmp0_ = 0;
	g_critical ("Type `%s' does not implement abstract method `files_abstract_editable_label_get_position'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return _tmp0_;
}

gint
files_abstract_editable_label_get_position (FilesAbstractEditableLabel* self)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_val_if_fail (self != NULL, 0);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->get_position) {
		return _klass_->get_position (self);
	}
	return -1;
}

static gboolean
files_abstract_editable_label_real_get_selection_bounds (FilesAbstractEditableLabel* self,
                                                         gint* start_pos,
                                                         gint* end_pos)
{
	gboolean _tmp0_ = FALSE;
	g_critical ("Type `%s' does not implement abstract method `files_abstract_editable_label_get_selection_bounds'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return _tmp0_;
}

gboolean
files_abstract_editable_label_get_selection_bounds (FilesAbstractEditableLabel* self,
                                                    gint* start_pos,
                                                    gint* end_pos)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->get_selection_bounds) {
		return _klass_->get_selection_bounds (self, start_pos, end_pos);
	}
	return FALSE;
}

static void
files_abstract_editable_label_real_set_position (FilesAbstractEditableLabel* self,
                                                 gint position)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_editable_label_set_position'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_editable_label_set_position (FilesAbstractEditableLabel* self,
                                            gint position)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->set_position) {
		_klass_->set_position (self, position);
	}
}

static GtkWidget*
files_abstract_editable_label_real_get_real_editable (FilesAbstractEditableLabel* self)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_editable_label_get_real_editable'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}

GtkWidget*
files_abstract_editable_label_get_real_editable (FilesAbstractEditableLabel* self)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_val_if_fail (self != NULL, NULL);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->get_real_editable) {
		return _klass_->get_real_editable (self);
	}
	return NULL;
}

/** CellEditable interface */
static void
files_abstract_editable_label_real_start_editing (FilesAbstractEditableLabel* self,
                                                  GdkEvent* event)
{
}

void
files_abstract_editable_label_start_editing (FilesAbstractEditableLabel* self,
                                             GdkEvent* event)
{
	FilesAbstractEditableLabelClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS (self);
	if (_klass_->start_editing) {
		_klass_->start_editing (self, event);
	}
}

gboolean
files_abstract_editable_label_get_editing_canceled (FilesAbstractEditableLabel* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_editing_canceled;
	return result;
}

void
files_abstract_editable_label_set_editing_canceled (FilesAbstractEditableLabel* self,
                                                    gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = files_abstract_editable_label_get_editing_canceled (self);
	if (old_value != value) {
		self->priv->_editing_canceled = value;
		g_object_notify_by_pspec ((GObject *) self, files_abstract_editable_label_properties[FILES_ABSTRACT_EDITABLE_LABEL_EDITING_CANCELED_PROPERTY]);
	}
}

gboolean
files_abstract_editable_label_get_small_size (FilesAbstractEditableLabel* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_small_size;
	return result;
}

void
files_abstract_editable_label_set_small_size (FilesAbstractEditableLabel* self,
                                              gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = files_abstract_editable_label_get_small_size (self);
	if (old_value != value) {
		self->priv->_small_size = value;
		g_object_notify_by_pspec ((GObject *) self, files_abstract_editable_label_properties[FILES_ABSTRACT_EDITABLE_LABEL_SMALL_SIZE_PROPERTY]);
	}
}

gfloat
files_abstract_editable_label_get_yalign (FilesAbstractEditableLabel* self)
{
	gfloat result;
	g_return_val_if_fail (self != NULL, 0.0F);
	result = self->priv->_yalign;
	return result;
}

void
files_abstract_editable_label_set_yalign (FilesAbstractEditableLabel* self,
                                          gfloat value)
{
	gfloat old_value;
	g_return_if_fail (self != NULL);
	old_value = files_abstract_editable_label_get_yalign (self);
	if (old_value != value) {
		self->priv->_yalign = value;
		g_object_notify_by_pspec ((GObject *) self, files_abstract_editable_label_properties[FILES_ABSTRACT_EDITABLE_LABEL_YALIGN_PROPERTY]);
	}
}

gfloat
files_abstract_editable_label_get_xalign (FilesAbstractEditableLabel* self)
{
	gfloat result;
	g_return_val_if_fail (self != NULL, 0.0F);
	result = self->priv->_xalign;
	return result;
}

void
files_abstract_editable_label_set_xalign (FilesAbstractEditableLabel* self,
                                          gfloat value)
{
	gfloat old_value;
	g_return_if_fail (self != NULL);
	old_value = files_abstract_editable_label_get_xalign (self);
	if (old_value != value) {
		self->priv->_xalign = value;
		g_object_notify_by_pspec ((GObject *) self, files_abstract_editable_label_properties[FILES_ABSTRACT_EDITABLE_LABEL_XALIGN_PROPERTY]);
	}
}

gboolean
files_abstract_editable_label_get_draw_outline (FilesAbstractEditableLabel* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_draw_outline;
	return result;
}

void
files_abstract_editable_label_set_draw_outline (FilesAbstractEditableLabel* self,
                                                gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = files_abstract_editable_label_get_draw_outline (self);
	if (old_value != value) {
		self->priv->_draw_outline = value;
		g_object_notify_by_pspec ((GObject *) self, files_abstract_editable_label_properties[FILES_ABSTRACT_EDITABLE_LABEL_DRAW_OUTLINE_PROPERTY]);
	}
}

static void
files_abstract_editable_label_class_init (FilesAbstractEditableLabelClass * klass,
                                          gpointer klass_data)
{
	files_abstract_editable_label_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &FilesAbstractEditableLabel_private_offset);
	((FilesAbstractEditableLabelClass *) klass)->on_key_press_event = (gboolean (*) (FilesAbstractEditableLabel*, GdkEventKey*)) files_abstract_editable_label_real_on_key_press_event;
	((FilesAbstractEditableLabelClass *) klass)->set_text = (void (*) (FilesAbstractEditableLabel*, const gchar*)) files_abstract_editable_label_real_set_text;
	((FilesAbstractEditableLabelClass *) klass)->set_line_wrap = (void (*) (FilesAbstractEditableLabel*, gboolean)) files_abstract_editable_label_real_set_line_wrap;
	((FilesAbstractEditableLabelClass *) klass)->set_line_wrap_mode = (void (*) (FilesAbstractEditableLabel*, PangoWrapMode)) files_abstract_editable_label_real_set_line_wrap_mode;
	((FilesAbstractEditableLabelClass *) klass)->set_justify = (void (*) (FilesAbstractEditableLabel*, GtkJustification)) files_abstract_editable_label_real_set_justify;
	((FilesAbstractEditableLabelClass *) klass)->set_padding = (void (*) (FilesAbstractEditableLabel*, gint, gint)) files_abstract_editable_label_real_set_padding;
	((FilesAbstractEditableLabelClass *) klass)->set_size_request = (void (*) (FilesAbstractEditableLabel*, gint, gint)) files_abstract_editable_label_real_set_size_request;
	((FilesAbstractEditableLabelClass *) klass)->create_editable_widget = (GtkWidget* (*) (FilesAbstractEditableLabel*)) files_abstract_editable_label_real_create_editable_widget;
	((FilesAbstractEditableLabelClass *) klass)->get_text = (gchar* (*) (FilesAbstractEditableLabel*)) files_abstract_editable_label_real_get_text;
	((FilesAbstractEditableLabelClass *) klass)->select_region = (void (*) (FilesAbstractEditableLabel*, gint, gint)) files_abstract_editable_label_real_select_region;
	((FilesAbstractEditableLabelClass *) klass)->do_delete_text = (void (*) (FilesAbstractEditableLabel*, gint, gint)) files_abstract_editable_label_real_do_delete_text;
	((FilesAbstractEditableLabelClass *) klass)->do_insert_text = (void (*) (FilesAbstractEditableLabel*, const gchar*, gint, gint*)) files_abstract_editable_label_real_do_insert_text;
	((FilesAbstractEditableLabelClass *) klass)->get_chars = (gchar* (*) (FilesAbstractEditableLabel*, gint, gint)) files_abstract_editable_label_real_get_chars;
	((FilesAbstractEditableLabelClass *) klass)->get_position = (gint (*) (FilesAbstractEditableLabel*)) files_abstract_editable_label_real_get_position;
	((FilesAbstractEditableLabelClass *) klass)->get_selection_bounds = (gboolean (*) (FilesAbstractEditableLabel*, gint*, gint*)) files_abstract_editable_label_real_get_selection_bounds;
	((FilesAbstractEditableLabelClass *) klass)->set_position = (void (*) (FilesAbstractEditableLabel*, gint)) files_abstract_editable_label_real_set_position;
	((FilesAbstractEditableLabelClass *) klass)->get_real_editable = (GtkWidget* (*) (FilesAbstractEditableLabel*)) files_abstract_editable_label_real_get_real_editable;
	((FilesAbstractEditableLabelClass *) klass)->start_editing = (void (*) (FilesAbstractEditableLabel*, GdkEvent*)) files_abstract_editable_label_real_start_editing;
	G_OBJECT_CLASS (klass)->get_property = _vala_files_abstract_editable_label_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_files_abstract_editable_label_set_property;
	G_OBJECT_CLASS (klass)->finalize = files_abstract_editable_label_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_ABSTRACT_EDITABLE_LABEL_EDITING_CANCELED_PROPERTY, files_abstract_editable_label_properties[FILES_ABSTRACT_EDITABLE_LABEL_EDITING_CANCELED_PROPERTY] = g_param_spec_boolean ("editing-canceled", "editing-canceled", "editing-canceled", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_ABSTRACT_EDITABLE_LABEL_SMALL_SIZE_PROPERTY, files_abstract_editable_label_properties[FILES_ABSTRACT_EDITABLE_LABEL_SMALL_SIZE_PROPERTY] = g_param_spec_boolean ("small-size", "small-size", "small-size", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_ABSTRACT_EDITABLE_LABEL_YALIGN_PROPERTY, files_abstract_editable_label_properties[FILES_ABSTRACT_EDITABLE_LABEL_YALIGN_PROPERTY] = g_param_spec_float ("yalign", "yalign", "yalign", -G_MAXFLOAT, G_MAXFLOAT, 0.0F, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_ABSTRACT_EDITABLE_LABEL_XALIGN_PROPERTY, files_abstract_editable_label_properties[FILES_ABSTRACT_EDITABLE_LABEL_XALIGN_PROPERTY] = g_param_spec_float ("xalign", "xalign", "xalign", -G_MAXFLOAT, G_MAXFLOAT, 0.0F, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_ABSTRACT_EDITABLE_LABEL_DRAW_OUTLINE_PROPERTY, files_abstract_editable_label_properties[FILES_ABSTRACT_EDITABLE_LABEL_DRAW_OUTLINE_PROPERTY] = g_param_spec_boolean ("draw-outline", "draw-outline", "draw-outline", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}

static void
files_abstract_editable_label_gtk_editable_interface_init (GtkEditableInterface * iface,
                                                           gpointer iface_data)
{
	files_abstract_editable_label_gtk_editable_parent_iface = g_type_interface_peek_parent (iface);
	iface->set_selection_bounds = (void (*) (GtkEditable*, gint, gint)) files_abstract_editable_label_select_region;
	iface->delete_text = (void (*) (GtkEditable*, gint, gint)) files_abstract_editable_label_do_delete_text;
	iface->insert_text = (void (*) (GtkEditable*, const gchar*, gint, gint*)) files_abstract_editable_label_do_insert_text;
	iface->get_chars = (gchar* (*) (GtkEditable*, gint, gint)) files_abstract_editable_label_get_chars;
	iface->get_position = (gint (*) (GtkEditable*)) files_abstract_editable_label_get_position;
	iface->get_selection_bounds = (gboolean (*) (GtkEditable*, gint*, gint*)) files_abstract_editable_label_get_selection_bounds;
	iface->set_position = (void (*) (GtkEditable*, gint)) files_abstract_editable_label_set_position;
}

static void
files_abstract_editable_label_gtk_cell_editable_interface_init (GtkCellEditableIface * iface,
                                                                gpointer iface_data)
{
	files_abstract_editable_label_gtk_cell_editable_parent_iface = g_type_interface_peek_parent (iface);
	iface->start_editing = (void (*) (GtkCellEditable*, GdkEvent*)) files_abstract_editable_label_start_editing;
}

static void
files_abstract_editable_label_instance_init (FilesAbstractEditableLabel * self,
                                             gpointer klass)
{
	self->priv = files_abstract_editable_label_get_instance_private (self);
}

static void
files_abstract_editable_label_finalize (GObject * obj)
{
	FilesAbstractEditableLabel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_TYPE_ABSTRACT_EDITABLE_LABEL, FilesAbstractEditableLabel);
	_g_free0 (self->original_name);
	_g_object_unref0 (self->priv->editable_widget);
	G_OBJECT_CLASS (files_abstract_editable_label_parent_class)->finalize (obj);
}

static GType
files_abstract_editable_label_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FilesAbstractEditableLabelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) files_abstract_editable_label_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FilesAbstractEditableLabel), 0, (GInstanceInitFunc) files_abstract_editable_label_instance_init, NULL };
	static const GInterfaceInfo gtk_editable_info = { (GInterfaceInitFunc) files_abstract_editable_label_gtk_editable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	static const GInterfaceInfo gtk_cell_editable_info = { (GInterfaceInitFunc) files_abstract_editable_label_gtk_cell_editable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType files_abstract_editable_label_type_id;
	files_abstract_editable_label_type_id = g_type_register_static (gtk_frame_get_type (), "FilesAbstractEditableLabel", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
	g_type_add_interface_static (files_abstract_editable_label_type_id, gtk_editable_get_type (), &gtk_editable_info);
	g_type_add_interface_static (files_abstract_editable_label_type_id, gtk_cell_editable_get_type (), &gtk_cell_editable_info);
	FilesAbstractEditableLabel_private_offset = g_type_add_instance_private (files_abstract_editable_label_type_id, sizeof (FilesAbstractEditableLabelPrivate));
	return files_abstract_editable_label_type_id;
}

GType
files_abstract_editable_label_get_type (void)
{
	static volatile gsize files_abstract_editable_label_type_id__once = 0;
	if (g_once_init_enter (&files_abstract_editable_label_type_id__once)) {
		GType files_abstract_editable_label_type_id;
		files_abstract_editable_label_type_id = files_abstract_editable_label_get_type_once ();
		g_once_init_leave (&files_abstract_editable_label_type_id__once, files_abstract_editable_label_type_id);
	}
	return files_abstract_editable_label_type_id__once;
}

static void
_vala_files_abstract_editable_label_get_property (GObject * object,
                                                  guint property_id,
                                                  GValue * value,
                                                  GParamSpec * pspec)
{
	FilesAbstractEditableLabel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FILES_TYPE_ABSTRACT_EDITABLE_LABEL, FilesAbstractEditableLabel);
	switch (property_id) {
		case FILES_ABSTRACT_EDITABLE_LABEL_EDITING_CANCELED_PROPERTY:
		g_value_set_boolean (value, files_abstract_editable_label_get_editing_canceled (self));
		break;
		case FILES_ABSTRACT_EDITABLE_LABEL_SMALL_SIZE_PROPERTY:
		g_value_set_boolean (value, files_abstract_editable_label_get_small_size (self));
		break;
		case FILES_ABSTRACT_EDITABLE_LABEL_YALIGN_PROPERTY:
		g_value_set_float (value, files_abstract_editable_label_get_yalign (self));
		break;
		case FILES_ABSTRACT_EDITABLE_LABEL_XALIGN_PROPERTY:
		g_value_set_float (value, files_abstract_editable_label_get_xalign (self));
		break;
		case FILES_ABSTRACT_EDITABLE_LABEL_DRAW_OUTLINE_PROPERTY:
		g_value_set_boolean (value, files_abstract_editable_label_get_draw_outline (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_files_abstract_editable_label_set_property (GObject * object,
                                                  guint property_id,
                                                  const GValue * value,
                                                  GParamSpec * pspec)
{
	FilesAbstractEditableLabel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FILES_TYPE_ABSTRACT_EDITABLE_LABEL, FilesAbstractEditableLabel);
	switch (property_id) {
		case FILES_ABSTRACT_EDITABLE_LABEL_EDITING_CANCELED_PROPERTY:
		files_abstract_editable_label_set_editing_canceled (self, g_value_get_boolean (value));
		break;
		case FILES_ABSTRACT_EDITABLE_LABEL_SMALL_SIZE_PROPERTY:
		files_abstract_editable_label_set_small_size (self, g_value_get_boolean (value));
		break;
		case FILES_ABSTRACT_EDITABLE_LABEL_YALIGN_PROPERTY:
		files_abstract_editable_label_set_yalign (self, g_value_get_float (value));
		break;
		case FILES_ABSTRACT_EDITABLE_LABEL_XALIGN_PROPERTY:
		files_abstract_editable_label_set_xalign (self, g_value_get_float (value));
		break;
		case FILES_ABSTRACT_EDITABLE_LABEL_DRAW_OUTLINE_PROPERTY:
		files_abstract_editable_label_set_draw_outline (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

