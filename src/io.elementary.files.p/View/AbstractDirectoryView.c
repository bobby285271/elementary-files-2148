/* AbstractDirectoryView.c generated by valac 0.56.3, the Vala compiler
 * generated from AbstractDirectoryView.vala, do not modify */

/*
* Copyright 2015-2020 elementary, Inc. (https://elementary.io)
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License as published by the Free Software Foundation; either
* version 3 of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
*
* You should have received a copy of the GNU General Public
* License along with this program; if not, write to the
* Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
* Boston, MA 02110-1301 USA
*
* Authored by: Jeremy Wootten <jeremy@elementaryos.org>
*/
/* Implementations of AbstractDirectoryView are
     * IconView
     * ListView
     * ColumnView
*/
/*** Private methods */
/** Signal Handlers */
/** Menu actions */
/** HELPER AND CONVENIENCE FUNCTIONS */

#include <gtk/gtk.h>
#include <glib-object.h>
#include <gdk/gdk.h>
#include <glib.h>
#include <cairo-gobject.h>
#include "pantheon-files-core.h"
#include <stdlib.h>
#include <string.h>
#include <handy.h>
#include <gio/gio.h>
#include <float.h>
#include <math.h>
#include <gee.h>
#include <granite.h>
#include <glib/gi18n-lib.h>
#include "marlin-file-operations.h"
#include <gdk-pixbuf/gdk-pixbuf.h>
#include "config.h"
#include <pango/pango.h>

#define FILES_ABSTRACT_DIRECTORY_VIEW_MAX_TEMPLATES 32
#define FILES_ABSTRACT_DIRECTORY_VIEW_FILE_DRAG_ACTIONS ((GDK_ACTION_COPY | GDK_ACTION_MOVE) | GDK_ACTION_LINK)
#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define FILES_TYPE_ABSTRACT_DIRECTORY_VIEW (files_abstract_directory_view_get_type ())
#define FILES_ABSTRACT_DIRECTORY_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_TYPE_ABSTRACT_DIRECTORY_VIEW, FilesAbstractDirectoryView))
#define FILES_ABSTRACT_DIRECTORY_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_TYPE_ABSTRACT_DIRECTORY_VIEW, FilesAbstractDirectoryViewClass))
#define FILES_IS_ABSTRACT_DIRECTORY_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_TYPE_ABSTRACT_DIRECTORY_VIEW))
#define FILES_IS_ABSTRACT_DIRECTORY_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_TYPE_ABSTRACT_DIRECTORY_VIEW))
#define FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_TYPE_ABSTRACT_DIRECTORY_VIEW, FilesAbstractDirectoryViewClass))

typedef struct _FilesAbstractDirectoryView FilesAbstractDirectoryView;
typedef struct _FilesAbstractDirectoryViewClass FilesAbstractDirectoryViewClass;
typedef struct _FilesAbstractDirectoryViewPrivate FilesAbstractDirectoryViewPrivate;

#define FILES_TYPE_TEXT_RENDERER (files_text_renderer_get_type ())
#define FILES_TEXT_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_TYPE_TEXT_RENDERER, FilesTextRenderer))
#define FILES_TEXT_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_TYPE_TEXT_RENDERER, FilesTextRendererClass))
#define FILES_IS_TEXT_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_TYPE_TEXT_RENDERER))
#define FILES_IS_TEXT_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_TYPE_TEXT_RENDERER))
#define FILES_TEXT_RENDERER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_TYPE_TEXT_RENDERER, FilesTextRendererClass))

typedef struct _FilesTextRenderer FilesTextRenderer;
typedef struct _FilesTextRendererClass FilesTextRendererClass;

#define FILES_TYPE_ICON_RENDERER (files_icon_renderer_get_type ())
#define FILES_ICON_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_TYPE_ICON_RENDERER, FilesIconRenderer))
#define FILES_ICON_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_TYPE_ICON_RENDERER, FilesIconRendererClass))
#define FILES_IS_ICON_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_TYPE_ICON_RENDERER))
#define FILES_IS_ICON_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_TYPE_ICON_RENDERER))
#define FILES_ICON_RENDERER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_TYPE_ICON_RENDERER, FilesIconRendererClass))

typedef struct _FilesIconRenderer FilesIconRenderer;
typedef struct _FilesIconRendererClass FilesIconRendererClass;

#define FILES_VIEW_TYPE_SLOT (files_view_slot_get_type ())
#define FILES_VIEW_SLOT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_VIEW_TYPE_SLOT, FilesViewSlot))
#define FILES_VIEW_SLOT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_VIEW_TYPE_SLOT, FilesViewSlotClass))
#define FILES_VIEW_IS_SLOT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_VIEW_TYPE_SLOT))
#define FILES_VIEW_IS_SLOT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_VIEW_TYPE_SLOT))
#define FILES_VIEW_SLOT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_VIEW_TYPE_SLOT, FilesViewSlotClass))

typedef struct _FilesViewSlot FilesViewSlot;
typedef struct _FilesViewSlotClass FilesViewSlotClass;

#define FILES_VIEW_TYPE_WINDOW (files_view_window_get_type ())
#define FILES_VIEW_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_VIEW_TYPE_WINDOW, FilesViewWindow))
#define FILES_VIEW_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_VIEW_TYPE_WINDOW, FilesViewWindowClass))
#define FILES_VIEW_IS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_VIEW_TYPE_WINDOW))
#define FILES_VIEW_IS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_VIEW_TYPE_WINDOW))
#define FILES_VIEW_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_VIEW_TYPE_WINDOW, FilesViewWindowClass))

typedef struct _FilesViewWindow FilesViewWindow;
typedef struct _FilesViewWindowClass FilesViewWindowClass;

#define FILES_TYPE_CLIPBOARD_MANAGER (files_clipboard_manager_get_type ())
#define FILES_CLIPBOARD_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_TYPE_CLIPBOARD_MANAGER, FilesClipboardManager))
#define FILES_CLIPBOARD_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_TYPE_CLIPBOARD_MANAGER, FilesClipboardManagerClass))
#define FILES_IS_CLIPBOARD_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_TYPE_CLIPBOARD_MANAGER))
#define FILES_IS_CLIPBOARD_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_TYPE_CLIPBOARD_MANAGER))
#define FILES_CLIPBOARD_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_TYPE_CLIPBOARD_MANAGER, FilesClipboardManagerClass))

typedef struct _FilesClipboardManager FilesClipboardManager;
typedef struct _FilesClipboardManagerClass FilesClipboardManagerClass;
enum  {
	FILES_ABSTRACT_DIRECTORY_VIEW_0_PROPERTY,
	FILES_ABSTRACT_DIRECTORY_VIEW_ZOOM_LEVEL_PROPERTY,
	FILES_ABSTRACT_DIRECTORY_VIEW_ICON_SIZE_PROPERTY,
	FILES_ABSTRACT_DIRECTORY_VIEW_SINGLECLICK_SELECT_PROPERTY,
	FILES_ABSTRACT_DIRECTORY_VIEW_RENAMING_PROPERTY,
	FILES_ABSTRACT_DIRECTORY_VIEW_IS_FROZEN_PROPERTY,
	FILES_ABSTRACT_DIRECTORY_VIEW_IN_RECENT_PROPERTY,
	FILES_ABSTRACT_DIRECTORY_VIEW_TREE_FROZEN_PROPERTY,
	FILES_ABSTRACT_DIRECTORY_VIEW_SHOW_REMOTE_THUMBNAILS_PROPERTY,
	FILES_ABSTRACT_DIRECTORY_VIEW_SHOW_LOCAL_THUMBNAILS_PROPERTY,
	FILES_ABSTRACT_DIRECTORY_VIEW_NUM_PROPERTIES
};
static GParamSpec* files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_NUM_PROPERTIES];
typedef enum  {
	FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_EXPANDER,
	FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_HELPER,
	FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_ICON,
	FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_NAME,
	FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_BLANK_PATH,
	FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_BLANK_NO_PATH,
	FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_INVALID
} FilesAbstractDirectoryViewClickZone;

#define FILES_ABSTRACT_DIRECTORY_VIEW_TYPE_CLICK_ZONE (files_abstract_directory_view_click_zone_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define __vala_GtkTreePath_free0(var) ((var == NULL) ? NULL : (var = (_vala_GtkTreePath_free (var), NULL)))

#define FILES_TYPE_APPLICATION (files_application_get_type ())
#define FILES_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_TYPE_APPLICATION, FilesApplication))
#define FILES_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_TYPE_APPLICATION, FilesApplicationClass))
#define FILES_IS_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_TYPE_APPLICATION))
#define FILES_IS_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_TYPE_APPLICATION))
#define FILES_APPLICATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_TYPE_APPLICATION, FilesApplicationClass))

typedef struct _FilesApplication FilesApplication;
typedef struct _FilesApplicationClass FilesApplicationClass;
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
typedef struct _Block12Data Block12Data;
typedef struct _Block13Data Block13Data;
#define __vala_GtkTreeIter_free0(var) ((var == NULL) ? NULL : (var = (_vala_GtkTreeIter_free (var), NULL)))
typedef struct _Block14Data Block14Data;
typedef struct _Block15Data Block15Data;
typedef struct _Block16Data Block16Data;
typedef struct _Block17Data Block17Data;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Block18Data Block18Data;

#define FILES_VIEW_TYPE_ABSTRACT_PROPERTIES_DIALOG (files_view_abstract_properties_dialog_get_type ())
#define FILES_VIEW_ABSTRACT_PROPERTIES_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_VIEW_TYPE_ABSTRACT_PROPERTIES_DIALOG, FilesViewAbstractPropertiesDialog))
#define FILES_VIEW_ABSTRACT_PROPERTIES_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_VIEW_TYPE_ABSTRACT_PROPERTIES_DIALOG, FilesViewAbstractPropertiesDialogClass))
#define FILES_VIEW_IS_ABSTRACT_PROPERTIES_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_VIEW_TYPE_ABSTRACT_PROPERTIES_DIALOG))
#define FILES_VIEW_IS_ABSTRACT_PROPERTIES_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_VIEW_TYPE_ABSTRACT_PROPERTIES_DIALOG))
#define FILES_VIEW_ABSTRACT_PROPERTIES_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_VIEW_TYPE_ABSTRACT_PROPERTIES_DIALOG, FilesViewAbstractPropertiesDialogClass))

typedef struct _FilesViewAbstractPropertiesDialog FilesViewAbstractPropertiesDialog;
typedef struct _FilesViewAbstractPropertiesDialogClass FilesViewAbstractPropertiesDialogClass;

#define FILES_VIEW_TYPE_PROPERTIES_WINDOW (files_view_properties_window_get_type ())
#define FILES_VIEW_PROPERTIES_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_VIEW_TYPE_PROPERTIES_WINDOW, FilesViewPropertiesWindow))
#define FILES_VIEW_PROPERTIES_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_VIEW_TYPE_PROPERTIES_WINDOW, FilesViewPropertiesWindowClass))
#define FILES_VIEW_IS_PROPERTIES_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_VIEW_TYPE_PROPERTIES_WINDOW))
#define FILES_VIEW_IS_PROPERTIES_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_VIEW_TYPE_PROPERTIES_WINDOW))
#define FILES_VIEW_PROPERTIES_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_VIEW_TYPE_PROPERTIES_WINDOW, FilesViewPropertiesWindowClass))

typedef struct _FilesViewPropertiesWindow FilesViewPropertiesWindow;
typedef struct _FilesViewPropertiesWindowClass FilesViewPropertiesWindowClass;
typedef struct _Block19Data Block19Data;
typedef struct _Block20Data Block20Data;
#define __vala_GdkEvent_free0(var) ((var == NULL) ? NULL : (var = (_vala_GdkEvent_free (var), NULL)))
#define _gtk_target_list_unref0(var) ((var == NULL) ? NULL : (var = (gtk_target_list_unref (var), NULL)))
typedef struct _Block21Data Block21Data;

#define FILES_ABSTRACT_DIRECTORY_VIEW_TYPE_SORT_SUB_MENU_ITEM (files_abstract_directory_view_sort_sub_menu_item_get_type ())
#define FILES_ABSTRACT_DIRECTORY_VIEW_SORT_SUB_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_ABSTRACT_DIRECTORY_VIEW_TYPE_SORT_SUB_MENU_ITEM, FilesAbstractDirectoryViewSortSubMenuItem))
#define FILES_ABSTRACT_DIRECTORY_VIEW_SORT_SUB_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_ABSTRACT_DIRECTORY_VIEW_TYPE_SORT_SUB_MENU_ITEM, FilesAbstractDirectoryViewSortSubMenuItemClass))
#define FILES_ABSTRACT_DIRECTORY_VIEW_IS_SORT_SUB_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_ABSTRACT_DIRECTORY_VIEW_TYPE_SORT_SUB_MENU_ITEM))
#define FILES_ABSTRACT_DIRECTORY_VIEW_IS_SORT_SUB_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_ABSTRACT_DIRECTORY_VIEW_TYPE_SORT_SUB_MENU_ITEM))
#define FILES_ABSTRACT_DIRECTORY_VIEW_SORT_SUB_MENU_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_ABSTRACT_DIRECTORY_VIEW_TYPE_SORT_SUB_MENU_ITEM, FilesAbstractDirectoryViewSortSubMenuItemClass))

typedef struct _FilesAbstractDirectoryViewSortSubMenuItem FilesAbstractDirectoryViewSortSubMenuItem;
typedef struct _FilesAbstractDirectoryViewSortSubMenuItemClass FilesAbstractDirectoryViewSortSubMenuItemClass;

#define FILES_ABSTRACT_DIRECTORY_VIEW_TYPE_NEW_SUB_MENU_ITEM (files_abstract_directory_view_new_sub_menu_item_get_type ())
#define FILES_ABSTRACT_DIRECTORY_VIEW_NEW_SUB_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_ABSTRACT_DIRECTORY_VIEW_TYPE_NEW_SUB_MENU_ITEM, FilesAbstractDirectoryViewNewSubMenuItem))
#define FILES_ABSTRACT_DIRECTORY_VIEW_NEW_SUB_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_ABSTRACT_DIRECTORY_VIEW_TYPE_NEW_SUB_MENU_ITEM, FilesAbstractDirectoryViewNewSubMenuItemClass))
#define FILES_ABSTRACT_DIRECTORY_VIEW_IS_NEW_SUB_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_ABSTRACT_DIRECTORY_VIEW_TYPE_NEW_SUB_MENU_ITEM))
#define FILES_ABSTRACT_DIRECTORY_VIEW_IS_NEW_SUB_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_ABSTRACT_DIRECTORY_VIEW_TYPE_NEW_SUB_MENU_ITEM))
#define FILES_ABSTRACT_DIRECTORY_VIEW_NEW_SUB_MENU_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_ABSTRACT_DIRECTORY_VIEW_TYPE_NEW_SUB_MENU_ITEM, FilesAbstractDirectoryViewNewSubMenuItemClass))

typedef struct _FilesAbstractDirectoryViewNewSubMenuItem FilesAbstractDirectoryViewNewSubMenuItem;
typedef struct _FilesAbstractDirectoryViewNewSubMenuItemClass FilesAbstractDirectoryViewNewSubMenuItemClass;
typedef struct _Block22Data Block22Data;
typedef struct _Block23Data Block23Data;

#define FILES_TYPE_ABSTRACT_EDITABLE_LABEL (files_abstract_editable_label_get_type ())
#define FILES_ABSTRACT_EDITABLE_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_TYPE_ABSTRACT_EDITABLE_LABEL, FilesAbstractEditableLabel))
#define FILES_ABSTRACT_EDITABLE_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_TYPE_ABSTRACT_EDITABLE_LABEL, FilesAbstractEditableLabelClass))
#define FILES_IS_ABSTRACT_EDITABLE_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_TYPE_ABSTRACT_EDITABLE_LABEL))
#define FILES_IS_ABSTRACT_EDITABLE_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_TYPE_ABSTRACT_EDITABLE_LABEL))
#define FILES_ABSTRACT_EDITABLE_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_TYPE_ABSTRACT_EDITABLE_LABEL, FilesAbstractEditableLabelClass))

typedef struct _FilesAbstractEditableLabel FilesAbstractEditableLabel;
typedef struct _FilesAbstractEditableLabelClass FilesAbstractEditableLabelClass;
typedef struct _FilesAbstractDirectoryViewSetFileDisplayNameData FilesAbstractDirectoryViewSetFileDisplayNameData;
typedef struct _Block24Data Block24Data;
typedef struct _Block25Data Block25Data;
typedef struct _Block26Data Block26Data;
#define __vala_GtkTreeRowReference_free0(var) ((var == NULL) ? NULL : (var = (_vala_GtkTreeRowReference_free (var), NULL)))
typedef struct _FilesIconRendererPrivate FilesIconRendererPrivate;
typedef struct _FilesAbstractDirectoryViewSortSubMenuItemPrivate FilesAbstractDirectoryViewSortSubMenuItemPrivate;
enum  {
	FILES_ABSTRACT_DIRECTORY_VIEW_SORT_SUB_MENU_ITEM_0_PROPERTY,
	FILES_ABSTRACT_DIRECTORY_VIEW_SORT_SUB_MENU_ITEM_NUM_PROPERTIES
};
static GParamSpec* files_abstract_directory_view_sort_sub_menu_item_properties[FILES_ABSTRACT_DIRECTORY_VIEW_SORT_SUB_MENU_ITEM_NUM_PROPERTIES];
typedef struct _FilesAbstractDirectoryViewNewSubMenuItemPrivate FilesAbstractDirectoryViewNewSubMenuItemPrivate;
enum  {
	FILES_ABSTRACT_DIRECTORY_VIEW_NEW_SUB_MENU_ITEM_0_PROPERTY,
	FILES_ABSTRACT_DIRECTORY_VIEW_NEW_SUB_MENU_ITEM_NUM_PROPERTIES
};
static GParamSpec* files_abstract_directory_view_new_sub_menu_item_properties[FILES_ABSTRACT_DIRECTORY_VIEW_NEW_SUB_MENU_ITEM_NUM_PROPERTIES];
enum  {
	FILES_ABSTRACT_DIRECTORY_VIEW_PATH_CHANGE_REQUEST_SIGNAL,
	FILES_ABSTRACT_DIRECTORY_VIEW_SELECTION_CHANGED_SIGNAL,
	FILES_ABSTRACT_DIRECTORY_VIEW_NUM_SIGNALS
};
static guint files_abstract_directory_view_signals[FILES_ABSTRACT_DIRECTORY_VIEW_NUM_SIGNALS] = {0};
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _FilesAbstractDirectoryView {
	GtkScrolledWindow parent_instance;
	FilesAbstractDirectoryViewPrivate * priv;
	FilesZoomLevel minimum_zoom;
	FilesZoomLevel maximum_zoom;
	gboolean large_thumbnails;
	GList* source_drag_file_list;
	GdkAtom current_target_type;
	gboolean dnd_disabled;
	FilesTextRenderer* name_renderer;
	gchar* original_name;
	gchar* proposed_name;
	gboolean right_margin_unselects_all;
	gboolean on_directory;
	gboolean one_or_less;
	gboolean should_activate;
	gboolean should_scroll;
	gboolean should_deselect;
	gboolean should_select;
	GtkTreePath* click_path;
	guint click_zone;
	guint previous_click_zone;
	GList* selected_files;
	gboolean is_writable;
	gboolean is_loading;
	gboolean helpers_shown;
	FilesListModel* model;
	FilesIconRenderer* icon_renderer;
	FilesViewSlot* slot;
	FilesViewWindow* window;
	GtkRecentManager* recent;
};

struct _FilesAbstractDirectoryViewClass {
	GtkScrolledWindowClass parent_class;
	void (*set_up_name_renderer) (FilesAbstractDirectoryView* self);
	void (*on_row_deleted) (FilesAbstractDirectoryView* self, GtkTreePath* path);
	gboolean (*on_view_key_press_event) (FilesAbstractDirectoryView* self, GdkEventKey* event);
	gboolean (*on_scroll_event) (FilesAbstractDirectoryView* self, GdkEventScroll* event);
	gboolean (*on_view_draw) (FilesAbstractDirectoryView* self, cairo_t* cr);
	gboolean (*handle_primary_button_click) (FilesAbstractDirectoryView* self, GdkEventButton* event, GtkTreePath* path);
	gboolean (*handle_secondary_button_click) (FilesAbstractDirectoryView* self, GdkEventButton* event);
	gboolean (*on_view_button_press_event) (FilesAbstractDirectoryView* self, GdkEventButton* event);
	gboolean (*on_view_button_release_event) (FilesAbstractDirectoryView* self, GdkEventButton* event);
	void (*change_zoom_level) (FilesAbstractDirectoryView* self);
	gboolean (*expand_collapse) (FilesAbstractDirectoryView* self, GtkTreePath* path);
	gboolean (*handle_default_button_click) (FilesAbstractDirectoryView* self, GdkEventButton* event);
	gboolean (*get_next_visible_iter) (FilesAbstractDirectoryView* self, GtkTreeIter* iter, gboolean recurse);
	void (*cancel) (FilesAbstractDirectoryView* self);
	void (*highlight_path) (FilesAbstractDirectoryView* self, GtkTreePath* path);
	GtkTreePath* (*up) (FilesAbstractDirectoryView* self, GtkTreePath* path);
	GtkTreePath* (*down) (FilesAbstractDirectoryView* self, GtkTreePath* path);
	GList* (*get_selected_paths) (FilesAbstractDirectoryView* self);
	GtkTreePath* (*get_path_at_pos) (FilesAbstractDirectoryView* self, gint x, gint win);
	GtkTreePath* (*get_path_at_cursor) (FilesAbstractDirectoryView* self);
	void (*tree_select_all) (FilesAbstractDirectoryView* self);
	void (*tree_unselect_all) (FilesAbstractDirectoryView* self);
	void (*tree_unselect_others) (FilesAbstractDirectoryView* self);
	void (*select_path) (FilesAbstractDirectoryView* self, GtkTreePath* path, gboolean cursor_follows);
	void (*unselect_path) (FilesAbstractDirectoryView* self, GtkTreePath* path);
	gboolean (*path_is_selected) (FilesAbstractDirectoryView* self, GtkTreePath* path);
	gboolean (*get_visible_range) (FilesAbstractDirectoryView* self, GtkTreePath** start_path, GtkTreePath** end_path);
	void (*set_cursor) (FilesAbstractDirectoryView* self, GtkTreePath* path, gboolean start_editing, gboolean select, gboolean scroll_to_top);
	gboolean (*move_cursor) (FilesAbstractDirectoryView* self, guint keyval, gboolean only_shift_pressed, gboolean control_pressed);
	gboolean (*will_handle_button_press) (FilesAbstractDirectoryView* self, gboolean no_mods, gboolean only_control_pressed, gboolean only_shift_pressed);
	gboolean (*handle_multi_select) (FilesAbstractDirectoryView* self, GtkTreePath* path);
	GtkWidget* (*create_view) (FilesAbstractDirectoryView* self);
	void (*set_up_zoom_level) (FilesAbstractDirectoryView* self);
	FilesZoomLevel (*get_normal_zoom_level) (FilesAbstractDirectoryView* self);
	gboolean (*view_has_focus) (FilesAbstractDirectoryView* self);
	guint (*get_selected_files_from_model) (FilesAbstractDirectoryView* self, GList** selected_files);
	guint (*get_event_position_info) (FilesAbstractDirectoryView* self, GdkEventButton* event, GtkTreePath** path, gboolean rubberband);
	void (*scroll_to_cell) (FilesAbstractDirectoryView* self, GtkTreePath* path, gboolean scroll_to_top);
	void (*set_cursor_on_cell) (FilesAbstractDirectoryView* self, GtkTreePath* path, GtkCellRenderer* renderer, gboolean start_editing, gboolean scroll_to_top);
	void (*freeze_tree) (FilesAbstractDirectoryView* self);
	void (*thaw_tree) (FilesAbstractDirectoryView* self);
	void (*freeze_child_notify) (FilesAbstractDirectoryView* self);
	void (*thaw_child_notify) (FilesAbstractDirectoryView* self);
	void (*connect_tree_signals) (FilesAbstractDirectoryView* self);
	void (*disconnect_tree_signals) (FilesAbstractDirectoryView* self);
};

struct _FilesAbstractDirectoryViewPrivate {
	GSimpleActionGroup* common_actions;
	GSimpleActionGroup* selection_actions;
	GSimpleActionGroup* background_actions;
	FilesZoomLevel _zoom_level;
	gdouble drag_x;
	gdouble drag_y;
	gint drag_button;
	guint drag_timer_id;
	guint drag_scroll_timer_id;
	guint drag_enter_timer_id;
	gboolean destination_data_ready;
	gboolean drop_occurred;
	FilesFile* drop_target_file;
	GList* destination_drop_file_list;
	GdkDragAction current_suggested_action;
	GdkDragAction current_actions;
	gboolean _drop_highlight;
	void* drag_data;
	gint thumbnail_request;
	guint thumbnail_source_id;
	guint freeze_source_id;
	FilesThumbnailer* thumbnailer;
	guint add_remove_file_timeout_id;
	gboolean signal_free_space_change;
	gdouble total_delta_y;
	GtkTreePath* deleted_path;
	gboolean _singleclick_select;
	GdkCursor* editable_cursor;
	GdkCursor* activatable_cursor;
	GdkCursor* selectable_cursor;
	GList* open_with_apps;
	gboolean selected_files_invalid;
	GAppInfo* default_app;
	GtkTreePath* hover_path;
	gboolean _renaming;
	gboolean _is_frozen;
	gboolean _in_recent;
	gboolean _tree_frozen;
	gboolean in_trash;
	gboolean in_network_root;
	gboolean _show_remote_thumbnails;
	gboolean _show_local_thumbnails;
	gboolean all_selected;
	GtkWidget* view;
	FilesClipboardManager* clipboard;
	guint set_cursor_timeout_id;
	gulong select_source_handler;
	guint draw_timeout_id;
};

struct _Block12Data {
	int _ref_count_;
	FilesAbstractDirectoryView* self;
	gboolean select;
};

struct _Block13Data {
	int _ref_count_;
	FilesAbstractDirectoryView* self;
	GeeLinkedList* files_to_select_list;
	GFile* focus_after_select;
};

struct _Block14Data {
	int _ref_count_;
	FilesAbstractDirectoryView* self;
	GdkScreen* screen;
	FilesOpenFlag flag;
};

struct _Block15Data {
	int _ref_count_;
	Block14Data * _data14_;
	FilesFile* file;
};

struct _Block16Data {
	int _ref_count_;
	Block14Data * _data14_;
	GList* files_to_open;
};

struct _Block17Data {
	int _ref_count_;
	FilesAbstractDirectoryView* self;
	gboolean only_folders;
};

struct _Block18Data {
	int _ref_count_;
	FilesAbstractDirectoryView* self;
	GList* locations;
};

struct _Block19Data {
	int _ref_count_;
	FilesAbstractDirectoryView* self;
	GFile* target;
};

struct _Block20Data {
	int _ref_count_;
	FilesAbstractDirectoryView* self;
	GFile* target;
};

struct _Block21Data {
	int _ref_count_;
	FilesAbstractDirectoryView* self;
	GdkEvent* event;
};

struct _Block22Data {
	int _ref_count_;
	FilesAbstractDirectoryView* self;
	GdkDragContext* context;
};

struct _Block23Data {
	int _ref_count_;
	FilesAbstractDirectoryView* self;
	GList* action_files;
};

struct _FilesAbstractDirectoryViewSetFileDisplayNameData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	FilesAbstractDirectoryView* self;
	GFile* old_location;
	gchar* new_name;
	GCancellable* cancellable;
	GFile* result;
	FilesViewSlot* _tmp0_;
	FilesDirectory* _tmp1_;
	FilesDirectory* _tmp2_;
	GFile* _tmp3_;
	GFile* _tmp4_;
	GFile* _tmp5_;
	GError* e;
	GError* _tmp6_;
	GError* _tmp7_;
	GError* _inner_error0_;
};

struct _Block24Data {
	int _ref_count_;
	FilesAbstractDirectoryView* self;
	guint button;
};

struct _Block25Data {
	int _ref_count_;
	FilesAbstractDirectoryView* self;
	GtkTreePath* path;
	guint count;
	gboolean ok_next_time;
	GtkTreePath* start_path;
};

struct _Block26Data {
	int _ref_count_;
	FilesAbstractDirectoryView* self;
	FilesDirectory* dir;
};

struct _FilesIconRenderer {
	GtkCellRenderer parent_instance;
	FilesIconRendererPrivate * priv;
	GdkRectangle hover_helper_rect;
	GdkRectangle hover_rect;
};

struct _FilesIconRendererClass {
	GtkCellRendererClass parent_class;
};

struct _FilesAbstractDirectoryViewSortSubMenuItem {
	GtkMenuItem parent_instance;
	FilesAbstractDirectoryViewSortSubMenuItemPrivate * priv;
};

struct _FilesAbstractDirectoryViewSortSubMenuItemClass {
	GtkMenuItemClass parent_class;
};

struct _FilesAbstractDirectoryViewNewSubMenuItem {
	GtkMenuItem parent_instance;
	FilesAbstractDirectoryViewNewSubMenuItemPrivate * priv;
};

struct _FilesAbstractDirectoryViewNewSubMenuItemClass {
	GtkMenuItemClass parent_class;
};

static gint FilesAbstractDirectoryView_private_offset;
static gpointer files_abstract_directory_view_parent_class = NULL;
static GList* files_abstract_directory_view_templates;
static GList* files_abstract_directory_view_templates = NULL;
VALA_EXTERN FilesDndHandler* files_abstract_directory_view_dnd_handler;
FilesDndHandler* files_abstract_directory_view_dnd_handler = NULL;
VALA_EXTERN GSettings* files_app_settings;
static gpointer files_abstract_directory_view_sort_sub_menu_item_parent_class = NULL;
static gpointer files_abstract_directory_view_new_sub_menu_item_parent_class = NULL;

VALA_EXTERN GType files_abstract_directory_view_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesAbstractDirectoryView, g_object_unref)
VALA_EXTERN GType files_text_renderer_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesTextRenderer, g_object_unref)
VALA_EXTERN GType files_icon_renderer_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesIconRenderer, g_object_unref)
VALA_EXTERN GType files_view_slot_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesViewSlot, g_object_unref)
VALA_EXTERN GType files_view_window_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesViewWindow, g_object_unref)
VALA_EXTERN GType files_clipboard_manager_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesClipboardManager, g_object_unref)
VALA_EXTERN void files_abstract_directory_view_set_up_name_renderer (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_on_row_deleted (FilesAbstractDirectoryView* self,
                                                   GtkTreePath* path);
VALA_EXTERN gboolean files_abstract_directory_view_on_view_key_press_event (FilesAbstractDirectoryView* self,
                                                                GdkEventKey* event);
VALA_EXTERN gboolean files_abstract_directory_view_on_scroll_event (FilesAbstractDirectoryView* self,
                                                        GdkEventScroll* event);
VALA_EXTERN gboolean files_abstract_directory_view_on_view_draw (FilesAbstractDirectoryView* self,
                                                     cairo_t* cr);
VALA_EXTERN gboolean files_abstract_directory_view_handle_primary_button_click (FilesAbstractDirectoryView* self,
                                                                    GdkEventButton* event,
                                                                    GtkTreePath* path);
VALA_EXTERN gboolean files_abstract_directory_view_handle_secondary_button_click (FilesAbstractDirectoryView* self,
                                                                      GdkEventButton* event);
VALA_EXTERN gboolean files_abstract_directory_view_on_view_button_press_event (FilesAbstractDirectoryView* self,
                                                                   GdkEventButton* event);
VALA_EXTERN gboolean files_abstract_directory_view_on_view_button_release_event (FilesAbstractDirectoryView* self,
                                                                     GdkEventButton* event);
VALA_EXTERN void files_abstract_directory_view_change_zoom_level (FilesAbstractDirectoryView* self);
VALA_EXTERN gboolean files_abstract_directory_view_expand_collapse (FilesAbstractDirectoryView* self,
                                                        GtkTreePath* path);
VALA_EXTERN gboolean files_abstract_directory_view_handle_default_button_click (FilesAbstractDirectoryView* self,
                                                                    GdkEventButton* event);
VALA_EXTERN gboolean files_abstract_directory_view_get_next_visible_iter (FilesAbstractDirectoryView* self,
                                                              GtkTreeIter* iter,
                                                              gboolean recurse);
VALA_EXTERN void files_abstract_directory_view_cancel (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_highlight_path (FilesAbstractDirectoryView* self,
                                                   GtkTreePath* path);
VALA_EXTERN GtkTreePath* files_abstract_directory_view_up (FilesAbstractDirectoryView* self,
                                               GtkTreePath* path);
VALA_EXTERN GtkTreePath* files_abstract_directory_view_down (FilesAbstractDirectoryView* self,
                                                 GtkTreePath* path);
VALA_EXTERN GList* files_abstract_directory_view_get_selected_paths (FilesAbstractDirectoryView* self);
VALA_EXTERN GtkTreePath* files_abstract_directory_view_get_path_at_pos (FilesAbstractDirectoryView* self,
                                                            gint x,
                                                            gint win);
VALA_EXTERN GtkTreePath* files_abstract_directory_view_get_path_at_cursor (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_tree_select_all (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_tree_unselect_all (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_tree_unselect_others (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_select_path (FilesAbstractDirectoryView* self,
                                                GtkTreePath* path,
                                                gboolean cursor_follows);
VALA_EXTERN void files_abstract_directory_view_unselect_path (FilesAbstractDirectoryView* self,
                                                  GtkTreePath* path);
VALA_EXTERN gboolean files_abstract_directory_view_path_is_selected (FilesAbstractDirectoryView* self,
                                                         GtkTreePath* path);
VALA_EXTERN gboolean files_abstract_directory_view_get_visible_range (FilesAbstractDirectoryView* self,
                                                          GtkTreePath** start_path,
                                                          GtkTreePath** end_path);
VALA_EXTERN void files_abstract_directory_view_set_cursor (FilesAbstractDirectoryView* self,
                                               GtkTreePath* path,
                                               gboolean start_editing,
                                               gboolean select,
                                               gboolean scroll_to_top);
VALA_EXTERN gboolean files_abstract_directory_view_move_cursor (FilesAbstractDirectoryView* self,
                                                    guint keyval,
                                                    gboolean only_shift_pressed,
                                                    gboolean control_pressed);
VALA_EXTERN gboolean files_abstract_directory_view_will_handle_button_press (FilesAbstractDirectoryView* self,
                                                                 gboolean no_mods,
                                                                 gboolean only_control_pressed,
                                                                 gboolean only_shift_pressed);
VALA_EXTERN gboolean files_abstract_directory_view_handle_multi_select (FilesAbstractDirectoryView* self,
                                                            GtkTreePath* path);
VALA_EXTERN GtkWidget* files_abstract_directory_view_create_view (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_set_up_zoom_level (FilesAbstractDirectoryView* self);
VALA_EXTERN FilesZoomLevel files_abstract_directory_view_get_normal_zoom_level (FilesAbstractDirectoryView* self);
VALA_EXTERN gboolean files_abstract_directory_view_view_has_focus (FilesAbstractDirectoryView* self);
VALA_EXTERN guint files_abstract_directory_view_get_selected_files_from_model (FilesAbstractDirectoryView* self,
                                                                   GList** selected_files);
VALA_EXTERN guint files_abstract_directory_view_get_event_position_info (FilesAbstractDirectoryView* self,
                                                             GdkEventButton* event,
                                                             GtkTreePath** path,
                                                             gboolean rubberband);
VALA_EXTERN void files_abstract_directory_view_scroll_to_cell (FilesAbstractDirectoryView* self,
                                                   GtkTreePath* path,
                                                   gboolean scroll_to_top);
VALA_EXTERN void files_abstract_directory_view_set_cursor_on_cell (FilesAbstractDirectoryView* self,
                                                       GtkTreePath* path,
                                                       GtkCellRenderer* renderer,
                                                       gboolean start_editing,
                                                       gboolean scroll_to_top);
VALA_EXTERN void files_abstract_directory_view_freeze_tree (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_thaw_tree (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_freeze_child_notify (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_thaw_child_notify (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_connect_tree_signals (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_disconnect_tree_signals (FilesAbstractDirectoryView* self);
VALA_EXTERN GType files_abstract_directory_view_click_zone_get_type (void) G_GNUC_CONST ;
static void files_abstract_directory_view_on_selection_action_open_executable (FilesAbstractDirectoryView* self,
                                                                        GSimpleAction* action,
                                                                        GVariant* param);
static void _files_abstract_directory_view_on_selection_action_open_executable_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                          GVariant* parameter,
                                                                                                          gpointer self);
static void files_abstract_directory_view_on_selection_action_open_with_app (FilesAbstractDirectoryView* self,
                                                                      GSimpleAction* action,
                                                                      GVariant* param);
static void _files_abstract_directory_view_on_selection_action_open_with_app_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                        GVariant* parameter,
                                                                                                        gpointer self);
static void files_abstract_directory_view_on_selection_action_open_with_default (FilesAbstractDirectoryView* self,
                                                                          GSimpleAction* action,
                                                                          GVariant* param);
static void _files_abstract_directory_view_on_selection_action_open_with_default_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                            GVariant* parameter,
                                                                                                            gpointer self);
static void files_abstract_directory_view_on_selection_action_open_with_other_app (FilesAbstractDirectoryView* self);
static void _files_abstract_directory_view_on_selection_action_open_with_other_app_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                              GVariant* parameter,
                                                                                                              gpointer self);
static void files_abstract_directory_view_on_selection_action_rename (FilesAbstractDirectoryView* self,
                                                               GSimpleAction* action,
                                                               GVariant* param);
static void _files_abstract_directory_view_on_selection_action_rename_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                 GVariant* parameter,
                                                                                                 gpointer self);
static void files_abstract_directory_view_on_selection_action_view_in_location (FilesAbstractDirectoryView* self,
                                                                         GSimpleAction* action,
                                                                         GVariant* param);
static void _files_abstract_directory_view_on_selection_action_view_in_location_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                           GVariant* parameter,
                                                                                                           gpointer self);
static void files_abstract_directory_view_on_selection_action_forget (FilesAbstractDirectoryView* self,
                                                               GSimpleAction* action,
                                                               GVariant* param);
static void _files_abstract_directory_view_on_selection_action_forget_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                 GVariant* parameter,
                                                                                                 gpointer self);
static void files_abstract_directory_view_on_selection_action_cut (FilesAbstractDirectoryView* self,
                                                            GSimpleAction* action,
                                                            GVariant* param);
static void _files_abstract_directory_view_on_selection_action_cut_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                              GVariant* parameter,
                                                                                              gpointer self);
static void files_abstract_directory_view_on_selection_action_trash (FilesAbstractDirectoryView* self,
                                                              GSimpleAction* action,
                                                              GVariant* param);
static void _files_abstract_directory_view_on_selection_action_trash_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                GVariant* parameter,
                                                                                                gpointer self);
static void files_abstract_directory_view_on_selection_action_delete (FilesAbstractDirectoryView* self,
                                                               GSimpleAction* action,
                                                               GVariant* param);
static void _files_abstract_directory_view_on_selection_action_delete_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                 GVariant* parameter,
                                                                                                 gpointer self);
static void files_abstract_directory_view_on_selection_action_restore (FilesAbstractDirectoryView* self,
                                                                GSimpleAction* action,
                                                                GVariant* param);
static void _files_abstract_directory_view_on_selection_action_restore_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                  GVariant* parameter,
                                                                                                  gpointer self);
VALA_EXTERN void files_abstract_directory_view_invert_selection (FilesAbstractDirectoryView* self);
static void _files_abstract_directory_view_invert_selection_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                       GVariant* parameter,
                                                                                       gpointer self);
static void files_abstract_directory_view_on_background_action_new (FilesAbstractDirectoryView* self,
                                                             GSimpleAction* action,
                                                             GVariant* param);
static void _files_abstract_directory_view_on_background_action_new_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                               GVariant* parameter,
                                                                                               gpointer self);
static void files_abstract_directory_view_on_background_action_create_from (FilesAbstractDirectoryView* self,
                                                                     GSimpleAction* action,
                                                                     GVariant* param);
static void _files_abstract_directory_view_on_background_action_create_from_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                       GVariant* parameter,
                                                                                                       gpointer self);
static void files_abstract_directory_view_on_background_action_sort_by_changed (FilesAbstractDirectoryView* self,
                                                                         GSimpleAction* action,
                                                                         GVariant* val);
static void _files_abstract_directory_view_on_background_action_sort_by_changed_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                           GVariant* parameter,
                                                                                                           gpointer self);
static void files_abstract_directory_view_on_background_action_reverse_changed (FilesAbstractDirectoryView* self,
                                                                         GSimpleAction* action,
                                                                         GVariant* val);
static void _files_abstract_directory_view_on_background_action_reverse_changed_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                           GVariant* parameter,
                                                                                                           gpointer self);
static void files_abstract_directory_view_on_background_action_folders_first_changed (FilesAbstractDirectoryView* self,
                                                                               GSimpleAction* action,
                                                                               GVariant* val);
static void _files_abstract_directory_view_on_background_action_folders_first_changed_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                                 GVariant* parameter,
                                                                                                                 gpointer self);
static void files_abstract_directory_view_change_state_show_hidden (FilesAbstractDirectoryView* self,
                                                             GSimpleAction* action);
static void _files_abstract_directory_view_change_state_show_hidden_gsimple_action_change_state_callback (GSimpleAction* action,
                                                                                                   GVariant* value,
                                                                                                   gpointer self);
static void files_abstract_directory_view_change_state_show_remote_thumbnails (FilesAbstractDirectoryView* self,
                                                                        GSimpleAction* action);
static void _files_abstract_directory_view_change_state_show_remote_thumbnails_gsimple_action_change_state_callback (GSimpleAction* action,
                                                                                                              GVariant* value,
                                                                                                              gpointer self);
static void files_abstract_directory_view_change_state_show_local_thumbnails (FilesAbstractDirectoryView* self,
                                                                       GSimpleAction* action);
static void _files_abstract_directory_view_change_state_show_local_thumbnails_gsimple_action_change_state_callback (GSimpleAction* action,
                                                                                                             GVariant* value,
                                                                                                             gpointer self);
static void files_abstract_directory_view_on_common_action_copy (FilesAbstractDirectoryView* self,
                                                          GSimpleAction* action,
                                                          GVariant* param);
static void _files_abstract_directory_view_on_common_action_copy_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                            GVariant* parameter,
                                                                                            gpointer self);
static void files_abstract_directory_view_on_common_action_paste_into (FilesAbstractDirectoryView* self,
                                                                GSimpleAction* action,
                                                                GVariant* param);
static void _files_abstract_directory_view_on_common_action_paste_into_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                  GVariant* parameter,
                                                                                                  gpointer self);
static void files_abstract_directory_view_on_common_action_paste (FilesAbstractDirectoryView* self,
                                                           GSimpleAction* action,
                                                           GVariant* param);
static void _files_abstract_directory_view_on_common_action_paste_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                             GVariant* parameter,
                                                                                             gpointer self);
static void files_abstract_directory_view_on_common_action_open_in (FilesAbstractDirectoryView* self,
                                                             GSimpleAction* action,
                                                             GVariant* param);
static void _files_abstract_directory_view_on_common_action_open_in_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                               GVariant* parameter,
                                                                                               gpointer self);
static void files_abstract_directory_view_on_common_action_bookmark (FilesAbstractDirectoryView* self,
                                                              GSimpleAction* action,
                                                              GVariant* param);
static void _files_abstract_directory_view_on_common_action_bookmark_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                GVariant* parameter,
                                                                                                gpointer self);
static void files_abstract_directory_view_on_common_action_properties (FilesAbstractDirectoryView* self,
                                                                GSimpleAction* action,
                                                                GVariant* param);
static void _files_abstract_directory_view_on_common_action_properties_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                  GVariant* parameter,
                                                                                                  gpointer self);
static void files_abstract_directory_view_on_common_action_copy_link (FilesAbstractDirectoryView* self,
                                                               GSimpleAction* action,
                                                               GVariant* param);
static void _files_abstract_directory_view_on_common_action_copy_link_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                 GVariant* parameter,
                                                                                                 gpointer self);
static void files_abstract_directory_view_toggle_select_all (FilesAbstractDirectoryView* self);
static void _files_abstract_directory_view_toggle_select_all_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                        GVariant* parameter,
                                                                                        gpointer self);
static void _g_object_unref0_ (gpointer var);
static inline void _g_list_free__g_object_unref0_ (GList* self);
static void _vala_GtkTreePath_free (GtkTreePath* self);
VALA_EXTERN FilesAbstractDirectoryView* files_abstract_directory_view_construct (GType object_type,
                                                                     FilesViewSlot* _slot);
VALA_EXTERN FilesViewWindow* files_view_slot_get_window (FilesViewSlot* self);
VALA_EXTERN GType files_application_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesApplication, g_object_unref)
VALA_EXTERN FilesClipboardManager* files_application_get_clipboard_manager (FilesApplication* self);
VALA_EXTERN GtkRecentManager* files_application_get_recent_manager (FilesApplication* self);
static void __lambda113_ (FilesAbstractDirectoryView* self,
                   guint req);
static void files_abstract_directory_view_draw_when_idle (FilesAbstractDirectoryView* self);
static void ___lambda113__files_thumbnailer_finished (FilesThumbnailer* _sender,
                                               guint request,
                                               gpointer self);
static void files_abstract_directory_view_set_up__menu_actions (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_set_up_directory_view (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_connect_drag_drop_signals (FilesAbstractDirectoryView* self,
                                                              GtkWidget* widget);
VALA_EXTERN gboolean files_abstract_directory_view_on_motion_notify_event (FilesAbstractDirectoryView* self,
                                                               GdkEventMotion* event);
static gboolean _files_abstract_directory_view_on_motion_notify_event_gtk_widget_motion_notify_event (GtkWidget* _sender,
                                                                                               GdkEventMotion* event,
                                                                                               gpointer self);
VALA_EXTERN gboolean files_abstract_directory_view_on_leave_notify_event (FilesAbstractDirectoryView* self,
                                                              GdkEventCrossing* event);
static gboolean _files_abstract_directory_view_on_leave_notify_event_gtk_widget_leave_notify_event (GtkWidget* _sender,
                                                                                             GdkEventCrossing* event,
                                                                                             gpointer self);
static gboolean _files_abstract_directory_view_on_view_key_press_event_gtk_widget_key_press_event (GtkWidget* _sender,
                                                                                            GdkEventKey* event,
                                                                                            gpointer self);
static gboolean _files_abstract_directory_view_on_view_button_press_event_gtk_widget_button_press_event (GtkWidget* _sender,
                                                                                                  GdkEventButton* event,
                                                                                                  gpointer self);
static gboolean _files_abstract_directory_view_on_view_button_release_event_gtk_widget_button_release_event (GtkWidget* _sender,
                                                                                                      GdkEventButton* event,
                                                                                                      gpointer self);
static gboolean _files_abstract_directory_view_on_view_draw_gtk_widget_draw (GtkWidget* _sender,
                                                                      cairo_t* cr,
                                                                      gpointer self);
VALA_EXTERN void files_abstract_directory_view_connect_directory_handlers (FilesAbstractDirectoryView* self,
                                                               FilesDirectory* dir);
static void files_abstract_directory_view_real_set_up_name_renderer (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_on_name_edited (FilesAbstractDirectoryView* self,
                                                   const gchar* path_string,
                                                   const gchar* _new_name);
static void _files_abstract_directory_view_on_name_edited_gtk_cell_renderer_text_edited (GtkCellRendererText* _sender,
                                                                                  const gchar* path,
                                                                                  const gchar* new_text,
                                                                                  gpointer self);
VALA_EXTERN void files_abstract_directory_view_on_name_editing_canceled (FilesAbstractDirectoryView* self);
static void _files_abstract_directory_view_on_name_editing_canceled_gtk_cell_renderer_editing_canceled (GtkCellRenderer* _sender,
                                                                                                 gpointer self);
VALA_EXTERN void files_abstract_directory_view_on_name_editing_started (FilesAbstractDirectoryView* self,
                                                            GtkCellEditable* editable,
                                                            const gchar* path_string);
static void _files_abstract_directory_view_on_name_editing_started_gtk_cell_renderer_editing_started (GtkCellRenderer* _sender,
                                                                                               GtkCellEditable* editable,
                                                                                               const gchar* path,
                                                                                               gpointer self);
static gboolean files_abstract_directory_view_on_popup_menu (FilesAbstractDirectoryView* self);
static gboolean _files_abstract_directory_view_on_popup_menu_gtk_widget_popup_menu (GtkWidget* _sender,
                                                                             gpointer self);
static void __lambda114_ (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_on_clipboard_changed (FilesAbstractDirectoryView* self);
static void _files_abstract_directory_view_on_clipboard_changed_files_clipboard_manager_changed (FilesClipboardManager* _sender,
                                                                                          gpointer self);
static void ___lambda114__gtk_widget_unrealize (GtkWidget* _sender,
                                         gpointer self);
static void __lambda115_ (FilesAbstractDirectoryView* self);
static void ___lambda115__gtk_widget_realize (GtkWidget* _sender,
                                       gpointer self);
static gboolean _files_abstract_directory_view_on_scroll_event_gtk_widget_scroll_event (GtkWidget* _sender,
                                                                                 GdkEventScroll* event,
                                                                                 gpointer self);
static void __lambda116_ (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_schedule_thumbnail_color_tag_timeout (FilesAbstractDirectoryView* self);
static void ___lambda116__gtk_adjustment_value_changed (GtkAdjustment* _sender,
                                                 gpointer self);
static void __lambda117_ (FilesAbstractDirectoryView* self);
VALA_EXTERN gboolean files_abstract_directory_view_get_renaming (FilesAbstractDirectoryView* self);
static void ___lambda117__g_object_notify (GObject* _sender,
                                    GParamSpec* pspec,
                                    gpointer self);
static void files_abstract_directory_view_on_show_hidden_files_changed (FilesAbstractDirectoryView* self,
                                                                 GObject* prefs,
                                                                 GParamSpec* pspec);
static void _files_abstract_directory_view_on_show_hidden_files_changed_g_object_notify (GObject* _sender,
                                                                                  GParamSpec* pspec,
                                                                                  gpointer self);
static void files_abstract_directory_view_on_show_remote_thumbnails_changed (FilesAbstractDirectoryView* self,
                                                                      GObject* prefs,
                                                                      GParamSpec* pspec);
static void _files_abstract_directory_view_on_show_remote_thumbnails_changed_g_object_notify (GObject* _sender,
                                                                                       GParamSpec* pspec,
                                                                                       gpointer self);
static void files_abstract_directory_view_on_show_local_thumbnails_changed (FilesAbstractDirectoryView* self,
                                                                     GObject* prefs,
                                                                     GParamSpec* pspec);
static void _files_abstract_directory_view_on_show_local_thumbnails_changed_g_object_notify (GObject* _sender,
                                                                                      GParamSpec* pspec,
                                                                                      gpointer self);
static void files_abstract_directory_view_on_sort_directories_first_changed (FilesAbstractDirectoryView* self,
                                                                      GObject* prefs,
                                                                      GParamSpec* pspec);
static void _files_abstract_directory_view_on_sort_directories_first_changed_g_object_notify (GObject* _sender,
                                                                                       GParamSpec* pspec,
                                                                                       gpointer self);
static void _files_abstract_directory_view_on_row_deleted_gtk_tree_model_row_deleted (GtkTreeModel* _sender,
                                                                               GtkTreePath* path,
                                                                               gpointer self);
VALA_EXTERN void files_abstract_directory_view_on_sort_column_changed (FilesAbstractDirectoryView* self);
static void _files_abstract_directory_view_on_sort_column_changed_gtk_tree_sortable_sort_column_changed (GtkTreeSortable* _sender,
                                                                                                  gpointer self);
static void files_abstract_directory_view_action_set_state (FilesAbstractDirectoryView* self,
                                                     GSimpleActionGroup* action_group,
                                                     const gchar* name,
                                                     GVariant* val);
static GVariant* _variant_new1 (gboolean value);
static GVariant* _variant_new2 (gboolean value);
static GVariant* _variant_new3 (gboolean value);
VALA_EXTERN void files_abstract_directory_view_zoom_in (FilesAbstractDirectoryView* self);
VALA_EXTERN FilesZoomLevel files_abstract_directory_view_get_zoom_level (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_set_zoom_level (FilesAbstractDirectoryView* self,
                                                   FilesZoomLevel value);
VALA_EXTERN void files_abstract_directory_view_zoom_out (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_zoom_normal (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_focus_first_for_empty_selection (FilesAbstractDirectoryView* self,
                                                                    gboolean select);
static Block12Data* block12_data_ref (Block12Data* _data12_);
static void block12_data_unref (void * _userdata_);
static gboolean ___lambda96_ (Block12Data* _data12_);
VALA_EXTERN gboolean files_abstract_directory_view_get_tree_frozen (FilesAbstractDirectoryView* self);
static gboolean ____lambda96__gsource_func (gpointer self);
VALA_EXTERN void files_abstract_directory_view_select_glib_files_when_thawed (FilesAbstractDirectoryView* self,
                                                                  GList* location_list,
                                                                  GFile* focus_location);
static Block13Data* block13_data_ref (Block13Data* _data13_);
static void block13_data_unref (void * _userdata_);
static void __lambda94_ (Block13Data* _data13_,
                  GFile* loc);
static void ___lambda94__gfunc (gconstpointer data,
                         gpointer self);
static void ___lambda95_ (Block13Data* _data13_);
static void files_abstract_directory_view_select_files_and_update_if_thawed (FilesAbstractDirectoryView* self,
                                                                      GeeLinkedList* files_to_select,
                                                                      GFile* focus_file);
static void ____lambda95__g_object_notify (GObject* _sender,
                                    GParamSpec* pspec,
                                    gpointer self);
VALA_EXTERN void files_abstract_directory_view_unselect_all (FilesAbstractDirectoryView* self);
static void _vala_GtkTreeIter_free (GtkTreeIter* self);
VALA_EXTERN void files_abstract_directory_view_on_view_selection_changed (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_update_selected_files_and_menu (FilesAbstractDirectoryView* self);
VALA_EXTERN GList* files_abstract_directory_view_get_open_with_apps (FilesAbstractDirectoryView* self);
VALA_EXTERN GAppInfo* files_abstract_directory_view_get_default_app (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_grab_focus (FilesAbstractDirectoryView* self);
VALA_EXTERN gboolean files_view_slot_get_is_active (FilesViewSlot* self);
VALA_EXTERN void files_abstract_directory_view_set_active_slot (FilesAbstractDirectoryView* self,
                                                    gboolean scroll);
VALA_EXTERN GList* files_abstract_directory_view_get_selected_files (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_load_location (FilesAbstractDirectoryView* self,
                                                  GFile* location);
VALA_EXTERN void files_abstract_directory_view_load_root_location (FilesAbstractDirectoryView* self,
                                                       GFile* location);
VALA_EXTERN void files_abstract_directory_view_activate_selected_items (FilesAbstractDirectoryView* self,
                                                            FilesOpenFlag flag,
                                                            GList* selection);
static Block14Data* block14_data_ref (Block14Data* _data14_);
static void block14_data_unref (void * _userdata_);
VALA_EXTERN gboolean files_abstract_directory_view_get_is_frozen (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_activate_file (FilesAbstractDirectoryView* self,
                                                  FilesFile* _file,
                                                  GdkScreen* screen,
                                                  FilesOpenFlag flag,
                                                  gboolean only_one_file);
static gboolean files_abstract_directory_view_app_is_this_app (FilesAbstractDirectoryView* self,
                                                        GAppInfo* ai);
static Block15Data* block15_data_ref (Block15Data* _data15_);
static void block15_data_unref (void * _userdata_);
static gboolean _______lambda63_ (Block15Data* _data15_);
static gboolean ________lambda63__gsource_func (gpointer self);
static gboolean _______lambda64_ (Block15Data* _data15_);
static void files_abstract_directory_view_open_file (FilesAbstractDirectoryView* self,
                                              FilesFile* file,
                                              GdkScreen* screen,
                                              GAppInfo* app_info);
static gboolean ________lambda64__gsource_func (gpointer self);
static Block16Data* block16_data_ref (Block16Data* _data16_);
static void block16_data_unref (void * _userdata_);
static gboolean _____lambda65_ (Block16Data* _data16_);
static void files_abstract_directory_view_open_files_with (FilesAbstractDirectoryView* self,
                                                    GAppInfo* app,
                                                    GList* files);
static gboolean ______lambda65__gsource_func (gpointer self);
VALA_EXTERN void files_abstract_directory_view_select_gof_file (FilesAbstractDirectoryView* self,
                                                    FilesFile* file);
VALA_EXTERN void files_abstract_directory_view_select_and_scroll_to_gof_file (FilesAbstractDirectoryView* self,
                                                                  FilesFile* file);
VALA_EXTERN void files_abstract_directory_view_add_gof_file_to_selection (FilesAbstractDirectoryView* self,
                                                              FilesFile* file);
static void files_abstract_directory_view_on_directory_file_added (FilesAbstractDirectoryView* self,
                                                            FilesDirectory* dir,
                                                            FilesFile* file);
static void _files_abstract_directory_view_on_directory_file_added_files_directory_file_added (FilesDirectory* _sender,
                                                                                        FilesFile* file,
                                                                                        gpointer self);
static void files_abstract_directory_view_on_directory_file_changed (FilesAbstractDirectoryView* self,
                                                              FilesDirectory* dir,
                                                              FilesFile* file);
static void _files_abstract_directory_view_on_directory_file_changed_files_directory_file_changed (FilesDirectory* _sender,
                                                                                            FilesFile* file,
                                                                                            gpointer self);
static void files_abstract_directory_view_on_directory_file_deleted (FilesAbstractDirectoryView* self,
                                                              FilesDirectory* dir,
                                                              FilesFile* file);
static void _files_abstract_directory_view_on_directory_file_deleted_files_directory_file_deleted (FilesDirectory* _sender,
                                                                                            FilesFile* file,
                                                                                            gpointer self);
static void files_abstract_directory_view_on_directory_file_icon_changed (FilesAbstractDirectoryView* self,
                                                                   FilesDirectory* dir,
                                                                   FilesFile* file);
static void _files_abstract_directory_view_on_directory_file_icon_changed_files_directory_icon_changed (FilesDirectory* _sender,
                                                                                                 FilesFile* file,
                                                                                                 gpointer self);
VALA_EXTERN void files_abstract_directory_view_connect_directory_loading_handlers (FilesAbstractDirectoryView* self,
                                                                       FilesDirectory* dir);
static void files_abstract_directory_view_on_directory_file_loaded (FilesAbstractDirectoryView* self,
                                                             FilesDirectory* dir,
                                                             FilesFile* file);
static void _files_abstract_directory_view_on_directory_file_loaded_files_directory_file_loaded (FilesDirectory* _sender,
                                                                                          FilesFile* file,
                                                                                          gpointer self);
static void files_abstract_directory_view_on_directory_done_loading (FilesAbstractDirectoryView* self,
                                                              FilesDirectory* dir);
static void _files_abstract_directory_view_on_directory_done_loading_files_directory_done_loading (FilesDirectory* _sender,
                                                                                            gpointer self);
VALA_EXTERN void files_abstract_directory_view_disconnect_directory_loading_handlers (FilesAbstractDirectoryView* self,
                                                                          FilesDirectory* dir);
VALA_EXTERN void files_abstract_directory_view_disconnect_directory_handlers (FilesAbstractDirectoryView* self,
                                                                  FilesDirectory* dir);
VALA_EXTERN void files_abstract_directory_view_change_directory (FilesAbstractDirectoryView* self,
                                                     FilesDirectory* old_dir,
                                                     FilesDirectory* new_dir);
static void files_abstract_directory_view_clear (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_prepare_reload (FilesAbstractDirectoryView* self,
                                                   FilesDirectory* dir);
VALA_EXTERN void files_abstract_directory_view_block_model (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_unblock_model (FilesAbstractDirectoryView* self);
static gboolean files_abstract_directory_view_on_drag_drop (FilesAbstractDirectoryView* self,
                                                     GdkDragContext* context,
                                                     gint x,
                                                     gint y,
                                                     guint timestamp);
static gboolean _files_abstract_directory_view_on_drag_drop_gtk_widget_drag_drop (GtkWidget* _sender,
                                                                           GdkDragContext* context,
                                                                           gint x,
                                                                           gint y,
                                                                           guint time_,
                                                                           gpointer self);
static void files_abstract_directory_view_on_drag_data_received (FilesAbstractDirectoryView* self,
                                                          GdkDragContext* context,
                                                          gint x,
                                                          gint y,
                                                          GtkSelectionData* selection_data,
                                                          guint info,
                                                          guint timestamp);
static void _files_abstract_directory_view_on_drag_data_received_gtk_widget_drag_data_received (GtkWidget* _sender,
                                                                                         GdkDragContext* context,
                                                                                         gint x,
                                                                                         gint y,
                                                                                         GtkSelectionData* selection_data,
                                                                                         guint info,
                                                                                         guint time_,
                                                                                         gpointer self);
static void files_abstract_directory_view_on_drag_leave (FilesAbstractDirectoryView* self,
                                                  GdkDragContext* context,
                                                  guint timestamp);
static void _files_abstract_directory_view_on_drag_leave_gtk_widget_drag_leave (GtkWidget* _sender,
                                                                         GdkDragContext* context,
                                                                         guint time_,
                                                                         gpointer self);
static gboolean files_abstract_directory_view_on_drag_motion (FilesAbstractDirectoryView* self,
                                                       GdkDragContext* context,
                                                       gint x,
                                                       gint y,
                                                       guint timestamp);
static gboolean _files_abstract_directory_view_on_drag_motion_gtk_widget_drag_motion (GtkWidget* _sender,
                                                                               GdkDragContext* context,
                                                                               gint x,
                                                                               gint y,
                                                                               guint time_,
                                                                               gpointer self);
static void files_abstract_directory_view_on_drag_begin (FilesAbstractDirectoryView* self,
                                                  GdkDragContext* context);
static void _files_abstract_directory_view_on_drag_begin_gtk_widget_drag_begin (GtkWidget* _sender,
                                                                         GdkDragContext* context,
                                                                         gpointer self);
static void files_abstract_directory_view_on_drag_data_get (FilesAbstractDirectoryView* self,
                                                     GdkDragContext* context,
                                                     GtkSelectionData* selection_data,
                                                     guint info,
                                                     guint timestamp);
static void _files_abstract_directory_view_on_drag_data_get_gtk_widget_drag_data_get (GtkWidget* _sender,
                                                                               GdkDragContext* context,
                                                                               GtkSelectionData* selection_data,
                                                                               guint info,
                                                                               guint time_,
                                                                               gpointer self);
static void files_abstract_directory_view_on_drag_data_delete (FilesAbstractDirectoryView* self,
                                                        GdkDragContext* context);
static void _files_abstract_directory_view_on_drag_data_delete_gtk_widget_drag_data_delete (GtkWidget* _sender,
                                                                                     GdkDragContext* context,
                                                                                     gpointer self);
static void files_abstract_directory_view_on_drag_end (FilesAbstractDirectoryView* self,
                                                GdkDragContext* context);
static void _files_abstract_directory_view_on_drag_end_gtk_widget_drag_end (GtkWidget* _sender,
                                                                     GdkDragContext* context,
                                                                     gpointer self);
VALA_EXTERN void files_abstract_directory_view_cancel_drag_timer (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_disconnect_drag_timeout_motion_and_release_events (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_cancel_timeout (FilesAbstractDirectoryView* self,
                                                   guint* id);
VALA_EXTERN void files_abstract_directory_view_cancel_thumbnailing (FilesAbstractDirectoryView* self);
VALA_EXTERN gboolean files_abstract_directory_view_selection_only_contains_folders (FilesAbstractDirectoryView* self,
                                                                        GList* list);
static Block17Data* block17_data_ref (Block17Data* _data17_);
static void block17_data_unref (void * _userdata_);
static void __lambda54_ (Block17Data* _data17_,
                  FilesFile* file);
static void ___lambda54__gfunc (gconstpointer data,
                         gpointer self);
VALA_EXTERN gboolean files_abstract_directory_view_handle_scroll_event (FilesAbstractDirectoryView* self,
                                                            GdkEventScroll* event);
VALA_EXTERN GList* files_abstract_directory_view_get_selected_files_for_transfer (FilesAbstractDirectoryView* self,
                                                                      GList* selection);
VALA_EXTERN gboolean files_abstract_directory_view_get_in_recent (FilesAbstractDirectoryView* self);
VALA_EXTERN GAppInfo* files_mime_actions_get_default_application_for_file (FilesFile* file);
static gboolean files_abstract_directory_view_can_open_file (FilesAbstractDirectoryView* self,
                                                      FilesFile* file,
                                                      gboolean show_error_dialog);
VALA_EXTERN void files_mime_actions_open_glib_file_request (GFile* file_to_open,
                                                GtkWidget* parent,
                                                GAppInfo* app);
static void files_abstract_directory_view_trash_or_delete_files (FilesAbstractDirectoryView* self,
                                                          GList* file_list,
                                                          gboolean delete_if_already_in_trash,
                                                          gboolean delete_immediately);
static Block18Data* block18_data_ref (Block18Data* _data18_);
static void block18_data_unref (void * _userdata_);
static void ___lambda58_ (Block18Data* _data18_,
                   FilesFile* file);
static void ____lambda58__gfunc (gconstpointer data,
                          gpointer self);
static void ___lambda59_ (Block18Data* _data18_,
                   FilesFile* file);
static void ____lambda59__gfunc (gconstpointer data,
                          gpointer self);
static void ___lambda60_ (FilesAbstractDirectoryView* self,
                   GObject* obj,
                   GAsyncResult* res);
VALA_EXTERN void files_abstract_directory_view_after_trash_or_delete (FilesAbstractDirectoryView* self);
static void ____lambda60__gasync_ready_callback (GObject* source_object,
                                          GAsyncResult* res,
                                          gpointer self);
static void files_abstract_directory_view_add_file (FilesAbstractDirectoryView* self,
                                             FilesFile* file,
                                             FilesDirectory* dir,
                                             gboolean select);
static void files_abstract_directory_view_handle_free_space_change (FilesAbstractDirectoryView* self);
static gboolean ___lambda78_ (FilesAbstractDirectoryView* self);
static gboolean ____lambda78__gsource_func (gpointer self);
static void files_abstract_directory_view_new_empty_file (FilesAbstractDirectoryView* self,
                                                   const gchar* parent_uri);
static void __lambda109_ (FilesAbstractDirectoryView* self,
                   GObject* obj,
                   GAsyncResult* res);
VALA_EXTERN void files_abstract_directory_view_create_file_done (GFile* new_file,
                                                     FilesAbstractDirectoryView* self);
static void ___lambda109__gasync_ready_callback (GObject* source_object,
                                          GAsyncResult* res,
                                          gpointer self);
static void files_abstract_directory_view_new_empty_folder (FilesAbstractDirectoryView* self);
static void __lambda66_ (FilesAbstractDirectoryView* self,
                  GObject* obj,
                  GAsyncResult* res);
static void ___lambda66__gasync_ready_callback (GObject* source_object,
                                         GAsyncResult* res,
                                         gpointer self);
static void files_abstract_directory_view_after_new_file_added (FilesAbstractDirectoryView* self,
                                                         FilesFile* file);
static void _files_abstract_directory_view_after_new_file_added_files_directory_file_added (FilesDirectory* _sender,
                                                                                     FilesFile* file,
                                                                                     gpointer self);
VALA_EXTERN void files_abstract_directory_view_rename_file (FilesAbstractDirectoryView* self,
                                                FilesFile* file_to_rename);
static void files_abstract_directory_view_start_renaming_file (FilesAbstractDirectoryView* self,
                                                        FilesFile* file);
static void files_abstract_directory_view_unblock_directory_monitor (FilesAbstractDirectoryView* self);
static gboolean __lambda61_ (FilesAbstractDirectoryView* self);
static gboolean ___lambda61__gsource_func (gpointer self);
static gboolean __lambda62_ (FilesAbstractDirectoryView* self);
static gboolean ___lambda62__gsource_func (gpointer self);
static void files_abstract_directory_view_trash_or_delete_selected_files (FilesAbstractDirectoryView* self,
                                                                   gboolean delete_immediately);
static void files_abstract_directory_view_view_selected_file (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_forget_selected_file (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_rename_selected_file (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_clipboard_manager_cut_files (FilesClipboardManager* self,
                                        GList* files);
VALA_EXTERN gboolean files_is_admin (void);
static GList* files_abstract_directory_view_get_files_for_action (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_view_window_bookmark_uri (FilesViewWindow* self,
                                     const gchar* uri,
                                     const gchar* custom_name);
VALA_EXTERN void files_view_window_change_state_show_hidden (FilesViewWindow* self,
                                                 GSimpleAction* action);
VALA_EXTERN void files_view_window_change_state_show_remote_thumbnails (FilesViewWindow* self,
                                                            GSimpleAction* action);
VALA_EXTERN void files_view_window_change_state_show_local_thumbnails (FilesViewWindow* self,
                                                           GSimpleAction* action);
static void files_abstract_directory_view_create_from_template (FilesAbstractDirectoryView* self,
                                                         GFile* template);
static void files_abstract_directory_view_set_sort (FilesAbstractDirectoryView* self,
                                             const gchar* col_name,
                                             gboolean reverse);
VALA_EXTERN FilesViewPropertiesWindow* files_view_properties_window_new (GList* _files,
                                                             FilesAbstractDirectoryView* _view,
                                                             GtkWindow* parent);
VALA_EXTERN FilesViewPropertiesWindow* files_view_properties_window_construct (GType object_type,
                                                                   GList* _files,
                                                                   FilesAbstractDirectoryView* _view,
                                                                   GtkWindow* parent);
VALA_EXTERN GType files_view_abstract_properties_dialog_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesViewAbstractPropertiesDialog, g_object_unref)
VALA_EXTERN GType files_view_properties_window_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesViewPropertiesWindow, g_object_unref)
VALA_EXTERN void files_clipboard_manager_copy_link_files (FilesClipboardManager* self,
                                              GList* files);
VALA_EXTERN void files_clipboard_manager_copy_files (FilesClipboardManager* self,
                                         GList* files);
VALA_EXTERN gboolean files_clipboard_manager_get_can_paste (FilesClipboardManager* self);
VALA_EXTERN gboolean files_clipboard_manager_get_files_linked (FilesClipboardManager* self);
static Block19Data* block19_data_ref (Block19Data* _data19_);
static void block19_data_unref (void * _userdata_);
VALA_EXTERN void files_clipboard_manager_paste_files (FilesClipboardManager* self,
                                          GFile* target_file,
                                          GtkWidget* widget,
                                          GAsyncReadyCallback _callback_,
                                          gpointer _user_data_);
VALA_EXTERN void files_clipboard_manager_paste_files_finish (FilesClipboardManager* self,
                                                 GAsyncResult* _res_);
static void ___lambda112_ (Block19Data* _data19_,
                    GObject* obj,
                    GAsyncResult* res);
static void ____lambda112__gasync_ready_callback (GObject* source_object,
                                           GAsyncResult* res,
                                           gpointer self);
static Block20Data* block20_data_ref (Block20Data* _data20_);
static void block20_data_unref (void * _userdata_);
VALA_EXTERN gboolean files_clipboard_manager_has_file (FilesClipboardManager* self,
                                           FilesFile* file);
static void ___lambda111_ (Block20Data* _data20_,
                    GObject* obj,
                    GAsyncResult* res);
static void ____lambda111__gasync_ready_callback (GObject* source_object,
                                           GAsyncResult* res,
                                           gpointer self);
VALA_EXTERN void files_abstract_directory_view_select_all (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_remove_marlin_icon_info_cache (FilesAbstractDirectoryView* self,
                                                                  FilesFile* file);
VALA_EXTERN gboolean files_abstract_directory_view_get_show_local_thumbnails (FilesAbstractDirectoryView* self);
VALA_EXTERN gboolean files_abstract_directory_view_get_show_remote_thumbnails (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_set_in_recent (FilesAbstractDirectoryView* self,
                                                  gboolean value);
static void files_abstract_directory_view_on_zoom_level_changed (FilesAbstractDirectoryView* self,
                                                          FilesZoomLevel zoom);
VALA_EXTERN gint files_abstract_directory_view_get_icon_size (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_view_slot_refresh_files (FilesViewSlot* self);
static void files_abstract_directory_view_directory_hidden_changed (FilesAbstractDirectoryView* self,
                                                             FilesDirectory* dir,
                                                             gboolean show);
static GVariant* _variant_new4 (gboolean value);
VALA_EXTERN void files_abstract_directory_view_set_show_remote_thumbnails (FilesAbstractDirectoryView* self,
                                                               gboolean value);
static GVariant* _variant_new5 (gboolean value);
VALA_EXTERN void files_abstract_directory_view_set_show_local_thumbnails (FilesAbstractDirectoryView* self,
                                                              gboolean value);
static GVariant* _variant_new6 (gboolean value);
VALA_EXTERN void files_abstract_directory_view_show_context_menu (FilesAbstractDirectoryView* self,
                                                      GdkEvent* event);
static void _vala_GdkEvent_free (GdkEvent* self);
static gboolean files_abstract_directory_view_on_drag_timeout_button_release (FilesAbstractDirectoryView* self,
                                                                       GdkEventButton* event);
static gboolean files_abstract_directory_view_on_drag_timeout_motion_notify (FilesAbstractDirectoryView* self,
                                                                      GdkEventMotion* event);
static void files_abstract_directory_view_real_on_row_deleted (FilesAbstractDirectoryView* self,
                                                        GtkTreePath* path);
static void files_abstract_directory_view_check_destination_actions_and_target_file (FilesAbstractDirectoryView* self,
                                                                              GdkDragContext* context,
                                                                              gint x,
                                                                              gint y,
                                                                              guint timestamp);
static void files_abstract_directory_view_get_drag_data (FilesAbstractDirectoryView* self,
                                                  GdkDragContext* context,
                                                  gint x,
                                                  gint y,
                                                  guint timestamp);
static void files_abstract_directory_view_start_drag_scroll_timer (FilesAbstractDirectoryView* self,
                                                            GdkDragContext* context);
static FilesFile* files_abstract_directory_view_get_drop_target_file (FilesAbstractDirectoryView* self,
                                                               gint win_x,
                                                               gint win_y);
VALA_EXTERN GtkWindow* files_get_active_window (void);
static void files_abstract_directory_view_clear_destination_drag_data (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_icon_renderer_set_drop_file (FilesIconRenderer* self,
                                        FilesFile* value);
static gboolean files_abstract_directory_view_get_drop_highlight (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_set_drop_highlight (FilesAbstractDirectoryView* self,
                                                       gboolean value);
static void files_abstract_directory_view_highlight_drop_file (FilesAbstractDirectoryView* self,
                                                        FilesFile* drop_file,
                                                        GdkDragAction action,
                                                        GtkTreePath* path);
static gboolean files_abstract_directory_view_is_valid_drop_folder (FilesAbstractDirectoryView* self,
                                                             FilesFile* file);
static gboolean _____lambda119_ (FilesAbstractDirectoryView* self);
static gboolean ______lambda119__gsource_func (gpointer self);
VALA_EXTERN void files_abstract_directory_view_start_drag_timer (FilesAbstractDirectoryView* self,
                                                     GdkEvent* event);
static GdkEvent* _vala_GdkEvent_copy (GdkEvent* self);
static Block21Data* block21_data_ref (Block21Data* _data21_);
static void block21_data_unref (void * _userdata_);
static void files_abstract_directory_view_connect_drag_timeout_motion_and_release_events (FilesAbstractDirectoryView* self);
static gboolean ___lambda121_ (Block21Data* _data21_);
static gboolean ____lambda121__gsource_func (gpointer self);
static void files_abstract_directory_view_update_menu_actions (FilesAbstractDirectoryView* self);
static GVariant* _variant_new7 (const gchar* value);
static GVariant* _variant_new8 (const gchar* value);
VALA_EXTERN GList* files_mime_actions_get_applications_for_files (GList* files);
static void files_abstract_directory_view_filter_default_app_from_open_with_apps (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_filter_this_app_from_open_with_apps (FilesAbstractDirectoryView* self);
static gboolean files_abstract_directory_view_valid_selection_for_restore (FilesAbstractDirectoryView* self);
static gboolean files_abstract_directory_view_valid_selection_for_edit (FilesAbstractDirectoryView* self);
VALA_EXTERN gboolean files_view_window_can_bookmark_uri (FilesViewWindow* self,
                                             const gchar* uri);
VALA_EXTERN gboolean files_clipboard_manager_has_cutted_file (FilesClipboardManager* self,
                                                  FilesFile* file);
static FilesAbstractDirectoryViewSortSubMenuItem* files_abstract_directory_view_sort_sub_menu_item_new (void);
static FilesAbstractDirectoryViewSortSubMenuItem* files_abstract_directory_view_sort_sub_menu_item_construct (GType object_type);
static GType files_abstract_directory_view_sort_sub_menu_item_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesAbstractDirectoryViewSortSubMenuItem, g_object_unref)
static FilesAbstractDirectoryViewNewSubMenuItem* files_abstract_directory_view_new_sub_menu_item_new (void);
static FilesAbstractDirectoryViewNewSubMenuItem* files_abstract_directory_view_new_sub_menu_item_construct (GType object_type);
static GType files_abstract_directory_view_new_sub_menu_item_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesAbstractDirectoryViewNewSubMenuItem, g_object_unref)
static void files_abstract_directory_view_action_set_enabled (FilesAbstractDirectoryView* self,
                                                       GSimpleActionGroup* action_group,
                                                       const gchar* name,
                                                       gboolean enabled);
static void files_abstract_directory_view_update_default_app (FilesAbstractDirectoryView* self,
                                                       GList* selection);
static void files_abstract_directory_view_update_menu_actions_sort (FilesAbstractDirectoryView* self);
VALA_EXTERN GAppInfo* files_mime_actions_get_default_application_for_files (GList* files);
static void files_abstract_directory_view_load_templates_from_folder (GFile* template_folder);
static gint ___lambda55_ (GFile* a,
                   GFile* b);
static gint ____lambda55__gcompare_func (gconstpointer a,
                                  gconstpointer b);
static void ___lambda56_ (GFile* folder);
static void ____lambda56__gfunc (gconstpointer data,
                          gpointer self);
static void __lambda110_ (FilesAbstractDirectoryView* self,
                   GObject* obj,
                   GAsyncResult* res);
static void ___lambda110__gasync_ready_callback (GObject* source_object,
                                          GAsyncResult* res,
                                          gpointer self);
VALA_EXTERN void files_mime_actions_open_multiple_gof_files_request (GList* gofs_to_open,
                                                         GtkWidget* parent,
                                                         GAppInfo* app);
static gboolean __lambda68_ (FilesAbstractDirectoryView* self);
static gboolean ___lambda68__gsource_func (gpointer self);
VALA_EXTERN gint files_view_slot_get_displayed_files_count (FilesViewSlot* self);
static gboolean __lambda69_ (FilesAbstractDirectoryView* self);
static GtkTreePath* _vala_GtkTreePath_copy (GtkTreePath* self);
static gboolean ___lambda69__gsource_func (gpointer self);
static gboolean __lambda70_ (FilesAbstractDirectoryView* self);
static gboolean ___lambda70__gsource_func (gpointer self);
static gboolean _files_abstract_directory_view_on_drag_timeout_button_release_gtk_widget_button_release_event (GtkWidget* _sender,
                                                                                                        GdkEventButton* event,
                                                                                                        gpointer self);
static gboolean _files_abstract_directory_view_on_drag_timeout_motion_notify_gtk_widget_motion_notify_event (GtkWidget* _sender,
                                                                                                      GdkEventMotion* event,
                                                                                                      gpointer self);
static Block22Data* block22_data_ref (Block22Data* _data22_);
static void block22_data_unref (void * _userdata_);
static gboolean __lambda120_ (Block22Data* _data22_);
static void files_abstract_directory_view_scroll_if_near_edge (FilesAbstractDirectoryView* self,
                                                        gint pos,
                                                        gint dim,
                                                        gint threshold,
                                                        GtkAdjustment* adj);
static gboolean ___lambda120__gsource_func (gpointer self);
static Block23Data* block23_data_ref (Block23Data* _data23_);
static void block23_data_unref (void * _userdata_);
static void ____lambda53_ (Block23Data* _data23_,
                    FilesFile* file);
static void _____lambda53__gfunc (gconstpointer data,
                           gpointer self);
VALA_EXTERN void files_abstract_directory_view_on_view_items_activated (FilesAbstractDirectoryView* self);
static gboolean files_abstract_directory_view_real_on_view_key_press_event (FilesAbstractDirectoryView* self,
                                                                     GdkEventKey* event);
static void files_abstract_directory_view_cancel_hover (FilesAbstractDirectoryView* self);
VALA_EXTERN guint key_utils_map_key (GdkEventKey* event,
                         GdkModifierType* consumed_mods);
static gboolean __lambda67_ (FilesAbstractDirectoryView* self);
static gboolean ___lambda67__gsource_func (gpointer self);
VALA_EXTERN gboolean files_abstract_directory_view_get_singleclick_select (FilesAbstractDirectoryView* self);
static gboolean files_abstract_directory_view_real_on_scroll_event (FilesAbstractDirectoryView* self,
                                                             GdkEventScroll* event);
VALA_EXTERN GType files_abstract_editable_label_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesAbstractEditableLabel, g_object_unref)
VALA_EXTERN gchar* files_abstract_editable_label_get_chars (FilesAbstractEditableLabel* self,
                                                gint start_pos,
                                                gint end_pos);
static GtkTreeIter* _vala_GtkTreeIter_copy (GtkTreeIter* self);
VALA_EXTERN void files_abstract_editable_label_select_region (FilesAbstractEditableLabel* self,
                                                  gint start_pos,
                                                  gint end_pos);
VALA_EXTERN void files_abstract_directory_view_set_is_frozen (FilesAbstractDirectoryView* self,
                                                  gboolean value);
VALA_EXTERN void files_abstract_directory_view_set_renaming (FilesAbstractDirectoryView* self,
                                                 gboolean value);
VALA_EXTERN void files_abstract_directory_view_set_file_display_name (FilesAbstractDirectoryView* self,
                                                          GFile* old_location,
                                                          const gchar* new_name,
                                                          GCancellable* cancellable,
                                                          GAsyncReadyCallback _callback_,
                                                          gpointer _user_data_);
VALA_EXTERN GFile* files_abstract_directory_view_set_file_display_name_finish (FilesAbstractDirectoryView* self,
                                                                   GAsyncResult* _res_,
                                                                   GError** error);
static void ____lambda72_ (FilesAbstractDirectoryView* self,
                    GObject* obj,
                    GAsyncResult* res);
static void _____lambda72__gasync_ready_callback (GObject* source_object,
                                           GAsyncResult* res,
                                           gpointer self);
static void files_abstract_directory_view_set_file_display_name_data_free (gpointer _data);
static gboolean files_abstract_directory_view_set_file_display_name_co (FilesAbstractDirectoryViewSetFileDisplayNameData* _data_);
static void files_abstract_directory_view_after_renamed_file_added (FilesAbstractDirectoryView* self,
                                                             FilesFile* new_file);
static void _files_abstract_directory_view_after_renamed_file_added_files_directory_file_added (FilesDirectory* _sender,
                                                                                         FilesFile* file,
                                                                                         gpointer self);
static void files_abstract_directory_view_set_file_display_name_ready (GObject* source_object,
                                                                GAsyncResult* _res_,
                                                                gpointer _user_data_);
static gboolean files_abstract_directory_view_real_on_view_draw (FilesAbstractDirectoryView* self,
                                                          cairo_t* cr);
VALA_EXTERN gchar* files_view_slot_get_empty_message (FilesViewSlot* self);
static PangoRectangle* _pango_rectangle_dup (PangoRectangle* self);
static gboolean files_abstract_directory_view_real_handle_primary_button_click (FilesAbstractDirectoryView* self,
                                                                         GdkEventButton* event,
                                                                         GtkTreePath* path);
static gboolean files_abstract_directory_view_real_handle_secondary_button_click (FilesAbstractDirectoryView* self,
                                                                           GdkEventButton* event);
VALA_EXTERN void files_abstract_directory_view_block_drag_and_drop (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_unblock_drag_and_drop (FilesAbstractDirectoryView* self);
static gboolean files_abstract_directory_view_real_on_view_button_press_event (FilesAbstractDirectoryView* self,
                                                                        GdkEventButton* event);
VALA_EXTERN void files_text_renderer_end_editing (FilesTextRenderer* self,
                                      gboolean cancel);
static gboolean files_abstract_directory_view_real_on_view_button_release_event (FilesAbstractDirectoryView* self,
                                                                          GdkEventButton* event);
static Block24Data* block24_data_ref (Block24Data* _data24_);
static void block24_data_unref (void * _userdata_);
static gboolean ____lambda122_ (Block24Data* _data24_);
static gboolean _____lambda122__gsource_func (gpointer self);
static gboolean _____lambda123_ (FilesAbstractDirectoryView* self);
static gboolean ______lambda123__gsource_func (gpointer self);
static gboolean ______lambda124_ (FilesAbstractDirectoryView* self);
static gboolean _______lambda124__gsource_func (gpointer self);
static void files_abstract_directory_view_real_change_zoom_level (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_icon_renderer_set_zoom_level (FilesIconRenderer* self,
                                         FilesZoomLevel value);
VALA_EXTERN void files_text_renderer_set_zoom_level (FilesTextRenderer* self,
                                         FilesZoomLevel value);
static Block25Data* block25_data_ref (Block25Data* _data25_);
static void block25_data_unref (void * _userdata_);
static gboolean __lambda57_ (Block25Data* _data25_);
static gboolean ___lambda57__gsource_func (gpointer self);
static Block26Data* block26_data_ref (Block26Data* _data26_);
static void block26_data_unref (void * _userdata_);
static void ___lambda118_ (Block26Data* _data26_,
                    GObject* obj,
                    GAsyncResult* res);
static void ____lambda118__gasync_ready_callback (GObject* source_object,
                                           GAsyncResult* res,
                                           gpointer self);
static gboolean files_abstract_directory_view_real_expand_collapse (FilesAbstractDirectoryView* self,
                                                             GtkTreePath* path);
static gboolean files_abstract_directory_view_real_handle_default_button_click (FilesAbstractDirectoryView* self,
                                                                         GdkEventButton* event);
static gboolean files_abstract_directory_view_real_get_next_visible_iter (FilesAbstractDirectoryView* self,
                                                                   GtkTreeIter* iter,
                                                                   gboolean recurse);
static void files_abstract_directory_view_real_cancel (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_close (FilesAbstractDirectoryView* self);
static void __vala_GtkTreePath_free0_ (gpointer var);
static inline void _g_list_free___vala_GtkTreePath_free0_ (GList* self);
static GtkTreeRowReference* _vala_GtkTreeRowReference_copy (GtkTreeRowReference* self);
static void _vala_GtkTreeRowReference_free (GtkTreeRowReference* self);
static void __vala_GtkTreeRowReference_free0_ (gpointer var);
static inline void _g_list_free___vala_GtkTreeRowReference_free0_ (GList* self);
VALA_EXTERN void files_abstract_directory_view_unselect_others (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_real_highlight_path (FilesAbstractDirectoryView* self,
                                                        GtkTreePath* path);
static GtkTreePath* files_abstract_directory_view_real_up (FilesAbstractDirectoryView* self,
                                                    GtkTreePath* path);
static GtkTreePath* files_abstract_directory_view_real_down (FilesAbstractDirectoryView* self,
                                                      GtkTreePath* path);
static GList* files_abstract_directory_view_real_get_selected_paths (FilesAbstractDirectoryView* self);
static GtkTreePath* files_abstract_directory_view_real_get_path_at_pos (FilesAbstractDirectoryView* self,
                                                                 gint x,
                                                                 gint win);
static GtkTreePath* files_abstract_directory_view_real_get_path_at_cursor (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_real_tree_select_all (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_real_tree_unselect_all (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_real_tree_unselect_others (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_real_select_path (FilesAbstractDirectoryView* self,
                                                     GtkTreePath* path,
                                                     gboolean cursor_follows);
static void files_abstract_directory_view_real_unselect_path (FilesAbstractDirectoryView* self,
                                                       GtkTreePath* path);
static gboolean files_abstract_directory_view_real_path_is_selected (FilesAbstractDirectoryView* self,
                                                              GtkTreePath* path);
static gboolean files_abstract_directory_view_real_get_visible_range (FilesAbstractDirectoryView* self,
                                                               GtkTreePath** start_path,
                                                               GtkTreePath** end_path);
static void files_abstract_directory_view_real_set_cursor (FilesAbstractDirectoryView* self,
                                                    GtkTreePath* path,
                                                    gboolean start_editing,
                                                    gboolean select,
                                                    gboolean scroll_to_top);
static gboolean files_abstract_directory_view_real_move_cursor (FilesAbstractDirectoryView* self,
                                                         guint keyval,
                                                         gboolean only_shift_pressed,
                                                         gboolean control_pressed);
static gboolean files_abstract_directory_view_real_will_handle_button_press (FilesAbstractDirectoryView* self,
                                                                      gboolean no_mods,
                                                                      gboolean only_control_pressed,
                                                                      gboolean only_shift_pressed);
VALA_EXTERN gboolean files_abstract_directory_view_is_on_icon (FilesAbstractDirectoryView* self,
                                                   gint x,
                                                   gint y,
                                                   gboolean* on_helper);
static gboolean files_abstract_directory_view_real_handle_multi_select (FilesAbstractDirectoryView* self,
                                                                 GtkTreePath* path);
static GtkWidget* files_abstract_directory_view_real_create_view (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_real_set_up_zoom_level (FilesAbstractDirectoryView* self);
static FilesZoomLevel files_abstract_directory_view_real_get_normal_zoom_level (FilesAbstractDirectoryView* self);
static gboolean files_abstract_directory_view_real_view_has_focus (FilesAbstractDirectoryView* self);
static guint files_abstract_directory_view_real_get_selected_files_from_model (FilesAbstractDirectoryView* self,
                                                                        GList** selected_files);
static guint files_abstract_directory_view_real_get_event_position_info (FilesAbstractDirectoryView* self,
                                                                  GdkEventButton* event,
                                                                  GtkTreePath** path,
                                                                  gboolean rubberband);
static void files_abstract_directory_view_real_scroll_to_cell (FilesAbstractDirectoryView* self,
                                                        GtkTreePath* path,
                                                        gboolean scroll_to_top);
static void files_abstract_directory_view_real_set_cursor_on_cell (FilesAbstractDirectoryView* self,
                                                            GtkTreePath* path,
                                                            GtkCellRenderer* renderer,
                                                            gboolean start_editing,
                                                            gboolean scroll_to_top);
static void files_abstract_directory_view_real_freeze_tree (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_real_thaw_tree (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_real_freeze_child_notify (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_real_thaw_child_notify (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_real_connect_tree_signals (FilesAbstractDirectoryView* self);
static void files_abstract_directory_view_real_disconnect_tree_signals (FilesAbstractDirectoryView* self);
VALA_EXTERN void files_abstract_directory_view_set_singleclick_select (FilesAbstractDirectoryView* self,
                                                           gboolean value);
VALA_EXTERN void files_abstract_directory_view_set_tree_frozen (FilesAbstractDirectoryView* self,
                                                    gboolean value);
static void g_cclosure_user_marshal_VOID__OBJECT_ENUM_BOOLEAN (GClosure * closure,
                                                        GValue * return_value,
                                                        guint n_param_values,
                                                        const GValue * param_values,
                                                        gpointer invocation_hint,
                                                        gpointer marshal_data);
static GObject * files_abstract_directory_view_sort_sub_menu_item_constructor (GType type,
                                                                        guint n_construct_properties,
                                                                        GObjectConstructParam * construct_properties);
static GVariant* _variant_new9 (const gchar* value);
static GVariant* _variant_new10 (const gchar* value);
static GVariant* _variant_new11 (const gchar* value);
static GVariant* _variant_new12 (const gchar* value);
static GType files_abstract_directory_view_sort_sub_menu_item_get_type_once (void);
static GObject * files_abstract_directory_view_new_sub_menu_item_constructor (GType type,
                                                                       guint n_construct_properties,
                                                                       GObjectConstructParam * construct_properties);
static GVariant* _variant_new13 (const gchar* value);
static GVariant* _variant_new14 (const gchar* value);
static GType files_abstract_directory_view_new_sub_menu_item_get_type_once (void);
static void files_abstract_directory_view_finalize (GObject * obj);
static GType files_abstract_directory_view_get_type_once (void);
static void _vala_files_abstract_directory_view_get_property (GObject * object,
                                                       guint property_id,
                                                       GValue * value,
                                                       GParamSpec * pspec);
static void _vala_files_abstract_directory_view_set_property (GObject * object,
                                                       guint property_id,
                                                       const GValue * value,
                                                       GParamSpec * pspec);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);
static gssize _vala_array_length (gpointer array);

static const GtkTargetEntry FILES_ABSTRACT_DIRECTORY_VIEW_DRAG_TARGETS[2] = {{"text/plain", (guint) GTK_TARGET_SAME_APP, (guint) FILES_TARGET_TYPE_STRING}, {"text/uri-list", (guint) GTK_TARGET_SAME_APP, (guint) FILES_TARGET_TYPE_TEXT_URI_LIST}};
static const GtkTargetEntry FILES_ABSTRACT_DIRECTORY_VIEW_DROP_TARGETS[4] = {{"text/uri-list", (guint) GTK_TARGET_SAME_APP, (guint) FILES_TARGET_TYPE_TEXT_URI_LIST}, {"text/uri-list", (guint) GTK_TARGET_OTHER_APP, (guint) FILES_TARGET_TYPE_TEXT_URI_LIST}, {"XdndDirectSave0", (guint) GTK_TARGET_OTHER_APP, (guint) FILES_TARGET_TYPE_XDND_DIRECT_SAVE0}, {"_NETSCAPE_URL", (guint) GTK_TARGET_OTHER_APP, (guint) FILES_TARGET_TYPE_NETSCAPE_URL}};
static const GActionEntry FILES_ABSTRACT_DIRECTORY_VIEW_SELECTION_ENTRIES[12] = {{"open", _files_abstract_directory_view_on_selection_action_open_executable_gsimple_action_activate_callback}, {"open-with-app", _files_abstract_directory_view_on_selection_action_open_with_app_gsimple_action_activate_callback, "u"}, {"open-with-default", _files_abstract_directory_view_on_selection_action_open_with_default_gsimple_action_activate_callback}, {"open-with-other-app", _files_abstract_directory_view_on_selection_action_open_with_other_app_gsimple_action_activate_callback}, {"rename", _files_abstract_directory_view_on_selection_action_rename_gsimple_action_activate_callback}, {"view-in-location", _files_abstract_directory_view_on_selection_action_view_in_location_gsimple_action_activate_callback}, {"forget", _files_abstract_directory_view_on_selection_action_forget_gsimple_action_activate_callback}, {"cut", _files_abstract_directory_view_on_selection_action_cut_gsimple_action_activate_callback}, {"trash", _files_abstract_directory_view_on_selection_action_trash_gsimple_action_activate_callback}, {"delete", _files_abstract_directory_view_on_selection_action_delete_gsimple_action_activate_callback}, {"restore", _files_abstract_directory_view_on_selection_action_restore_gsimple_action_activate_callback}, {"invert-selection", _files_abstract_directory_view_invert_selection_gsimple_action_activate_callback}};
static const GActionEntry FILES_ABSTRACT_DIRECTORY_VIEW_BACKGROUND_ENTRIES[8] = {{"new", _files_abstract_directory_view_on_background_action_new_gsimple_action_activate_callback, "s"}, {"create-from", _files_abstract_directory_view_on_background_action_create_from_gsimple_action_activate_callback, "s"}, {"sort-by", _files_abstract_directory_view_on_background_action_sort_by_changed_gsimple_action_activate_callback, "s", "'name'"}, {"reverse", _files_abstract_directory_view_on_background_action_reverse_changed_gsimple_action_activate_callback, NULL, "false"}, {"folders-first", _files_abstract_directory_view_on_background_action_folders_first_changed_gsimple_action_activate_callback, NULL, "true"}, {"show-hidden", NULL, NULL, "false", _files_abstract_directory_view_change_state_show_hidden_gsimple_action_change_state_callback}, {"show-remote-thumbnails", NULL, NULL, "true", _files_abstract_directory_view_change_state_show_remote_thumbnails_gsimple_action_change_state_callback}, {"show-local-thumbnails", NULL, NULL, "true", _files_abstract_directory_view_change_state_show_local_thumbnails_gsimple_action_change_state_callback}};
static const GActionEntry FILES_ABSTRACT_DIRECTORY_VIEW_COMMON_ENTRIES[8] = {{"copy", _files_abstract_directory_view_on_common_action_copy_gsimple_action_activate_callback}, {"paste-into", _files_abstract_directory_view_on_common_action_paste_into_gsimple_action_activate_callback}, {"paste", _files_abstract_directory_view_on_common_action_paste_gsimple_action_activate_callback}, {"open-in", _files_abstract_directory_view_on_common_action_open_in_gsimple_action_activate_callback, "s"}, {"bookmark", _files_abstract_directory_view_on_common_action_bookmark_gsimple_action_activate_callback}, {"properties", _files_abstract_directory_view_on_common_action_properties_gsimple_action_activate_callback}, {"copy-link", _files_abstract_directory_view_on_common_action_copy_link_gsimple_action_activate_callback}, {"select-all", _files_abstract_directory_view_toggle_select_all_gsimple_action_activate_callback}};

static inline gpointer
files_abstract_directory_view_get_instance_private (FilesAbstractDirectoryView* self)
{
	return G_STRUCT_MEMBER_P (self, FilesAbstractDirectoryView_private_offset);
}

static GType
files_abstract_directory_view_click_zone_get_type_once (void)
{
	static const GEnumValue values[] = {{FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_EXPANDER, "FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_EXPANDER", "expander"}, {FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_HELPER, "FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_HELPER", "helper"}, {FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_ICON, "FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_ICON", "icon"}, {FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_NAME, "FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_NAME", "name"}, {FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_BLANK_PATH, "FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_BLANK_PATH", "blank-path"}, {FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_BLANK_NO_PATH, "FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_BLANK_NO_PATH", "blank-no-path"}, {FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_INVALID, "FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_INVALID", "invalid"}, {0, NULL, NULL}};
	GType files_abstract_directory_view_click_zone_type_id;
	files_abstract_directory_view_click_zone_type_id = g_enum_register_static ("FilesAbstractDirectoryViewClickZone", values);
	return files_abstract_directory_view_click_zone_type_id;
}

GType
files_abstract_directory_view_click_zone_get_type (void)
{
	static volatile gsize files_abstract_directory_view_click_zone_type_id__once = 0;
	if (g_once_init_enter (&files_abstract_directory_view_click_zone_type_id__once)) {
		GType files_abstract_directory_view_click_zone_type_id;
		files_abstract_directory_view_click_zone_type_id = files_abstract_directory_view_click_zone_get_type_once ();
		g_once_init_leave (&files_abstract_directory_view_click_zone_type_id__once, files_abstract_directory_view_click_zone_type_id);
	}
	return files_abstract_directory_view_click_zone_type_id__once;
}

static void
_files_abstract_directory_view_on_selection_action_open_executable_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                     GVariant* parameter,
                                                                                                     gpointer self)
{
	files_abstract_directory_view_on_selection_action_open_executable ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_selection_action_open_with_app_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                   GVariant* parameter,
                                                                                                   gpointer self)
{
	files_abstract_directory_view_on_selection_action_open_with_app ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_selection_action_open_with_default_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                       GVariant* parameter,
                                                                                                       gpointer self)
{
	files_abstract_directory_view_on_selection_action_open_with_default ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_selection_action_open_with_other_app_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                         GVariant* parameter,
                                                                                                         gpointer self)
{
	files_abstract_directory_view_on_selection_action_open_with_other_app ((FilesAbstractDirectoryView*) self);
}

static void
_files_abstract_directory_view_on_selection_action_rename_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                            GVariant* parameter,
                                                                                            gpointer self)
{
	files_abstract_directory_view_on_selection_action_rename ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_selection_action_view_in_location_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                      GVariant* parameter,
                                                                                                      gpointer self)
{
	files_abstract_directory_view_on_selection_action_view_in_location ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_selection_action_forget_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                            GVariant* parameter,
                                                                                            gpointer self)
{
	files_abstract_directory_view_on_selection_action_forget ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_selection_action_cut_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                         GVariant* parameter,
                                                                                         gpointer self)
{
	files_abstract_directory_view_on_selection_action_cut ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_selection_action_trash_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                           GVariant* parameter,
                                                                                           gpointer self)
{
	files_abstract_directory_view_on_selection_action_trash ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_selection_action_delete_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                            GVariant* parameter,
                                                                                            gpointer self)
{
	files_abstract_directory_view_on_selection_action_delete ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_selection_action_restore_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                             GVariant* parameter,
                                                                                             gpointer self)
{
	files_abstract_directory_view_on_selection_action_restore ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_invert_selection_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                  GVariant* parameter,
                                                                                  gpointer self)
{
	files_abstract_directory_view_invert_selection ((FilesAbstractDirectoryView*) self);
}

static void
_files_abstract_directory_view_on_background_action_new_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                          GVariant* parameter,
                                                                                          gpointer self)
{
	files_abstract_directory_view_on_background_action_new ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_background_action_create_from_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                  GVariant* parameter,
                                                                                                  gpointer self)
{
	files_abstract_directory_view_on_background_action_create_from ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_background_action_sort_by_changed_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                      GVariant* parameter,
                                                                                                      gpointer self)
{
	files_abstract_directory_view_on_background_action_sort_by_changed ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_background_action_reverse_changed_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                      GVariant* parameter,
                                                                                                      gpointer self)
{
	files_abstract_directory_view_on_background_action_reverse_changed ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_background_action_folders_first_changed_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                                            GVariant* parameter,
                                                                                                            gpointer self)
{
	files_abstract_directory_view_on_background_action_folders_first_changed ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_change_state_show_hidden_gsimple_action_change_state_callback (GSimpleAction* action,
                                                                                              GVariant* value,
                                                                                              gpointer self)
{
	files_abstract_directory_view_change_state_show_hidden ((FilesAbstractDirectoryView*) self, action);
}

static void
_files_abstract_directory_view_change_state_show_remote_thumbnails_gsimple_action_change_state_callback (GSimpleAction* action,
                                                                                                         GVariant* value,
                                                                                                         gpointer self)
{
	files_abstract_directory_view_change_state_show_remote_thumbnails ((FilesAbstractDirectoryView*) self, action);
}

static void
_files_abstract_directory_view_change_state_show_local_thumbnails_gsimple_action_change_state_callback (GSimpleAction* action,
                                                                                                        GVariant* value,
                                                                                                        gpointer self)
{
	files_abstract_directory_view_change_state_show_local_thumbnails ((FilesAbstractDirectoryView*) self, action);
}

static void
_files_abstract_directory_view_on_common_action_copy_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                       GVariant* parameter,
                                                                                       gpointer self)
{
	files_abstract_directory_view_on_common_action_copy ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_common_action_paste_into_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                             GVariant* parameter,
                                                                                             gpointer self)
{
	files_abstract_directory_view_on_common_action_paste_into ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_common_action_paste_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                        GVariant* parameter,
                                                                                        gpointer self)
{
	files_abstract_directory_view_on_common_action_paste ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_common_action_open_in_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                          GVariant* parameter,
                                                                                          gpointer self)
{
	files_abstract_directory_view_on_common_action_open_in ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_common_action_bookmark_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                           GVariant* parameter,
                                                                                           gpointer self)
{
	files_abstract_directory_view_on_common_action_bookmark ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_common_action_properties_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                             GVariant* parameter,
                                                                                             gpointer self)
{
	files_abstract_directory_view_on_common_action_properties ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_on_common_action_copy_link_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                            GVariant* parameter,
                                                                                            gpointer self)
{
	files_abstract_directory_view_on_common_action_copy_link ((FilesAbstractDirectoryView*) self, action, parameter);
}

static void
_files_abstract_directory_view_toggle_select_all_gsimple_action_activate_callback (GSimpleAction* action,
                                                                                   GVariant* parameter,
                                                                                   gpointer self)
{
	files_abstract_directory_view_toggle_select_all ((FilesAbstractDirectoryView*) self);
}

static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}

static inline void
_g_list_free__g_object_unref0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_object_unref0_);
}

static void
_vala_GtkTreePath_free (GtkTreePath* self)
{
	g_boxed_free (gtk_tree_path_get_type (), self);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static void
__lambda113_ (FilesAbstractDirectoryView* self,
              guint req)
{
	if (req == ((guint) self->priv->thumbnail_request)) {
		self->priv->thumbnail_request = -1;
	}
	files_abstract_directory_view_draw_when_idle (self);
}

static void
___lambda113__files_thumbnailer_finished (FilesThumbnailer* _sender,
                                          guint request,
                                          gpointer self)
{
	__lambda113_ ((FilesAbstractDirectoryView*) self, request);
}

static gboolean
_files_abstract_directory_view_on_motion_notify_event_gtk_widget_motion_notify_event (GtkWidget* _sender,
                                                                                      GdkEventMotion* event,
                                                                                      gpointer self)
{
	gboolean result;
	result = files_abstract_directory_view_on_motion_notify_event ((FilesAbstractDirectoryView*) self, event);
	return result;
}

static gboolean
_files_abstract_directory_view_on_leave_notify_event_gtk_widget_leave_notify_event (GtkWidget* _sender,
                                                                                    GdkEventCrossing* event,
                                                                                    gpointer self)
{
	gboolean result;
	result = files_abstract_directory_view_on_leave_notify_event ((FilesAbstractDirectoryView*) self, event);
	return result;
}

static gboolean
_files_abstract_directory_view_on_view_key_press_event_gtk_widget_key_press_event (GtkWidget* _sender,
                                                                                   GdkEventKey* event,
                                                                                   gpointer self)
{
	gboolean result;
	result = files_abstract_directory_view_on_view_key_press_event ((FilesAbstractDirectoryView*) self, event);
	return result;
}

static gboolean
_files_abstract_directory_view_on_view_button_press_event_gtk_widget_button_press_event (GtkWidget* _sender,
                                                                                         GdkEventButton* event,
                                                                                         gpointer self)
{
	gboolean result;
	result = files_abstract_directory_view_on_view_button_press_event ((FilesAbstractDirectoryView*) self, event);
	return result;
}

static gboolean
_files_abstract_directory_view_on_view_button_release_event_gtk_widget_button_release_event (GtkWidget* _sender,
                                                                                             GdkEventButton* event,
                                                                                             gpointer self)
{
	gboolean result;
	result = files_abstract_directory_view_on_view_button_release_event ((FilesAbstractDirectoryView*) self, event);
	return result;
}

static gboolean
_files_abstract_directory_view_on_view_draw_gtk_widget_draw (GtkWidget* _sender,
                                                             cairo_t* cr,
                                                             gpointer self)
{
	gboolean result;
	result = files_abstract_directory_view_on_view_draw ((FilesAbstractDirectoryView*) self, cr);
	return result;
}

FilesAbstractDirectoryView*
files_abstract_directory_view_construct (GType object_type,
                                         FilesViewSlot* _slot)
{
	FilesAbstractDirectoryView * self = NULL;
	FilesViewWindow* _tmp0_;
	FilesViewWindow* _tmp1_;
	GdkDisplay* _tmp2_;
	GdkCursor* _tmp3_;
	GdkDisplay* _tmp4_;
	GdkCursor* _tmp5_;
	GdkDisplay* _tmp6_;
	GdkCursor* _tmp7_;
	FilesApplication* app = NULL;
	GApplication* _tmp8_;
	FilesApplication* _tmp9_;
	FilesApplication* _tmp10_;
	FilesClipboardManager* _tmp11_;
	FilesApplication* _tmp12_;
	GtkRecentManager* _tmp13_;
	FilesApplication* _tmp14_;
	gchar* _tmp15_;
	gchar** _tmp16_;
	gchar** _tmp17_;
	gint _tmp17__length1;
	FilesApplication* _tmp18_;
	gchar* _tmp19_;
	gchar** _tmp20_;
	gchar** _tmp21_;
	gint _tmp21__length1;
	FilesThumbnailer* _tmp22_;
	FilesThumbnailer* _tmp23_;
	FilesListModel* _tmp24_;
	GSettings* _tmp25_;
	GSettings* _tmp26_;
	GtkWidget* _tmp27_;
	GtkWidget* _tmp28_;
	FilesViewSlot* _tmp38_;
	FilesDirectory* _tmp39_;
	FilesDirectory* _tmp40_;
	g_return_val_if_fail (_slot != NULL, NULL);
	self = (FilesAbstractDirectoryView*) g_object_new (object_type, NULL);
	self->slot = _slot;
	_tmp0_ = files_view_slot_get_window (_slot);
	_tmp1_ = _tmp0_;
	self->window = _tmp1_;
	_tmp2_ = gdk_display_get_default ();
	_tmp3_ = gdk_cursor_new_from_name (_tmp2_, "text");
	_g_object_unref0 (self->priv->editable_cursor);
	self->priv->editable_cursor = _tmp3_;
	_tmp4_ = gdk_display_get_default ();
	_tmp5_ = gdk_cursor_new_from_name (_tmp4_, "pointer");
	_g_object_unref0 (self->priv->activatable_cursor);
	self->priv->activatable_cursor = _tmp5_;
	_tmp6_ = gdk_display_get_default ();
	_tmp7_ = gdk_cursor_new_from_name (_tmp6_, "default");
	_g_object_unref0 (self->priv->selectable_cursor);
	self->priv->selectable_cursor = _tmp7_;
	_tmp8_ = g_application_get_default ();
	_tmp9_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp8_, FILES_TYPE_APPLICATION, FilesApplication));
	app = _tmp9_;
	_tmp10_ = app;
	_tmp11_ = files_application_get_clipboard_manager (_tmp10_);
	self->priv->clipboard = _tmp11_;
	_tmp12_ = app;
	_tmp13_ = files_application_get_recent_manager (_tmp12_);
	self->recent = _tmp13_;
	_tmp14_ = app;
	_tmp15_ = g_strdup ("<Ctrl>A");
	_tmp16_ = g_new0 (gchar*, 1 + 1);
	_tmp16_[0] = _tmp15_;
	_tmp17_ = _tmp16_;
	_tmp17__length1 = 1;
	gtk_application_set_accels_for_action ((GtkApplication*) _tmp14_, "common.select-all", _tmp17_);
	_tmp17_ = (_vala_array_free (_tmp17_, _tmp17__length1, (GDestroyNotify) g_free), NULL);
	_tmp18_ = app;
	_tmp19_ = g_strdup ("<Shift><Ctrl>A");
	_tmp20_ = g_new0 (gchar*, 1 + 1);
	_tmp20_[0] = _tmp19_;
	_tmp21_ = _tmp20_;
	_tmp21__length1 = 1;
	gtk_application_set_accels_for_action ((GtkApplication*) _tmp18_, "selection.invert-selection", _tmp21_);
	_tmp21_ = (_vala_array_free (_tmp21_, _tmp21__length1, (GDestroyNotify) g_free), NULL);
	_tmp22_ = files_thumbnailer_get ();
	_g_object_unref0 (self->priv->thumbnailer);
	self->priv->thumbnailer = _tmp22_;
	_tmp23_ = self->priv->thumbnailer;
	g_signal_connect_object (_tmp23_, "finished", (GCallback) ___lambda113__files_thumbnailer_finished, self, 0);
	_tmp24_ = files_list_model_new ();
	_g_object_unref0 (self->model);
	self->model = _tmp24_;
	_tmp25_ = files_app_settings;
	g_settings_bind (_tmp25_, "show-remote-thumbnails", (GObject*) self, "show_remote_thumbnails", G_SETTINGS_BIND_GET);
	_tmp26_ = files_app_settings;
	g_settings_bind (_tmp26_, "show-local-thumbnails", (GObject*) self, "show_local_thumbnails", G_SETTINGS_BIND_GET);
	files_abstract_directory_view_set_up__menu_actions (self);
	files_abstract_directory_view_set_up_directory_view (self);
	_tmp27_ = files_abstract_directory_view_create_view (self);
	_g_object_unref0 (self->priv->view);
	self->priv->view = _tmp27_;
	_tmp28_ = self->priv->view;
	if (_tmp28_ != NULL) {
		GtkWidget* _tmp29_;
		GtkWidget* _tmp30_;
		GtkWidget* _tmp31_;
		GtkWidget* _tmp32_;
		GtkWidget* _tmp33_;
		GtkWidget* _tmp34_;
		GtkWidget* _tmp35_;
		GtkWidget* _tmp36_;
		GtkWidget* _tmp37_;
		_tmp29_ = self->priv->view;
		gtk_container_add ((GtkContainer*) self, _tmp29_);
		gtk_widget_show_all ((GtkWidget*) self);
		_tmp30_ = self->priv->view;
		files_abstract_directory_view_connect_drag_drop_signals (self, _tmp30_);
		_tmp31_ = self->priv->view;
		gtk_widget_add_events (_tmp31_, (gint) ((GDK_POINTER_MOTION_MASK | GDK_ENTER_NOTIFY_MASK) | GDK_LEAVE_NOTIFY_MASK));
		_tmp32_ = self->priv->view;
		g_signal_connect_object (_tmp32_, "motion-notify-event", (GCallback) _files_abstract_directory_view_on_motion_notify_event_gtk_widget_motion_notify_event, self, 0);
		_tmp33_ = self->priv->view;
		g_signal_connect_object (_tmp33_, "leave-notify-event", (GCallback) _files_abstract_directory_view_on_leave_notify_event_gtk_widget_leave_notify_event, self, 0);
		_tmp34_ = self->priv->view;
		g_signal_connect_object (_tmp34_, "key-press-event", (GCallback) _files_abstract_directory_view_on_view_key_press_event_gtk_widget_key_press_event, self, 0);
		_tmp35_ = self->priv->view;
		g_signal_connect_object (_tmp35_, "button-press-event", (GCallback) _files_abstract_directory_view_on_view_button_press_event_gtk_widget_button_press_event, self, 0);
		_tmp36_ = self->priv->view;
		g_signal_connect_object (_tmp36_, "button-release-event", (GCallback) _files_abstract_directory_view_on_view_button_release_event_gtk_widget_button_release_event, self, 0);
		_tmp37_ = self->priv->view;
		g_signal_connect_object (_tmp37_, "draw", (GCallback) _files_abstract_directory_view_on_view_draw_gtk_widget_draw, self, 0);
	}
	files_abstract_directory_view_freeze_tree (self);
	files_abstract_directory_view_set_up_zoom_level (self);
	_tmp38_ = self->slot;
	_tmp39_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp38_);
	_tmp40_ = _tmp39_;
	files_abstract_directory_view_connect_directory_handlers (self, _tmp40_);
	_g_object_unref0 (app);
	return self;
}

static void
_files_abstract_directory_view_on_name_edited_gtk_cell_renderer_text_edited (GtkCellRendererText* _sender,
                                                                             const gchar* path,
                                                                             const gchar* new_text,
                                                                             gpointer self)
{
	files_abstract_directory_view_on_name_edited ((FilesAbstractDirectoryView*) self, path, new_text);
}

static void
_files_abstract_directory_view_on_name_editing_canceled_gtk_cell_renderer_editing_canceled (GtkCellRenderer* _sender,
                                                                                            gpointer self)
{
	files_abstract_directory_view_on_name_editing_canceled ((FilesAbstractDirectoryView*) self);
}

static void
_files_abstract_directory_view_on_name_editing_started_gtk_cell_renderer_editing_started (GtkCellRenderer* _sender,
                                                                                          GtkCellEditable* editable,
                                                                                          const gchar* path,
                                                                                          gpointer self)
{
	files_abstract_directory_view_on_name_editing_started ((FilesAbstractDirectoryView*) self, editable, path);
}

static void
files_abstract_directory_view_real_set_up_name_renderer (FilesAbstractDirectoryView* self)
{
	FilesTextRenderer* _tmp0_;
	FilesTextRenderer* _tmp1_;
	FilesTextRenderer* _tmp2_;
	FilesTextRenderer* _tmp3_;
	_tmp0_ = self->name_renderer;
	g_object_set ((GtkCellRendererText*) _tmp0_, "editable", FALSE, NULL);
	_tmp1_ = self->name_renderer;
	g_signal_connect_object ((GtkCellRendererText*) _tmp1_, "edited", (GCallback) _files_abstract_directory_view_on_name_edited_gtk_cell_renderer_text_edited, self, 0);
	_tmp2_ = self->name_renderer;
	g_signal_connect_object ((GtkCellRenderer*) _tmp2_, "editing-canceled", (GCallback) _files_abstract_directory_view_on_name_editing_canceled_gtk_cell_renderer_editing_canceled, self, 0);
	_tmp3_ = self->name_renderer;
	g_signal_connect_object ((GtkCellRenderer*) _tmp3_, "editing-started", (GCallback) _files_abstract_directory_view_on_name_editing_started_gtk_cell_renderer_editing_started, self, 0);
}

void
files_abstract_directory_view_set_up_name_renderer (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->set_up_name_renderer) {
		_klass_->set_up_name_renderer (self);
	}
}

static gboolean
_files_abstract_directory_view_on_popup_menu_gtk_widget_popup_menu (GtkWidget* _sender,
                                                                    gpointer self)
{
	gboolean result;
	result = files_abstract_directory_view_on_popup_menu ((FilesAbstractDirectoryView*) self);
	return result;
}

static void
_files_abstract_directory_view_on_clipboard_changed_files_clipboard_manager_changed (FilesClipboardManager* _sender,
                                                                                     gpointer self)
{
	files_abstract_directory_view_on_clipboard_changed ((FilesAbstractDirectoryView*) self);
}

static void
__lambda114_ (FilesAbstractDirectoryView* self)
{
	FilesClipboardManager* _tmp0_;
	guint _tmp1_;
	_tmp0_ = self->priv->clipboard;
	g_signal_parse_name ("changed", FILES_TYPE_CLIPBOARD_MANAGER, &_tmp1_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp0_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _files_abstract_directory_view_on_clipboard_changed_files_clipboard_manager_changed, self);
}

static void
___lambda114__gtk_widget_unrealize (GtkWidget* _sender,
                                    gpointer self)
{
	__lambda114_ ((FilesAbstractDirectoryView*) self);
}

static void
__lambda115_ (FilesAbstractDirectoryView* self)
{
	FilesClipboardManager* _tmp0_;
	_tmp0_ = self->priv->clipboard;
	g_signal_connect_object (_tmp0_, "changed", (GCallback) _files_abstract_directory_view_on_clipboard_changed_files_clipboard_manager_changed, self, 0);
	files_abstract_directory_view_on_clipboard_changed (self);
}

static void
___lambda115__gtk_widget_realize (GtkWidget* _sender,
                                  gpointer self)
{
	__lambda115_ ((FilesAbstractDirectoryView*) self);
}

static gboolean
_files_abstract_directory_view_on_scroll_event_gtk_widget_scroll_event (GtkWidget* _sender,
                                                                        GdkEventScroll* event,
                                                                        gpointer self)
{
	gboolean result;
	result = files_abstract_directory_view_on_scroll_event ((FilesAbstractDirectoryView*) self, event);
	return result;
}

static void
__lambda116_ (FilesAbstractDirectoryView* self)
{
	files_abstract_directory_view_schedule_thumbnail_color_tag_timeout (self);
}

static void
___lambda116__gtk_adjustment_value_changed (GtkAdjustment* _sender,
                                            gpointer self)
{
	__lambda116_ ((FilesAbstractDirectoryView*) self);
}

static void
__lambda117_ (FilesAbstractDirectoryView* self)
{
	GtkWidget* vscroll_bar = NULL;
	GtkWidget* _tmp0_;
	GtkWidget* _tmp1_;
	gboolean _tmp2_;
	_tmp0_ = gtk_scrolled_window_get_vscrollbar ((GtkScrolledWindow*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	vscroll_bar = _tmp1_;
	_tmp2_ = self->priv->_renaming;
	gtk_widget_set_visible (vscroll_bar, !_tmp2_);
	_g_object_unref0 (vscroll_bar);
}

static void
___lambda117__g_object_notify (GObject* _sender,
                               GParamSpec* pspec,
                               gpointer self)
{
	__lambda117_ ((FilesAbstractDirectoryView*) self);
}

static void
_files_abstract_directory_view_on_show_hidden_files_changed_g_object_notify (GObject* _sender,
                                                                             GParamSpec* pspec,
                                                                             gpointer self)
{
	files_abstract_directory_view_on_show_hidden_files_changed ((FilesAbstractDirectoryView*) self, _sender, pspec);
}

static void
_files_abstract_directory_view_on_show_remote_thumbnails_changed_g_object_notify (GObject* _sender,
                                                                                  GParamSpec* pspec,
                                                                                  gpointer self)
{
	files_abstract_directory_view_on_show_remote_thumbnails_changed ((FilesAbstractDirectoryView*) self, _sender, pspec);
}

static void
_files_abstract_directory_view_on_show_local_thumbnails_changed_g_object_notify (GObject* _sender,
                                                                                 GParamSpec* pspec,
                                                                                 gpointer self)
{
	files_abstract_directory_view_on_show_local_thumbnails_changed ((FilesAbstractDirectoryView*) self, _sender, pspec);
}

static void
_files_abstract_directory_view_on_sort_directories_first_changed_g_object_notify (GObject* _sender,
                                                                                  GParamSpec* pspec,
                                                                                  gpointer self)
{
	files_abstract_directory_view_on_sort_directories_first_changed ((FilesAbstractDirectoryView*) self, _sender, pspec);
}

static void
_files_abstract_directory_view_on_row_deleted_gtk_tree_model_row_deleted (GtkTreeModel* _sender,
                                                                          GtkTreePath* path,
                                                                          gpointer self)
{
	files_abstract_directory_view_on_row_deleted ((FilesAbstractDirectoryView*) self, path);
}

static void
_files_abstract_directory_view_on_sort_column_changed_gtk_tree_sortable_sort_column_changed (GtkTreeSortable* _sender,
                                                                                             gpointer self)
{
	files_abstract_directory_view_on_sort_column_changed ((FilesAbstractDirectoryView*) self);
}

static void
files_abstract_directory_view_set_up_directory_view (FilesAbstractDirectoryView* self)
{
	GtkAdjustment* _tmp0_;
	FilesPreferences* prefs = NULL;
	FilesPreferences* _tmp1_;
	FilesListModel* _tmp2_;
	FilesPreferences* _tmp3_;
	FilesPreferences* _tmp4_;
	gboolean _tmp5_;
	gboolean _tmp6_;
	FilesListModel* _tmp7_;
	FilesListModel* _tmp8_;
	g_return_if_fail (self != NULL);
	gtk_scrolled_window_set_policy ((GtkScrolledWindow*) self, GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type ((GtkScrolledWindow*) self, GTK_SHADOW_NONE);
	g_signal_connect_object ((GtkWidget*) self, "popup-menu", (GCallback) _files_abstract_directory_view_on_popup_menu_gtk_widget_popup_menu, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "unrealize", (GCallback) ___lambda114__gtk_widget_unrealize, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "realize", (GCallback) ___lambda115__gtk_widget_realize, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "scroll-event", (GCallback) _files_abstract_directory_view_on_scroll_event_gtk_widget_scroll_event, self, 0);
	_tmp0_ = gtk_scrolled_window_get_vadjustment ((GtkScrolledWindow*) self);
	g_signal_connect_object (_tmp0_, "value-changed", (GCallback) ___lambda116__gtk_adjustment_value_changed, self, G_CONNECT_AFTER);
	g_signal_connect_object ((GObject*) self, "notify::renaming", (GCallback) ___lambda117__g_object_notify, self, 0);
	_tmp1_ = files_preferences_get_default ();
	prefs = _tmp1_;
	g_signal_connect_object ((GObject*) prefs, "notify::show-hidden-files", (GCallback) _files_abstract_directory_view_on_show_hidden_files_changed_g_object_notify, self, 0);
	g_signal_connect_object ((GObject*) prefs, "notify::show-remote-thumbnails", (GCallback) _files_abstract_directory_view_on_show_remote_thumbnails_changed_g_object_notify, self, 0);
	g_signal_connect_object ((GObject*) prefs, "notify::show-local-thumbnails", (GCallback) _files_abstract_directory_view_on_show_local_thumbnails_changed_g_object_notify, self, 0);
	g_signal_connect_object ((GObject*) prefs, "notify::sort-directories-first", (GCallback) _files_abstract_directory_view_on_sort_directories_first_changed_g_object_notify, self, 0);
	g_object_bind_property_with_closures ((GObject*) prefs, "singleclick-select", (GObject*) self, "singleclick_select", G_BINDING_DEFAULT | G_BINDING_SYNC_CREATE, (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, (GClosureNotify) NULL)), (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, (GClosureNotify) NULL)));
	_tmp2_ = self->model;
	_tmp3_ = files_preferences_get_default ();
	_tmp4_ = _tmp3_;
	_tmp5_ = files_preferences_get_sort_directories_first (_tmp4_);
	_tmp6_ = _tmp5_;
	files_list_model_set_should_sort_directories_first (_tmp2_, _tmp6_);
	_g_object_unref0 (_tmp4_);
	_tmp7_ = self->model;
	g_signal_connect_object ((GtkTreeModel*) _tmp7_, "row-deleted", (GCallback) _files_abstract_directory_view_on_row_deleted_gtk_tree_model_row_deleted, self, 0);
	_tmp8_ = self->model;
	g_signal_connect_object ((GtkTreeSortable*) _tmp8_, "sort-column-changed", (GCallback) _files_abstract_directory_view_on_sort_column_changed_gtk_tree_sortable_sort_column_changed, self, 0);
	_g_object_unref0 (prefs);
}

static GVariant*
_variant_new1 (gboolean value)
{
	return g_variant_ref_sink (g_variant_new_boolean (value));
}

static GVariant*
_variant_new2 (gboolean value)
{
	return g_variant_ref_sink (g_variant_new_boolean (value));
}

static GVariant*
_variant_new3 (gboolean value)
{
	return g_variant_ref_sink (g_variant_new_boolean (value));
}

static void
files_abstract_directory_view_set_up__menu_actions (FilesAbstractDirectoryView* self)
{
	GSimpleActionGroup* _tmp0_;
	GSimpleActionGroup* _tmp1_;
	GSimpleActionGroup* _tmp2_;
	GSimpleActionGroup* _tmp3_;
	GSimpleActionGroup* _tmp4_;
	GSimpleActionGroup* _tmp5_;
	GSimpleActionGroup* _tmp6_;
	GSimpleActionGroup* _tmp7_;
	GSimpleActionGroup* _tmp8_;
	GSimpleActionGroup* _tmp9_;
	GSettings* _tmp10_;
	GVariant* _tmp11_;
	GSimpleActionGroup* _tmp12_;
	GSettings* _tmp13_;
	GVariant* _tmp14_;
	GSimpleActionGroup* _tmp15_;
	GSettings* _tmp16_;
	GVariant* _tmp17_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_simple_action_group_new ();
	_g_object_unref0 (self->priv->selection_actions);
	self->priv->selection_actions = _tmp0_;
	_tmp1_ = self->priv->selection_actions;
	g_action_map_add_action_entries ((GActionMap*) _tmp1_, FILES_ABSTRACT_DIRECTORY_VIEW_SELECTION_ENTRIES, (gint) G_N_ELEMENTS (FILES_ABSTRACT_DIRECTORY_VIEW_SELECTION_ENTRIES), self);
	_tmp2_ = self->priv->selection_actions;
	gtk_widget_insert_action_group ((GtkWidget*) self, "selection", (GActionGroup*) _tmp2_);
	_tmp3_ = g_simple_action_group_new ();
	_g_object_unref0 (self->priv->background_actions);
	self->priv->background_actions = _tmp3_;
	_tmp4_ = self->priv->background_actions;
	g_action_map_add_action_entries ((GActionMap*) _tmp4_, FILES_ABSTRACT_DIRECTORY_VIEW_BACKGROUND_ENTRIES, (gint) G_N_ELEMENTS (FILES_ABSTRACT_DIRECTORY_VIEW_BACKGROUND_ENTRIES), self);
	_tmp5_ = self->priv->background_actions;
	gtk_widget_insert_action_group ((GtkWidget*) self, "background", (GActionGroup*) _tmp5_);
	_tmp6_ = g_simple_action_group_new ();
	_g_object_unref0 (self->priv->common_actions);
	self->priv->common_actions = _tmp6_;
	_tmp7_ = self->priv->common_actions;
	g_action_map_add_action_entries ((GActionMap*) _tmp7_, FILES_ABSTRACT_DIRECTORY_VIEW_COMMON_ENTRIES, (gint) G_N_ELEMENTS (FILES_ABSTRACT_DIRECTORY_VIEW_COMMON_ENTRIES), self);
	_tmp8_ = self->priv->common_actions;
	gtk_widget_insert_action_group ((GtkWidget*) self, "common", (GActionGroup*) _tmp8_);
	_tmp9_ = self->priv->background_actions;
	_tmp10_ = files_app_settings;
	_tmp11_ = _variant_new1 (g_settings_get_boolean (_tmp10_, "show-hiddenfiles"));
	files_abstract_directory_view_action_set_state (self, _tmp9_, "show-hidden", _tmp11_);
	_g_variant_unref0 (_tmp11_);
	_tmp12_ = self->priv->background_actions;
	_tmp13_ = files_app_settings;
	_tmp14_ = _variant_new2 (g_settings_get_boolean (_tmp13_, "show-remote-thumbnails"));
	files_abstract_directory_view_action_set_state (self, _tmp12_, "show-remote-thumbnails", _tmp14_);
	_g_variant_unref0 (_tmp14_);
	_tmp15_ = self->priv->background_actions;
	_tmp16_ = files_app_settings;
	_tmp17_ = _variant_new3 (g_settings_get_boolean (_tmp16_, "show-local-thumbnails"));
	files_abstract_directory_view_action_set_state (self, _tmp15_, "show-local-thumbnails", _tmp17_);
	_g_variant_unref0 (_tmp17_);
}

void
files_abstract_directory_view_zoom_in (FilesAbstractDirectoryView* self)
{
	FilesZoomLevel _tmp0_;
	FilesZoomLevel _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = files_abstract_directory_view_get_zoom_level (self);
	_tmp1_ = _tmp0_;
	files_abstract_directory_view_set_zoom_level (self, _tmp1_ + 1);
}

void
files_abstract_directory_view_zoom_out (FilesAbstractDirectoryView* self)
{
	FilesZoomLevel _tmp0_;
	FilesZoomLevel _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = files_abstract_directory_view_get_zoom_level (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_ > 0) {
		FilesZoomLevel _tmp2_;
		FilesZoomLevel _tmp3_;
		_tmp2_ = files_abstract_directory_view_get_zoom_level (self);
		_tmp3_ = _tmp2_;
		files_abstract_directory_view_set_zoom_level (self, _tmp3_ - 1);
	}
}

void
files_abstract_directory_view_zoom_normal (FilesAbstractDirectoryView* self)
{
	g_return_if_fail (self != NULL);
	files_abstract_directory_view_set_zoom_level (self, files_abstract_directory_view_get_normal_zoom_level (self));
}

static Block12Data*
block12_data_ref (Block12Data* _data12_)
{
	g_atomic_int_inc (&_data12_->_ref_count_);
	return _data12_;
}

static void
block12_data_unref (void * _userdata_)
{
	Block12Data* _data12_;
	_data12_ = (Block12Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data12_->_ref_count_)) {
		FilesAbstractDirectoryView* self;
		self = _data12_->self;
		_g_object_unref0 (self);
		g_slice_free (Block12Data, _data12_);
	}
}

static gboolean
___lambda96_ (Block12Data* _data12_)
{
	FilesAbstractDirectoryView* self;
	gboolean _tmp0_;
	gboolean result;
	self = _data12_->self;
	_tmp0_ = self->priv->_tree_frozen;
	if (!_tmp0_) {
		GtkTreePath* _tmp1_;
		GtkTreePath* _tmp2_;
		self->priv->set_cursor_timeout_id = (guint) 0;
		_tmp1_ = gtk_tree_path_new_from_indices (0, -1);
		_tmp2_ = _tmp1_;
		files_abstract_directory_view_set_cursor (self, _tmp2_, FALSE, _data12_->select, TRUE);
		__vala_GtkTreePath_free0 (_tmp2_);
		result = G_SOURCE_REMOVE;
		return result;
	} else {
		result = G_SOURCE_CONTINUE;
		return result;
	}
}

static gboolean
____lambda96__gsource_func (gpointer self)
{
	gboolean result;
	result = ___lambda96_ (self);
	return result;
}

void
files_abstract_directory_view_focus_first_for_empty_selection (FilesAbstractDirectoryView* self,
                                                               gboolean select)
{
	Block12Data* _data12_;
	GList* _tmp0_;
	g_return_if_fail (self != NULL);
	_data12_ = g_slice_new0 (Block12Data);
	_data12_->_ref_count_ = 1;
	_data12_->self = g_object_ref (self);
	_data12_->select = select;
	_tmp0_ = self->selected_files;
	if (_tmp0_ == NULL) {
		self->priv->set_cursor_timeout_id = g_idle_add_full (G_PRIORITY_LOW, ____lambda96__gsource_func, block12_data_ref (_data12_), block12_data_unref);
	}
	block12_data_unref (_data12_);
	_data12_ = NULL;
}

static Block13Data*
block13_data_ref (Block13Data* _data13_)
{
	g_atomic_int_inc (&_data13_->_ref_count_);
	return _data13_;
}

static void
block13_data_unref (void * _userdata_)
{
	Block13Data* _data13_;
	_data13_ = (Block13Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data13_->_ref_count_)) {
		FilesAbstractDirectoryView* self;
		self = _data13_->self;
		_g_object_unref0 (_data13_->focus_after_select);
		_g_object_unref0 (_data13_->files_to_select_list);
		_g_object_unref0 (self);
		g_slice_free (Block13Data, _data13_);
	}
}

static void
__lambda94_ (Block13Data* _data13_,
             GFile* loc)
{
	FilesAbstractDirectoryView* self;
	GeeLinkedList* _tmp0_;
	FilesFile* _tmp1_;
	FilesFile* _tmp2_;
	self = _data13_->self;
	g_return_if_fail (loc != NULL);
	_tmp0_ = _data13_->files_to_select_list;
	_tmp1_ = files_file_get (loc);
	_tmp2_ = _tmp1_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp0_, _tmp2_);
	_g_object_unref0 (_tmp2_);
}

static void
___lambda94__gfunc (gconstpointer data,
                    gpointer self)
{
	__lambda94_ (self, (GFile*) data);
}

static void
___lambda95_ (Block13Data* _data13_)
{
	FilesAbstractDirectoryView* self;
	GeeLinkedList* _tmp0_;
	GFile* _tmp1_;
	self = _data13_->self;
	_tmp0_ = _data13_->files_to_select_list;
	_tmp1_ = _data13_->focus_after_select;
	files_abstract_directory_view_select_files_and_update_if_thawed (self, _tmp0_, _tmp1_);
}

static void
____lambda95__g_object_notify (GObject* _sender,
                               GParamSpec* pspec,
                               gpointer self)
{
	___lambda95_ (self);
}

void
files_abstract_directory_view_select_glib_files_when_thawed (FilesAbstractDirectoryView* self,
                                                             GList* location_list,
                                                             GFile* focus_location)
{
	Block13Data* _data13_;
	GeeLinkedList* _tmp0_;
	GFile* _tmp1_ = NULL;
	GFile* _tmp3_;
	gboolean _tmp4_;
	g_return_if_fail (self != NULL);
	_data13_ = g_slice_new0 (Block13Data);
	_data13_->_ref_count_ = 1;
	_data13_->self = g_object_ref (self);
	_tmp0_ = gee_linked_list_new (FILES_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	_data13_->files_to_select_list = _tmp0_;
	g_list_foreach (location_list, ___lambda94__gfunc, _data13_);
	if (focus_location != NULL) {
		GFile* _tmp2_;
		_tmp2_ = g_file_dup (focus_location);
		_g_object_unref0 (_tmp1_);
		_tmp1_ = _tmp2_;
	} else {
		_g_object_unref0 (_tmp1_);
		_tmp1_ = NULL;
	}
	_tmp3_ = _g_object_ref0 (_tmp1_);
	_data13_->focus_after_select = _tmp3_;
	_tmp4_ = self->priv->_tree_frozen;
	if (_tmp4_) {
		gulong _tmp5_;
		_tmp5_ = g_signal_connect_data ((GObject*) self, "notify::tree-frozen", (GCallback) ____lambda95__g_object_notify, block13_data_ref (_data13_), (GClosureNotify) block13_data_unref, 0);
		self->priv->select_source_handler = _tmp5_;
	} else {
		GeeLinkedList* _tmp6_;
		GFile* _tmp7_;
		_tmp6_ = _data13_->files_to_select_list;
		_tmp7_ = _data13_->focus_after_select;
		files_abstract_directory_view_select_files_and_update_if_thawed (self, _tmp6_, _tmp7_);
	}
	_g_object_unref0 (_tmp1_);
	block13_data_unref (_data13_);
	_data13_ = NULL;
}

static void
_vala_GtkTreeIter_free (GtkTreeIter* self)
{
	g_boxed_free (gtk_tree_iter_get_type (), self);
}

static void
files_abstract_directory_view_select_files_and_update_if_thawed (FilesAbstractDirectoryView* self,
                                                                 GeeLinkedList* files_to_select,
                                                                 GFile* focus_file)
{
	gboolean _tmp0_;
	guint count = 0U;
	GtkTreeIter* iter = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (files_to_select != NULL);
	_tmp0_ = self->priv->_tree_frozen;
	if (_tmp0_) {
		return;
	}
	if (self->priv->select_source_handler > ((gulong) 0)) {
		g_signal_handler_disconnect ((GObject*) self, self->priv->select_source_handler);
		self->priv->select_source_handler = (gulong) 0;
	}
	files_abstract_directory_view_disconnect_tree_signals (self);
	files_abstract_directory_view_unselect_all (self);
	count = (guint) 0;
	{
		GeeLinkedList* _f_list = NULL;
		gint _f_size = 0;
		GeeLinkedList* _tmp1_;
		gint _tmp2_;
		gint _tmp3_;
		gint _f_index = 0;
		_f_list = files_to_select;
		_tmp1_ = _f_list;
		_tmp2_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp1_);
		_tmp3_ = _tmp2_;
		_f_size = _tmp3_;
		_f_index = -1;
		while (TRUE) {
			gint _tmp4_;
			gint _tmp5_;
			FilesFile* f = NULL;
			GeeLinkedList* _tmp6_;
			gpointer _tmp7_;
			FilesListModel* _tmp8_;
			FilesFile* _tmp9_;
			GtkTreeIter* _tmp10_ = NULL;
			gboolean _tmp11_;
			_f_index = _f_index + 1;
			_tmp4_ = _f_index;
			_tmp5_ = _f_size;
			if (!(_tmp4_ < _tmp5_)) {
				break;
			}
			_tmp6_ = _f_list;
			_tmp7_ = gee_abstract_list_get ((GeeAbstractList*) _tmp6_, _f_index);
			f = (FilesFile*) _tmp7_;
			_tmp8_ = self->model;
			_tmp9_ = f;
			_tmp11_ = files_list_model_get_first_iter_for_file (_tmp8_, _tmp9_, &_tmp10_);
			__vala_GtkTreeIter_free0 (iter);
			iter = _tmp10_;
			if (_tmp11_) {
				guint _tmp12_;
				GtkTreePath* path = NULL;
				FilesListModel* _tmp13_;
				GtkTreeIter* _tmp14_;
				GtkTreeIter _tmp15_;
				GtkTreePath* _tmp16_;
				gboolean _tmp17_ = FALSE;
				GtkTreePath* _tmp21_;
				_tmp12_ = count;
				count = _tmp12_ + 1;
				_tmp13_ = self->model;
				_tmp14_ = iter;
				_tmp15_ = *_tmp14_;
				_tmp16_ = gtk_tree_model_get_path ((GtkTreeModel*) _tmp13_, &_tmp15_);
				path = _tmp16_;
				if (focus_file != NULL) {
					FilesFile* _tmp18_;
					GFile* _tmp19_;
					GFile* _tmp20_;
					_tmp18_ = f;
					_tmp19_ = files_file_get_location (_tmp18_);
					_tmp20_ = _tmp19_;
					_tmp17_ = g_file_equal (focus_file, _tmp20_);
				} else {
					_tmp17_ = FALSE;
				}
				_tmp21_ = path;
				files_abstract_directory_view_select_path (self, _tmp21_, _tmp17_);
				__vala_GtkTreePath_free0 (path);
			}
			_g_object_unref0 (f);
		}
	}
	if (count == ((guint) 0)) {
		files_abstract_directory_view_focus_first_for_empty_selection (self, FALSE);
	}
	files_abstract_directory_view_connect_tree_signals (self);
	files_abstract_directory_view_on_view_selection_changed (self);
	files_abstract_directory_view_update_selected_files_and_menu (self);
	__vala_GtkTreeIter_free0 (iter);
}

GList*
files_abstract_directory_view_get_open_with_apps (FilesAbstractDirectoryView* self)
{
	GList* _tmp0_;
	GList* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->open_with_apps;
	result = _tmp0_;
	return result;
}

GAppInfo*
files_abstract_directory_view_get_default_app (FilesAbstractDirectoryView* self)
{
	GAppInfo* _tmp0_;
	GAppInfo* _tmp1_;
	GAppInfo* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->default_app;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	result = _tmp1_;
	return result;
}

void
files_abstract_directory_view_grab_focus (FilesAbstractDirectoryView* self)
{
	GtkWidget* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->view;
	if (gtk_widget_get_realized (_tmp0_)) {
		FilesViewSlot* _tmp1_;
		gboolean _tmp2_;
		gboolean _tmp3_;
		GtkWidget* _tmp4_;
		_tmp1_ = self->slot;
		_tmp2_ = files_view_slot_get_is_active (_tmp1_);
		_tmp3_ = _tmp2_;
		if (!_tmp3_) {
			files_abstract_directory_view_set_active_slot (self, TRUE);
		}
		_tmp4_ = self->priv->view;
		gtk_widget_grab_focus (_tmp4_);
	}
}

GList*
files_abstract_directory_view_get_selected_files (FilesAbstractDirectoryView* self)
{
	GList* _tmp0_;
	GList* result;
	g_return_val_if_fail (self != NULL, NULL);
	files_abstract_directory_view_update_selected_files_and_menu (self);
	_tmp0_ = self->selected_files;
	result = _tmp0_;
	return result;
}

/*** Protected Methods */
void
files_abstract_directory_view_set_active_slot (FilesAbstractDirectoryView* self,
                                               gboolean scroll)
{
	FilesViewSlot* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->slot;
	g_signal_emit_by_name ((FilesAbstractSlot*) _tmp0_, "active", scroll, TRUE);
}

void
files_abstract_directory_view_load_location (FilesAbstractDirectoryView* self,
                                             GFile* location)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (location != NULL);
	g_signal_emit (self, files_abstract_directory_view_signals[FILES_ABSTRACT_DIRECTORY_VIEW_PATH_CHANGE_REQUEST_SIGNAL], 0, location, FILES_OPEN_FLAG_DEFAULT, FALSE);
}

void
files_abstract_directory_view_load_root_location (FilesAbstractDirectoryView* self,
                                                  GFile* location)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (location != NULL);
	g_signal_emit (self, files_abstract_directory_view_signals[FILES_ABSTRACT_DIRECTORY_VIEW_PATH_CHANGE_REQUEST_SIGNAL], 0, location, FILES_OPEN_FLAG_DEFAULT, TRUE);
}

/** Operations on selections */
static Block14Data*
block14_data_ref (Block14Data* _data14_)
{
	g_atomic_int_inc (&_data14_->_ref_count_);
	return _data14_;
}

static void
block14_data_unref (void * _userdata_)
{
	Block14Data* _data14_;
	_data14_ = (Block14Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data14_->_ref_count_)) {
		FilesAbstractDirectoryView* self;
		self = _data14_->self;
		_g_object_unref0 (self);
		g_slice_free (Block14Data, _data14_);
	}
}

static Block15Data*
block15_data_ref (Block15Data* _data15_)
{
	g_atomic_int_inc (&_data15_->_ref_count_);
	return _data15_;
}

static void
block15_data_unref (void * _userdata_)
{
	Block15Data* _data15_;
	_data15_ = (Block15Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data15_->_ref_count_)) {
		FilesAbstractDirectoryView* self;
		self = _data15_->_data14_->self;
		_g_object_unref0 (_data15_->file);
		block14_data_unref (_data15_->_data14_);
		_data15_->_data14_ = NULL;
		g_slice_free (Block15Data, _data15_);
	}
}

static gboolean
_______lambda63_ (Block15Data* _data15_)
{
	Block14Data* _data14_;
	FilesAbstractDirectoryView* self;
	FilesFile* _tmp0_;
	GdkScreen* _tmp1_;
	gboolean result;
	_data14_ = _data15_->_data14_;
	self = _data14_->self;
	_tmp0_ = _data15_->file;
	_tmp1_ = _data14_->screen;
	files_abstract_directory_view_activate_file (self, _tmp0_, _tmp1_, _data14_->flag, FALSE);
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
________lambda63__gsource_func (gpointer self)
{
	gboolean result;
	result = _______lambda63_ (self);
	return result;
}

static gboolean
_______lambda64_ (Block15Data* _data15_)
{
	Block14Data* _data14_;
	FilesAbstractDirectoryView* self;
	FilesFile* _tmp0_;
	GdkScreen* _tmp1_;
	gboolean result;
	_data14_ = _data15_->_data14_;
	self = _data14_->self;
	_tmp0_ = _data15_->file;
	_tmp1_ = _data14_->screen;
	files_abstract_directory_view_open_file (self, _tmp0_, _tmp1_, NULL);
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
________lambda64__gsource_func (gpointer self)
{
	gboolean result;
	result = _______lambda64_ (self);
	return result;
}

static Block16Data*
block16_data_ref (Block16Data* _data16_)
{
	g_atomic_int_inc (&_data16_->_ref_count_);
	return _data16_;
}

static void
block16_data_unref (void * _userdata_)
{
	Block16Data* _data16_;
	_data16_ = (Block16Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data16_->_ref_count_)) {
		FilesAbstractDirectoryView* self;
		self = _data16_->_data14_->self;
		(_data16_->files_to_open == NULL) ? NULL : (_data16_->files_to_open = (_g_list_free__g_object_unref0_ (_data16_->files_to_open), NULL));
		block14_data_unref (_data16_->_data14_);
		_data16_->_data14_ = NULL;
		g_slice_free (Block16Data, _data16_);
	}
}

static gboolean
_____lambda65_ (Block16Data* _data16_)
{
	Block14Data* _data14_;
	FilesAbstractDirectoryView* self;
	GAppInfo* _tmp0_;
	GList* _tmp1_;
	gboolean result;
	_data14_ = _data16_->_data14_;
	self = _data14_->self;
	_tmp0_ = self->priv->default_app;
	_tmp1_ = _data16_->files_to_open;
	files_abstract_directory_view_open_files_with (self, _tmp0_, _tmp1_);
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
______lambda65__gsource_func (gpointer self)
{
	gboolean result;
	result = _____lambda65_ (self);
	return result;
}

void
files_abstract_directory_view_activate_selected_items (FilesAbstractDirectoryView* self,
                                                       FilesOpenFlag flag,
                                                       GList* selection)
{
	Block14Data* _data14_;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	gboolean _tmp2_;
	GdkScreen* _tmp3_;
	GList* _tmp4_;
	GList* _tmp5_;
	g_return_if_fail (self != NULL);
	_data14_ = g_slice_new0 (Block14Data);
	_data14_->_ref_count_ = 1;
	_data14_->self = g_object_ref (self);
	_data14_->flag = flag;
	_tmp1_ = files_abstract_directory_view_get_is_frozen (self);
	_tmp2_ = _tmp1_;
	if (_tmp2_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = selection == NULL;
	}
	if (_tmp0_) {
		block14_data_unref (_data14_);
		_data14_ = NULL;
		return;
	}
	_tmp3_ = gtk_widget_get_screen ((GtkWidget*) self);
	_data14_->screen = _tmp3_;
	_tmp4_ = g_list_first (selection);
	_tmp5_ = _tmp4_->next;
	if (_tmp5_ == NULL) {
		gconstpointer _tmp6_;
		GdkScreen* _tmp7_;
		_tmp6_ = selection->data;
		_tmp7_ = _data14_->screen;
		files_abstract_directory_view_activate_file (self, (FilesFile*) _tmp6_, _tmp7_, _data14_->flag, TRUE);
		block14_data_unref (_data14_);
		_data14_ = NULL;
		return;
	}
	if (!self->priv->in_trash) {
		gboolean _tmp8_ = FALSE;
		gconstpointer _tmp9_;
		_tmp9_ = g_list_nth_data (selection, (guint) 11);
		if (((FilesFile*) _tmp9_) == NULL) {
			gboolean _tmp10_ = FALSE;
			GAppInfo* _tmp11_;
			_tmp11_ = self->priv->default_app;
			if (_tmp11_ == NULL) {
				_tmp10_ = TRUE;
			} else {
				GAppInfo* _tmp12_;
				_tmp12_ = self->priv->default_app;
				_tmp10_ = files_abstract_directory_view_app_is_this_app (self, _tmp12_);
			}
			_tmp8_ = _tmp10_;
		} else {
			_tmp8_ = FALSE;
		}
		if (_tmp8_) {
			{
				GList* file_collection = NULL;
				GList* file_it = NULL;
				file_collection = selection;
				for (file_it = file_collection; file_it != NULL; file_it = file_it->next) {
					FilesFile* _tmp13_;
					FilesFile* file = NULL;
					_tmp13_ = _g_object_ref0 ((FilesFile*) file_it->data);
					file = _tmp13_;
					{
						Block15Data* _data15_;
						FilesFile* _tmp14_;
						_data15_ = g_slice_new0 (Block15Data);
						_data15_->_ref_count_ = 1;
						_data15_->_data14_ = block14_data_ref (_data14_);
						_data15_->file = file;
						_tmp14_ = _data15_->file;
						if (files_file_is_folder (_tmp14_)) {
							if (_data14_->flag == FILES_OPEN_FLAG_DEFAULT) {
								_data14_->flag = FILES_OPEN_FLAG_NEW_TAB;
							}
							g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ________lambda63__gsource_func, block15_data_ref (_data15_), block15_data_unref);
						} else {
							g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ________lambda64__gsource_func, block15_data_ref (_data15_), block15_data_unref);
						}
						block15_data_unref (_data15_);
						_data15_ = NULL;
					}
				}
			}
		} else {
			GAppInfo* _tmp15_;
			_tmp15_ = self->priv->default_app;
			if (_tmp15_ != NULL) {
				Block16Data* _data16_;
				GList* _tmp16_;
				_data16_ = g_slice_new0 (Block16Data);
				_data16_->_ref_count_ = 1;
				_data16_->_data14_ = block14_data_ref (_data14_);
				_tmp16_ = g_list_copy_deep (selection, (GCopyFunc) g_object_ref, NULL);
				_data16_->files_to_open = _tmp16_;
				g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ______lambda65__gsource_func, block16_data_ref (_data16_), block16_data_unref);
				block16_data_unref (_data16_);
				_data16_ = NULL;
			}
		}
	} else {
		g_warning ("AbstractDirectoryView.vala:595: Cannot open files in trash");
	}
	block14_data_unref (_data14_);
	_data14_ = NULL;
}

void
files_abstract_directory_view_select_gof_file (FilesAbstractDirectoryView* self,
                                               FilesFile* file)
{
	GtkTreeIter* iter = NULL;
	FilesListModel* _tmp0_;
	GtkTreeIter* _tmp1_ = NULL;
	gboolean _tmp2_;
	GtkTreePath* path = NULL;
	FilesListModel* _tmp3_;
	GtkTreeIter* _tmp4_;
	GtkTreeIter _tmp5_;
	GtkTreePath* _tmp6_;
	GtkTreePath* _tmp7_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	_tmp0_ = self->model;
	_tmp2_ = files_list_model_get_first_iter_for_file (_tmp0_, file, &_tmp1_);
	__vala_GtkTreeIter_free0 (iter);
	iter = _tmp1_;
	if (!_tmp2_) {
		__vala_GtkTreeIter_free0 (iter);
		return;
	}
	_tmp3_ = self->model;
	_tmp4_ = iter;
	_tmp5_ = *_tmp4_;
	_tmp6_ = gtk_tree_model_get_path ((GtkTreeModel*) _tmp3_, &_tmp5_);
	path = _tmp6_;
	_tmp7_ = path;
	files_abstract_directory_view_set_cursor (self, _tmp7_, FALSE, TRUE, FALSE);
	__vala_GtkTreePath_free0 (path);
	__vala_GtkTreeIter_free0 (iter);
}

void
files_abstract_directory_view_select_and_scroll_to_gof_file (FilesAbstractDirectoryView* self,
                                                             FilesFile* file)
{
	GtkTreeIter iter = {0};
	FilesListModel* _tmp0_;
	GtkTreeIter* _tmp1_ = NULL;
	gboolean _tmp2_;
	GtkTreeIter* _tmp3_;
	gboolean _tmp4_;
	GtkTreePath* path = NULL;
	FilesListModel* _tmp5_;
	GtkTreeIter _tmp6_;
	GtkTreePath* _tmp7_;
	GtkTreePath* _tmp8_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	_tmp0_ = self->model;
	_tmp2_ = files_list_model_get_first_iter_for_file (_tmp0_, file, &_tmp1_);
	_tmp3_ = _tmp1_;
	iter = *_tmp3_;
	_tmp4_ = !_tmp2_;
	__vala_GtkTreeIter_free0 (_tmp3_);
	if (_tmp4_) {
		return;
	}
	_tmp5_ = self->model;
	_tmp6_ = iter;
	_tmp7_ = gtk_tree_model_get_path ((GtkTreeModel*) _tmp5_, &_tmp6_);
	path = _tmp7_;
	_tmp8_ = path;
	files_abstract_directory_view_set_cursor (self, _tmp8_, FALSE, TRUE, TRUE);
	__vala_GtkTreePath_free0 (path);
}

void
files_abstract_directory_view_add_gof_file_to_selection (FilesAbstractDirectoryView* self,
                                                         FilesFile* file)
{
	GtkTreeIter iter = {0};
	FilesListModel* _tmp0_;
	GtkTreeIter* _tmp1_ = NULL;
	gboolean _tmp2_;
	GtkTreeIter* _tmp3_;
	gboolean _tmp4_;
	GtkTreePath* path = NULL;
	FilesListModel* _tmp5_;
	GtkTreeIter _tmp6_;
	GtkTreePath* _tmp7_;
	GtkTreePath* _tmp8_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	_tmp0_ = self->model;
	_tmp2_ = files_list_model_get_first_iter_for_file (_tmp0_, file, &_tmp1_);
	_tmp3_ = _tmp1_;
	iter = *_tmp3_;
	_tmp4_ = !_tmp2_;
	__vala_GtkTreeIter_free0 (_tmp3_);
	if (_tmp4_) {
		return;
	}
	_tmp5_ = self->model;
	_tmp6_ = iter;
	_tmp7_ = gtk_tree_model_get_path ((GtkTreeModel*) _tmp5_, &_tmp6_);
	path = _tmp7_;
	_tmp8_ = path;
	files_abstract_directory_view_select_path (self, _tmp8_, FALSE);
	__vala_GtkTreePath_free0 (path);
}

/** Directory signal handlers. */
static void
_files_abstract_directory_view_on_directory_file_added_files_directory_file_added (FilesDirectory* _sender,
                                                                                   FilesFile* file,
                                                                                   gpointer self)
{
	files_abstract_directory_view_on_directory_file_added ((FilesAbstractDirectoryView*) self, _sender, file);
}

static void
_files_abstract_directory_view_on_directory_file_changed_files_directory_file_changed (FilesDirectory* _sender,
                                                                                       FilesFile* file,
                                                                                       gpointer self)
{
	files_abstract_directory_view_on_directory_file_changed ((FilesAbstractDirectoryView*) self, _sender, file);
}

static void
_files_abstract_directory_view_on_directory_file_deleted_files_directory_file_deleted (FilesDirectory* _sender,
                                                                                       FilesFile* file,
                                                                                       gpointer self)
{
	files_abstract_directory_view_on_directory_file_deleted ((FilesAbstractDirectoryView*) self, _sender, file);
}

static void
_files_abstract_directory_view_on_directory_file_icon_changed_files_directory_icon_changed (FilesDirectory* _sender,
                                                                                            FilesFile* file,
                                                                                            gpointer self)
{
	files_abstract_directory_view_on_directory_file_icon_changed ((FilesAbstractDirectoryView*) self, _sender, file);
}

void
files_abstract_directory_view_connect_directory_handlers (FilesAbstractDirectoryView* self,
                                                          FilesDirectory* dir)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	g_signal_connect_object (dir, "file-added", (GCallback) _files_abstract_directory_view_on_directory_file_added_files_directory_file_added, self, 0);
	g_signal_connect_object (dir, "file-changed", (GCallback) _files_abstract_directory_view_on_directory_file_changed_files_directory_file_changed, self, 0);
	g_signal_connect_object (dir, "file-deleted", (GCallback) _files_abstract_directory_view_on_directory_file_deleted_files_directory_file_deleted, self, 0);
	g_signal_connect_object (dir, "icon-changed", (GCallback) _files_abstract_directory_view_on_directory_file_icon_changed_files_directory_icon_changed, self, 0);
	files_abstract_directory_view_connect_directory_loading_handlers (self, dir);
}

static void
_files_abstract_directory_view_on_directory_file_loaded_files_directory_file_loaded (FilesDirectory* _sender,
                                                                                     FilesFile* file,
                                                                                     gpointer self)
{
	files_abstract_directory_view_on_directory_file_loaded ((FilesAbstractDirectoryView*) self, _sender, file);
}

static void
_files_abstract_directory_view_on_directory_done_loading_files_directory_done_loading (FilesDirectory* _sender,
                                                                                       gpointer self)
{
	files_abstract_directory_view_on_directory_done_loading ((FilesAbstractDirectoryView*) self, _sender);
}

void
files_abstract_directory_view_connect_directory_loading_handlers (FilesAbstractDirectoryView* self,
                                                                  FilesDirectory* dir)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	g_signal_connect_object (dir, "file-loaded", (GCallback) _files_abstract_directory_view_on_directory_file_loaded_files_directory_file_loaded, self, 0);
	g_signal_connect_object (dir, "done-loading", (GCallback) _files_abstract_directory_view_on_directory_done_loading_files_directory_done_loading, self, 0);
}

void
files_abstract_directory_view_disconnect_directory_loading_handlers (FilesAbstractDirectoryView* self,
                                                                     FilesDirectory* dir)
{
	guint _tmp0_;
	guint _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	g_signal_parse_name ("file-loaded", FILES_TYPE_DIRECTORY, &_tmp0_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (dir, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp0_, 0, NULL, (GCallback) _files_abstract_directory_view_on_directory_file_loaded_files_directory_file_loaded, self);
	g_signal_parse_name ("done-loading", FILES_TYPE_DIRECTORY, &_tmp1_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (dir, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _files_abstract_directory_view_on_directory_done_loading_files_directory_done_loading, self);
}

void
files_abstract_directory_view_disconnect_directory_handlers (FilesAbstractDirectoryView* self,
                                                             FilesDirectory* dir)
{
	guint _tmp0_;
	guint _tmp1_;
	guint _tmp2_;
	guint _tmp3_;
	guint _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	if (files_directory_is_loading (dir)) {
		files_abstract_directory_view_disconnect_directory_loading_handlers (self, dir);
	}
	g_signal_parse_name ("file-added", FILES_TYPE_DIRECTORY, &_tmp0_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (dir, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp0_, 0, NULL, (GCallback) _files_abstract_directory_view_on_directory_file_added_files_directory_file_added, self);
	g_signal_parse_name ("file-changed", FILES_TYPE_DIRECTORY, &_tmp1_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (dir, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _files_abstract_directory_view_on_directory_file_changed_files_directory_file_changed, self);
	g_signal_parse_name ("file-deleted", FILES_TYPE_DIRECTORY, &_tmp2_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (dir, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp2_, 0, NULL, (GCallback) _files_abstract_directory_view_on_directory_file_deleted_files_directory_file_deleted, self);
	g_signal_parse_name ("icon-changed", FILES_TYPE_DIRECTORY, &_tmp3_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (dir, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp3_, 0, NULL, (GCallback) _files_abstract_directory_view_on_directory_file_icon_changed_files_directory_icon_changed, self);
	g_signal_parse_name ("done-loading", FILES_TYPE_DIRECTORY, &_tmp4_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (dir, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp4_, 0, NULL, (GCallback) _files_abstract_directory_view_on_directory_done_loading_files_directory_done_loading, self);
}

void
files_abstract_directory_view_change_directory (FilesAbstractDirectoryView* self,
                                                FilesDirectory* old_dir,
                                                FilesDirectory* new_dir)
{
	GtkStyleContext* style_context = NULL;
	GtkStyleContext* _tmp0_;
	GtkStyleContext* _tmp1_;
	GtkStyleContext* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (old_dir != NULL);
	g_return_if_fail (new_dir != NULL);
	_tmp0_ = gtk_widget_get_style_context ((GtkWidget*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	style_context = _tmp1_;
	_tmp2_ = style_context;
	if (gtk_style_context_has_class (_tmp2_, GRANITE_STYLE_CLASS_H2_LABEL)) {
		GtkStyleContext* _tmp3_;
		GtkStyleContext* _tmp4_;
		_tmp3_ = style_context;
		gtk_style_context_remove_class (_tmp3_, GRANITE_STYLE_CLASS_H2_LABEL);
		_tmp4_ = style_context;
		gtk_style_context_remove_class (_tmp4_, GTK_STYLE_CLASS_VIEW);
	}
	files_abstract_directory_view_cancel (self);
	files_abstract_directory_view_clear (self);
	files_abstract_directory_view_disconnect_directory_handlers (self, old_dir);
	files_abstract_directory_view_connect_directory_handlers (self, new_dir);
	_g_object_unref0 (style_context);
}

void
files_abstract_directory_view_prepare_reload (FilesAbstractDirectoryView* self,
                                              FilesDirectory* dir)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	files_abstract_directory_view_cancel (self);
	files_abstract_directory_view_clear (self);
	files_abstract_directory_view_connect_directory_loading_handlers (self, dir);
}

static void
files_abstract_directory_view_clear (FilesAbstractDirectoryView* self)
{
	FilesListModel* _tmp0_;
	g_return_if_fail (self != NULL);
	files_abstract_directory_view_freeze_tree (self);
	files_abstract_directory_view_block_model (self);
	_tmp0_ = self->model;
	gtk_tree_store_clear ((GtkTreeStore*) _tmp0_);
	self->priv->all_selected = FALSE;
	self->on_directory = FALSE;
	files_abstract_directory_view_unblock_model (self);
}

static gboolean
_files_abstract_directory_view_on_drag_drop_gtk_widget_drag_drop (GtkWidget* _sender,
                                                                  GdkDragContext* context,
                                                                  gint x,
                                                                  gint y,
                                                                  guint time_,
                                                                  gpointer self)
{
	gboolean result;
	result = files_abstract_directory_view_on_drag_drop ((FilesAbstractDirectoryView*) self, context, x, y, time_);
	return result;
}

static void
_files_abstract_directory_view_on_drag_data_received_gtk_widget_drag_data_received (GtkWidget* _sender,
                                                                                    GdkDragContext* context,
                                                                                    gint x,
                                                                                    gint y,
                                                                                    GtkSelectionData* selection_data,
                                                                                    guint info,
                                                                                    guint time_,
                                                                                    gpointer self)
{
	files_abstract_directory_view_on_drag_data_received ((FilesAbstractDirectoryView*) self, context, x, y, selection_data, info, time_);
}

static void
_files_abstract_directory_view_on_drag_leave_gtk_widget_drag_leave (GtkWidget* _sender,
                                                                    GdkDragContext* context,
                                                                    guint time_,
                                                                    gpointer self)
{
	files_abstract_directory_view_on_drag_leave ((FilesAbstractDirectoryView*) self, context, time_);
}

static gboolean
_files_abstract_directory_view_on_drag_motion_gtk_widget_drag_motion (GtkWidget* _sender,
                                                                      GdkDragContext* context,
                                                                      gint x,
                                                                      gint y,
                                                                      guint time_,
                                                                      gpointer self)
{
	gboolean result;
	result = files_abstract_directory_view_on_drag_motion ((FilesAbstractDirectoryView*) self, context, x, y, time_);
	return result;
}

static void
_files_abstract_directory_view_on_drag_begin_gtk_widget_drag_begin (GtkWidget* _sender,
                                                                    GdkDragContext* context,
                                                                    gpointer self)
{
	files_abstract_directory_view_on_drag_begin ((FilesAbstractDirectoryView*) self, context);
}

static void
_files_abstract_directory_view_on_drag_data_get_gtk_widget_drag_data_get (GtkWidget* _sender,
                                                                          GdkDragContext* context,
                                                                          GtkSelectionData* selection_data,
                                                                          guint info,
                                                                          guint time_,
                                                                          gpointer self)
{
	files_abstract_directory_view_on_drag_data_get ((FilesAbstractDirectoryView*) self, context, selection_data, info, time_);
}

static void
_files_abstract_directory_view_on_drag_data_delete_gtk_widget_drag_data_delete (GtkWidget* _sender,
                                                                                GdkDragContext* context,
                                                                                gpointer self)
{
	files_abstract_directory_view_on_drag_data_delete ((FilesAbstractDirectoryView*) self, context);
}

static void
_files_abstract_directory_view_on_drag_end_gtk_widget_drag_end (GtkWidget* _sender,
                                                                GdkDragContext* context,
                                                                gpointer self)
{
	files_abstract_directory_view_on_drag_end ((FilesAbstractDirectoryView*) self, context);
}

void
files_abstract_directory_view_connect_drag_drop_signals (FilesAbstractDirectoryView* self,
                                                         GtkWidget* widget)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	gtk_drag_dest_set (widget, GTK_DEST_DEFAULT_MOTION, FILES_ABSTRACT_DIRECTORY_VIEW_DROP_TARGETS, (gint) G_N_ELEMENTS (FILES_ABSTRACT_DIRECTORY_VIEW_DROP_TARGETS), GDK_ACTION_ASK | FILES_ABSTRACT_DIRECTORY_VIEW_FILE_DRAG_ACTIONS);
	g_signal_connect_object (widget, "drag-drop", (GCallback) _files_abstract_directory_view_on_drag_drop_gtk_widget_drag_drop, self, 0);
	g_signal_connect_object (widget, "drag-data-received", (GCallback) _files_abstract_directory_view_on_drag_data_received_gtk_widget_drag_data_received, self, 0);
	g_signal_connect_object (widget, "drag-leave", (GCallback) _files_abstract_directory_view_on_drag_leave_gtk_widget_drag_leave, self, 0);
	g_signal_connect_object (widget, "drag-motion", (GCallback) _files_abstract_directory_view_on_drag_motion_gtk_widget_drag_motion, self, 0);
	gtk_drag_source_set (widget, (GDK_BUTTON1_MASK | GDK_BUTTON3_MASK) | GDK_CONTROL_MASK, FILES_ABSTRACT_DIRECTORY_VIEW_DRAG_TARGETS, (gint) G_N_ELEMENTS (FILES_ABSTRACT_DIRECTORY_VIEW_DRAG_TARGETS), FILES_ABSTRACT_DIRECTORY_VIEW_FILE_DRAG_ACTIONS);
	g_signal_connect_object (widget, "drag-begin", (GCallback) _files_abstract_directory_view_on_drag_begin_gtk_widget_drag_begin, self, 0);
	g_signal_connect_object (widget, "drag-data-get", (GCallback) _files_abstract_directory_view_on_drag_data_get_gtk_widget_drag_data_get, self, 0);
	g_signal_connect_object (widget, "drag-data-delete", (GCallback) _files_abstract_directory_view_on_drag_data_delete_gtk_widget_drag_data_delete, self, 0);
	g_signal_connect_object (widget, "drag-end", (GCallback) _files_abstract_directory_view_on_drag_end_gtk_widget_drag_end, self, 0);
}

void
files_abstract_directory_view_cancel_drag_timer (FilesAbstractDirectoryView* self)
{
	g_return_if_fail (self != NULL);
	files_abstract_directory_view_disconnect_drag_timeout_motion_and_release_events (self);
	files_abstract_directory_view_cancel_timeout (self, &self->priv->drag_timer_id);
}

void
files_abstract_directory_view_cancel_thumbnailing (FilesAbstractDirectoryView* self)
{
	g_return_if_fail (self != NULL);
	if (self->priv->thumbnail_request >= 0) {
		FilesThumbnailer* _tmp0_;
		_tmp0_ = self->priv->thumbnailer;
		files_thumbnailer_dequeue (_tmp0_, self->priv->thumbnail_request);
		self->priv->thumbnail_request = -1;
	}
	files_abstract_directory_view_cancel_timeout (self, &self->priv->thumbnail_source_id);
}

static Block17Data*
block17_data_ref (Block17Data* _data17_)
{
	g_atomic_int_inc (&_data17_->_ref_count_);
	return _data17_;
}

static void
block17_data_unref (void * _userdata_)
{
	Block17Data* _data17_;
	_data17_ = (Block17Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data17_->_ref_count_)) {
		FilesAbstractDirectoryView* self;
		self = _data17_->self;
		_g_object_unref0 (self);
		g_slice_free (Block17Data, _data17_);
	}
}

static void
__lambda54_ (Block17Data* _data17_,
             FilesFile* file)
{
	FilesAbstractDirectoryView* self;
	gboolean _tmp0_ = FALSE;
	self = _data17_->self;
	g_return_if_fail (file != NULL);
	if (files_file_is_folder (file)) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = files_file_is_root_network_folder (file);
	}
	if (!_tmp0_) {
		_data17_->only_folders = FALSE;
	}
}

static void
___lambda54__gfunc (gconstpointer data,
                    gpointer self)
{
	__lambda54_ (self, (FilesFile*) data);
}

gboolean
files_abstract_directory_view_selection_only_contains_folders (FilesAbstractDirectoryView* self,
                                                               GList* list)
{
	Block17Data* _data17_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	_data17_ = g_slice_new0 (Block17Data);
	_data17_->_ref_count_ = 1;
	_data17_->self = g_object_ref (self);
	_data17_->only_folders = TRUE;
	g_list_foreach (list, ___lambda54__gfunc, _data17_);
	result = _data17_->only_folders;
	block17_data_unref (_data17_);
	_data17_ = NULL;
	return result;
}

/** Handle scroll events */
gboolean
files_abstract_directory_view_handle_scroll_event (FilesAbstractDirectoryView* self,
                                                   GdkEventScroll* event)
{
	gboolean _tmp0_;
	gboolean _tmp1_;
	GdkModifierType state = 0U;
	GdkModifierType _tmp2_ = 0U;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = files_abstract_directory_view_get_is_frozen (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_) {
		result = TRUE;
		return result;
	}
	gdk_event_get_state ((GdkEvent*) event, &_tmp2_);
	state = _tmp2_;
	if ((state & GDK_CONTROL_MASK) > 0) {
		GdkScrollDirection direction = 0;
		gdouble delta_x = 0.0;
		gdouble delta_y = 0.0;
		GdkScrollDirection _tmp3_ = 0;
		gboolean _tmp4_;
		_tmp4_ = gdk_event_get_scroll_direction ((GdkEvent*) event, &_tmp3_);
		direction = _tmp3_;
		if (_tmp4_) {
			if (direction == GDK_SCROLL_UP) {
				files_abstract_directory_view_zoom_in (self);
				result = TRUE;
				return result;
			} else {
				if (direction == GDK_SCROLL_DOWN) {
					files_abstract_directory_view_zoom_out (self);
					result = TRUE;
					return result;
				}
			}
			result = FALSE;
			return result;
		} else {
			gdouble _tmp5_ = 0.0;
			gdouble _tmp6_ = 0.0;
			gboolean _tmp7_;
			_tmp7_ = gdk_event_get_scroll_deltas ((GdkEvent*) event, &_tmp5_, &_tmp6_);
			delta_x = _tmp5_;
			delta_y = _tmp6_;
			if (_tmp7_) {
				self->priv->total_delta_y = self->priv->total_delta_y + delta_y;
				if (self->priv->total_delta_y >= 0.5) {
					self->priv->total_delta_y = (gdouble) 0;
					files_abstract_directory_view_zoom_out (self);
				} else {
					if (self->priv->total_delta_y <= (-0.5)) {
						self->priv->total_delta_y = (gdouble) 0;
						files_abstract_directory_view_zoom_in (self);
					}
				}
				result = TRUE;
				return result;
			}
		}
	}
	result = FALSE;
	return result;
}

GList*
files_abstract_directory_view_get_selected_files_for_transfer (FilesAbstractDirectoryView* self,
                                                               GList* selection)
{
	GList* _tmp0_;
	GList* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_list_copy_deep (selection, (GCopyFunc) g_object_ref, NULL);
	result = _tmp0_;
	return result;
}

/** File operations */
static void
files_abstract_directory_view_activate_file (FilesAbstractDirectoryView* self,
                                             FilesFile* _file,
                                             GdkScreen* screen,
                                             FilesOpenFlag flag,
                                             gboolean only_one_file)
{
	gboolean _tmp0_;
	gboolean _tmp1_;
	FilesFile* file = NULL;
	FilesFile* _tmp2_;
	gboolean _tmp3_;
	FilesFile* _tmp8_;
	GAppInfo* _tmp9_;
	GFile* location = NULL;
	FilesFile* _tmp10_;
	GFile* _tmp11_;
	GFile* _tmp12_;
	gboolean _tmp14_ = FALSE;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (_file != NULL);
	_tmp0_ = files_abstract_directory_view_get_is_frozen (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_) {
		return;
	}
	_tmp2_ = _g_object_ref0 (_file);
	file = _tmp2_;
	_tmp3_ = self->priv->_in_recent;
	if (_tmp3_) {
		FilesFile* _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
		FilesFile* _tmp7_;
		_tmp4_ = file;
		_tmp5_ = files_file_get_display_target_uri (_tmp4_);
		_tmp6_ = _tmp5_;
		_tmp7_ = files_file_get_by_uri (_tmp6_);
		_g_object_unref0 (file);
		file = _tmp7_;
		_g_free0 (_tmp6_);
	}
	_tmp8_ = file;
	_tmp9_ = files_mime_actions_get_default_application_for_file (_tmp8_);
	_g_object_unref0 (self->priv->default_app);
	self->priv->default_app = _tmp9_;
	_tmp10_ = file;
	_tmp11_ = files_file_get_target_location (_tmp10_);
	_tmp12_ = _g_object_ref0 (_tmp11_);
	location = _tmp12_;
	if (screen == NULL) {
		GdkScreen* _tmp13_;
		_tmp13_ = gtk_widget_get_screen ((GtkWidget*) self);
		screen = _tmp13_;
	}
	if (flag != FILES_OPEN_FLAG_APP) {
		gboolean _tmp15_ = FALSE;
		gboolean _tmp16_ = FALSE;
		FilesFile* _tmp17_;
		_tmp17_ = file;
		if (files_file_is_folder (_tmp17_)) {
			_tmp16_ = TRUE;
		} else {
			FilesFile* _tmp18_;
			const gchar* _tmp19_;
			_tmp18_ = file;
			_tmp19_ = files_file_get_ftype (_tmp18_);
			_tmp16_ = g_strcmp0 (_tmp19_, "inode/directory") == 0;
		}
		if (_tmp16_) {
			_tmp15_ = TRUE;
		} else {
			FilesFile* _tmp20_;
			_tmp20_ = file;
			_tmp15_ = files_file_is_root_network_folder (_tmp20_);
		}
		_tmp14_ = _tmp15_;
	} else {
		_tmp14_ = FALSE;
	}
	if (_tmp14_) {
		switch (flag) {
			case FILES_OPEN_FLAG_NEW_TAB:
			case FILES_OPEN_FLAG_NEW_WINDOW:
			{
				GFile* _tmp21_;
				_tmp21_ = location;
				g_signal_emit (self, files_abstract_directory_view_signals[FILES_ABSTRACT_DIRECTORY_VIEW_PATH_CHANGE_REQUEST_SIGNAL], 0, _tmp21_, flag, TRUE);
				break;
			}
			default:
			{
				if (only_one_file) {
					GFile* _tmp22_;
					_tmp22_ = location;
					files_abstract_directory_view_load_location (self, _tmp22_);
				}
				break;
			}
		}
	} else {
		if (!self->priv->in_trash) {
			if (only_one_file) {
				FilesFile* _tmp23_;
				_tmp23_ = file;
				if (files_file_is_executable (_tmp23_)) {
					gchar* content_type = NULL;
					FilesFile* _tmp24_;
					const gchar* _tmp25_;
					gchar* _tmp26_;
					const gchar* _tmp27_;
					_tmp24_ = file;
					_tmp25_ = files_file_get_ftype (_tmp24_);
					_tmp26_ = g_strdup (_tmp25_);
					content_type = _tmp26_;
					_tmp27_ = content_type;
					if (g_content_type_is_a (_tmp27_, "text/plain")) {
						FilesFile* _tmp28_;
						GAppInfo* _tmp29_;
						_tmp28_ = file;
						_tmp29_ = self->priv->default_app;
						files_abstract_directory_view_open_file (self, _tmp28_, screen, _tmp29_);
					} else {
						{
							FilesFile* _tmp30_;
							_tmp30_ = file;
							files_file_execute (_tmp30_, NULL, &_inner_error0_);
							if (G_UNLIKELY (_inner_error0_ != NULL)) {
								goto __catch0_g_error;
							}
						}
						goto __finally0;
						__catch0_g_error:
						{
							GError* e = NULL;
							GError* _tmp31_;
							const gchar* _tmp32_;
							FilesViewWindow* _tmp33_;
							GraniteMessageDialog* _tmp34_;
							GraniteMessageDialog* _tmp35_;
							e = _inner_error0_;
							_inner_error0_ = NULL;
							_tmp31_ = e;
							_tmp32_ = _tmp31_->message;
							_tmp33_ = self->window;
							_tmp34_ = pf_dialogs_show_warning_dialog (_ ("Cannot execute this file"), _tmp32_, (GtkWindow*) _tmp33_);
							_tmp35_ = _tmp34_;
							_g_object_unref0 (_tmp35_);
							_g_error_free0 (e);
						}
						__finally0:
						if (G_UNLIKELY (_inner_error0_ != NULL)) {
							_g_free0 (content_type);
							_g_object_unref0 (location);
							_g_object_unref0 (file);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
							g_clear_error (&_inner_error0_);
							return;
						}
					}
					_g_free0 (content_type);
				} else {
					FilesFile* _tmp36_;
					GAppInfo* _tmp37_;
					_tmp36_ = file;
					_tmp37_ = self->priv->default_app;
					files_abstract_directory_view_open_file (self, _tmp36_, screen, _tmp37_);
				}
			}
		} else {
			FilesFile* _tmp38_;
			const gchar* _tmp39_;
			const gchar* _tmp40_;
			gchar* _tmp41_;
			gchar* _tmp42_;
			FilesViewWindow* _tmp43_;
			GraniteMessageDialog* _tmp44_;
			GraniteMessageDialog* _tmp45_;
			_tmp38_ = file;
			_tmp39_ = files_file_get_basename (_tmp38_);
			_tmp40_ = _tmp39_;
			_tmp41_ = g_strdup_printf (_ ("“%s” must be moved from Trash before opening"), _tmp40_);
			_tmp42_ = _tmp41_;
			_tmp43_ = self->window;
			_tmp44_ = pf_dialogs_show_error_dialog (_tmp42_, _ ("Files inside Trash cannot be opened. To open this file, it must be mov" \
"ed elsewhere."), (GtkWindow*) _tmp43_);
			_tmp45_ = _tmp44_;
			_g_object_unref0 (_tmp45_);
			_g_free0 (_tmp42_);
		}
	}
	_g_object_unref0 (location);
	_g_object_unref0 (file);
}

static void
files_abstract_directory_view_open_file (FilesAbstractDirectoryView* self,
                                         FilesFile* file,
                                         GdkScreen* screen,
                                         GAppInfo* app_info)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	if (files_abstract_directory_view_can_open_file (self, file, TRUE)) {
		GFile* _tmp0_;
		GFile* _tmp1_;
		_tmp0_ = files_file_get_location (file);
		_tmp1_ = _tmp0_;
		files_mime_actions_open_glib_file_request (_tmp1_, (GtkWidget*) self, app_info);
	}
}

static gchar*
bool_to_string (gboolean self)
{
	gchar* result;
	if (self) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup ("true");
		result = _tmp0_;
		return result;
	} else {
		gchar* _tmp1_;
		_tmp1_ = g_strdup ("false");
		result = _tmp1_;
		return result;
	}
}

static gboolean
string_contains (const gchar* self,
                 const gchar* needle)
{
	gchar* _tmp0_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}

static gboolean
files_abstract_directory_view_can_open_file (FilesAbstractDirectoryView* self,
                                             FilesFile* file,
                                             gboolean show_error_dialog)
{
	gchar* err_msg1 = NULL;
	gchar* _tmp0_;
	gchar* err_msg2 = NULL;
	gchar* _tmp1_;
	gchar* content_type = NULL;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp12_;
	gboolean success = FALSE;
	const gchar* _tmp40_;
	gint _tmp41_;
	gint _tmp42_;
	gboolean _tmp43_ = FALSE;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (file != NULL, FALSE);
	_tmp0_ = g_strdup (_ ("Cannot open this file"));
	err_msg1 = _tmp0_;
	_tmp1_ = g_strdup ("");
	err_msg2 = _tmp1_;
	_tmp2_ = files_file_get_ftype (file);
	_tmp3_ = g_strdup (_tmp2_);
	content_type = _tmp3_;
	_tmp4_ = content_type;
	if (_tmp4_ == NULL) {
		gboolean result_uncertain = FALSE;
		const gchar* _tmp5_;
		const gchar* _tmp6_;
		gboolean _tmp7_ = FALSE;
		gchar* _tmp8_;
		const gchar* _tmp9_;
		gchar* _tmp10_;
		gchar* _tmp11_;
		result_uncertain = TRUE;
		_tmp5_ = files_file_get_basename (file);
		_tmp6_ = _tmp5_;
		_tmp8_ = g_content_type_guess (_tmp6_, NULL, (gsize) 0, &_tmp7_);
		result_uncertain = _tmp7_;
		_g_free0 (content_type);
		content_type = _tmp8_;
		_tmp9_ = content_type;
		_tmp10_ = bool_to_string (result_uncertain);
		_tmp11_ = _tmp10_;
		g_debug ("AbstractDirectoryView.vala:870: Guessed content type to be %s from nam" \
"e - result_uncertain %s", _tmp9_, _tmp11_);
		_g_free0 (_tmp11_);
	}
	_tmp12_ = content_type;
	if (_tmp12_ == NULL) {
		gchar* _tmp13_;
		_tmp13_ = g_strdup (_ ("Cannot identify file type to open"));
		_g_free0 (err_msg2);
		err_msg2 = _tmp13_;
	} else {
		FilesViewSlot* _tmp14_;
		FilesDirectory* _tmp15_;
		FilesDirectory* _tmp16_;
		gboolean _tmp17_;
		gboolean _tmp18_;
		_tmp14_ = self->slot;
		_tmp15_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp14_);
		_tmp16_ = _tmp15_;
		_tmp17_ = files_directory_get_can_open_files (_tmp16_);
		_tmp18_ = _tmp17_;
		if (!_tmp18_) {
			FilesViewSlot* _tmp19_;
			FilesDirectory* _tmp20_;
			FilesDirectory* _tmp21_;
			const gchar* _tmp22_;
			const gchar* _tmp23_;
			gchar* _tmp24_;
			_tmp19_ = self->slot;
			_tmp20_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp19_);
			_tmp21_ = _tmp20_;
			_tmp22_ = files_directory_get_scheme (_tmp21_);
			_tmp23_ = _tmp22_;
			_tmp24_ = g_strdup_printf ("Cannot open files with this protocol (%s)", _tmp23_);
			_g_free0 (err_msg2);
			err_msg2 = _tmp24_;
		} else {
			gboolean _tmp25_ = FALSE;
			FilesViewSlot* _tmp26_;
			FilesDirectory* _tmp27_;
			FilesDirectory* _tmp28_;
			gboolean _tmp29_;
			gboolean _tmp30_;
			_tmp26_ = self->slot;
			_tmp27_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp26_);
			_tmp28_ = _tmp27_;
			_tmp29_ = files_directory_get_can_stream_files (_tmp28_);
			_tmp30_ = _tmp29_;
			if (!_tmp30_) {
				gboolean _tmp31_ = FALSE;
				const gchar* _tmp32_;
				_tmp32_ = content_type;
				if (string_contains (_tmp32_, "video")) {
					_tmp31_ = TRUE;
				} else {
					const gchar* _tmp33_;
					_tmp33_ = content_type;
					_tmp31_ = string_contains (_tmp33_, "audio");
				}
				_tmp25_ = _tmp31_;
			} else {
				_tmp25_ = FALSE;
			}
			if (_tmp25_) {
				FilesViewSlot* _tmp34_;
				FilesDirectory* _tmp35_;
				FilesDirectory* _tmp36_;
				const gchar* _tmp37_;
				const gchar* _tmp38_;
				gchar* _tmp39_;
				_tmp34_ = self->slot;
				_tmp35_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp34_);
				_tmp36_ = _tmp35_;
				_tmp37_ = files_directory_get_scheme (_tmp36_);
				_tmp38_ = _tmp37_;
				_tmp39_ = g_strdup_printf ("Cannot stream from this protocol (%s)", _tmp38_);
				_g_free0 (err_msg2);
				err_msg2 = _tmp39_;
			}
		}
	}
	_tmp40_ = err_msg2;
	_tmp41_ = strlen (_tmp40_);
	_tmp42_ = _tmp41_;
	success = _tmp42_ < 1;
	if (!success) {
		_tmp43_ = show_error_dialog;
	} else {
		_tmp43_ = FALSE;
	}
	if (_tmp43_) {
		const gchar* _tmp44_;
		const gchar* _tmp45_;
		FilesViewWindow* _tmp46_;
		GraniteMessageDialog* _tmp47_;
		GraniteMessageDialog* _tmp48_;
		_tmp44_ = err_msg1;
		_tmp45_ = err_msg2;
		_tmp46_ = self->window;
		_tmp47_ = pf_dialogs_show_warning_dialog (_tmp44_, _tmp45_, (GtkWindow*) _tmp46_);
		_tmp48_ = _tmp47_;
		_g_object_unref0 (_tmp48_);
	}
	result = success;
	_g_free0 (content_type);
	_g_free0 (err_msg2);
	_g_free0 (err_msg1);
	return result;
}

static Block18Data*
block18_data_ref (Block18Data* _data18_)
{
	g_atomic_int_inc (&_data18_->_ref_count_);
	return _data18_;
}

static void
block18_data_unref (void * _userdata_)
{
	Block18Data* _data18_;
	_data18_ = (Block18Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data18_->_ref_count_)) {
		FilesAbstractDirectoryView* self;
		self = _data18_->self;
		(_data18_->locations == NULL) ? NULL : (_data18_->locations = (_g_list_free__g_object_unref0_ (_data18_->locations), NULL));
		_g_object_unref0 (self);
		g_slice_free (Block18Data, _data18_);
	}
}

static void
___lambda58_ (Block18Data* _data18_,
              FilesFile* file)
{
	FilesAbstractDirectoryView* self;
	gchar* _tmp0_;
	gchar* _tmp1_;
	GFile* _tmp2_;
	self = _data18_->self;
	g_return_if_fail (file != NULL);
	_tmp0_ = files_file_get_display_target_uri (file);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_file_new_for_uri (_tmp1_);
	_data18_->locations = g_list_prepend (_data18_->locations, _tmp2_);
	_g_free0 (_tmp1_);
}

static void
____lambda58__gfunc (gconstpointer data,
                     gpointer self)
{
	___lambda58_ (self, (FilesFile*) data);
}

static void
___lambda59_ (Block18Data* _data18_,
              FilesFile* file)
{
	FilesAbstractDirectoryView* self;
	GFile* _tmp0_;
	GFile* _tmp1_;
	GFile* _tmp2_;
	self = _data18_->self;
	g_return_if_fail (file != NULL);
	_tmp0_ = files_file_get_location (file);
	_tmp1_ = _tmp0_;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_data18_->locations = g_list_prepend (_data18_->locations, _tmp2_);
}

static void
____lambda59__gfunc (gconstpointer data,
                     gpointer self)
{
	___lambda59_ (self, (FilesFile*) data);
}

static void
___lambda60_ (FilesAbstractDirectoryView* self,
              GObject* obj,
              GAsyncResult* res)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (res != NULL);
	{
		marlin_file_operations_delete_finish (res, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp0_;
		const gchar* _tmp1_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp0_ = e;
		_tmp1_ = _tmp0_->message;
		g_debug ("AbstractDirectoryView.vala:925: %s", _tmp1_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	files_abstract_directory_view_after_trash_or_delete (self);
}

static void
____lambda60__gasync_ready_callback (GObject* source_object,
                                     GAsyncResult* res,
                                     gpointer self)
{
	___lambda60_ ((FilesAbstractDirectoryView*) self, source_object, res);
	g_object_unref (self);
}

static void
files_abstract_directory_view_trash_or_delete_files (FilesAbstractDirectoryView* self,
                                                     GList* file_list,
                                                     gboolean delete_if_already_in_trash,
                                                     gboolean delete_immediately)
{
	Block18Data* _data18_;
	gboolean _tmp0_;
	GtkTreeIter* iter = NULL;
	FilesListModel* _tmp1_;
	GList* _tmp2_;
	gconstpointer _tmp3_;
	GtkTreeIter* _tmp4_ = NULL;
	FilesListModel* _tmp5_;
	GtkTreeIter* _tmp6_;
	GtkTreeIter _tmp7_;
	GtkTreePath* _tmp8_;
	GList* _tmp9_;
	gboolean _tmp15_;
	g_return_if_fail (self != NULL);
	_data18_ = g_slice_new0 (Block18Data);
	_data18_->_ref_count_ = 1;
	_data18_->self = g_object_ref (self);
	_data18_->locations = NULL;
	_tmp0_ = self->priv->_in_recent;
	if (_tmp0_) {
		g_list_foreach (file_list, ____lambda58__gfunc, _data18_);
	} else {
		g_list_foreach (file_list, ____lambda59__gfunc, _data18_);
	}
	iter = NULL;
	_tmp1_ = self->model;
	_tmp2_ = g_list_first (file_list);
	_tmp3_ = _tmp2_->data;
	files_list_model_get_first_iter_for_file (_tmp1_, (FilesFile*) _tmp3_, &_tmp4_);
	__vala_GtkTreeIter_free0 (iter);
	iter = _tmp4_;
	_tmp5_ = self->model;
	_tmp6_ = iter;
	_tmp7_ = *_tmp6_;
	_tmp8_ = gtk_tree_model_get_path ((GtkTreeModel*) _tmp5_, &_tmp7_);
	__vala_GtkTreePath_free0 (self->priv->deleted_path);
	self->priv->deleted_path = _tmp8_;
	_tmp9_ = _data18_->locations;
	if (_tmp9_ != NULL) {
		FilesViewSlot* _tmp10_;
		FilesDirectory* _tmp11_;
		FilesDirectory* _tmp12_;
		GList* _tmp13_;
		FilesViewWindow* _tmp14_;
		_data18_->locations = g_list_reverse (_data18_->locations);
		_tmp10_ = self->slot;
		_tmp11_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp10_);
		_tmp12_ = _tmp11_;
		files_directory_block_monitor (_tmp12_);
		_tmp13_ = _data18_->locations;
		_tmp14_ = self->window;
		marlin_file_operations_delete (_tmp13_, G_TYPE_CHECK_INSTANCE_TYPE (_tmp14_, gtk_window_get_type ()) ? ((GtkWindow*) _tmp14_) : NULL, !delete_immediately, NULL, ____lambda60__gasync_ready_callback, g_object_ref (self));
	}
	_tmp15_ = self->priv->_in_recent;
	if (_tmp15_) {
		FilesViewSlot* _tmp16_;
		_tmp16_ = self->slot;
		files_abstract_slot_reload ((FilesAbstractSlot*) _tmp16_, FALSE);
	}
	__vala_GtkTreeIter_free0 (iter);
	block18_data_unref (_data18_);
	_data18_ = NULL;
}

static void
files_abstract_directory_view_add_file (FilesAbstractDirectoryView* self,
                                        FilesFile* file,
                                        FilesDirectory* dir,
                                        gboolean select)
{
	FilesListModel* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	g_return_if_fail (dir != NULL);
	_tmp0_ = self->model;
	files_list_model_add_file (_tmp0_, file, dir);
	if (select) {
		files_abstract_directory_view_add_gof_file_to_selection (self, file);
	}
}

static gboolean
___lambda78_ (FilesAbstractDirectoryView* self)
{
	gboolean result;
	if (self->priv->signal_free_space_change) {
		FilesViewWindow* _tmp0_;
		self->priv->add_remove_file_timeout_id = (guint) 0;
		_tmp0_ = self->window;
		g_signal_emit_by_name (_tmp0_, "free-space-change");
		result = G_SOURCE_REMOVE;
		return result;
	} else {
		self->priv->signal_free_space_change = TRUE;
		result = G_SOURCE_CONTINUE;
		return result;
	}
}

static gboolean
____lambda78__gsource_func (gpointer self)
{
	gboolean result;
	result = ___lambda78_ ((FilesAbstractDirectoryView*) self);
	return result;
}

static void
files_abstract_directory_view_handle_free_space_change (FilesAbstractDirectoryView* self)
{
	g_return_if_fail (self != NULL);
	if (self->priv->add_remove_file_timeout_id == ((guint) 0)) {
		self->priv->signal_free_space_change = FALSE;
		self->priv->add_remove_file_timeout_id = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 250, ____lambda78__gsource_func, g_object_ref (self), g_object_unref);
	} else {
		self->priv->signal_free_space_change = FALSE;
	}
}

static void
__lambda109_ (FilesAbstractDirectoryView* self,
              GObject* obj,
              GAsyncResult* res)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (res != NULL);
	{
		GFile* file = NULL;
		GFile* _tmp0_;
		_tmp0_ = marlin_file_operations_new_file_finish (res, &_inner_error0_);
		file = _tmp0_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		files_abstract_directory_view_create_file_done (file, self);
		_g_object_unref0 (file);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp1_;
		const gchar* _tmp2_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp1_ = e;
		_tmp2_ = _tmp1_->message;
		g_critical ("AbstractDirectoryView.vala:985: %s", _tmp2_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

static void
___lambda109__gasync_ready_callback (GObject* source_object,
                                     GAsyncResult* res,
                                     gpointer self)
{
	__lambda109_ ((FilesAbstractDirectoryView*) self, source_object, res);
	g_object_unref (self);
}

static void
files_abstract_directory_view_new_empty_file (FilesAbstractDirectoryView* self,
                                              const gchar* parent_uri)
{
	FilesViewSlot* _tmp7_;
	FilesDirectory* _tmp8_;
	FilesDirectory* _tmp9_;
	g_return_if_fail (self != NULL);
	if (parent_uri == NULL) {
		FilesViewSlot* _tmp0_;
		FilesDirectory* _tmp1_;
		FilesDirectory* _tmp2_;
		FilesFile* _tmp3_;
		FilesFile* _tmp4_;
		const gchar* _tmp5_;
		const gchar* _tmp6_;
		_tmp0_ = self->slot;
		_tmp1_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp0_);
		_tmp2_ = _tmp1_;
		_tmp3_ = files_directory_get_file (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp5_ = files_file_get_uri (_tmp4_);
		_tmp6_ = _tmp5_;
		parent_uri = _tmp6_;
	}
	_tmp7_ = self->slot;
	_tmp8_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp7_);
	_tmp9_ = _tmp8_;
	files_directory_block_monitor (_tmp9_);
	marlin_file_operations_new_file ((GtkWidget*) self, parent_uri, NULL, NULL, 0, NULL, ___lambda109__gasync_ready_callback, g_object_ref (self));
}

static void
__lambda66_ (FilesAbstractDirectoryView* self,
             GObject* obj,
             GAsyncResult* res)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (res != NULL);
	{
		GFile* file = NULL;
		GFile* _tmp0_;
		_tmp0_ = marlin_file_operations_new_folder_finish (res, &_inner_error0_);
		file = _tmp0_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		files_abstract_directory_view_create_file_done (file, self);
		_g_object_unref0 (file);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp1_;
		const gchar* _tmp2_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp1_ = e;
		_tmp2_ = _tmp1_->message;
		g_critical ("AbstractDirectoryView.vala:999: %s", _tmp2_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

static void
___lambda66__gasync_ready_callback (GObject* source_object,
                                    GAsyncResult* res,
                                    gpointer self)
{
	__lambda66_ ((FilesAbstractDirectoryView*) self, source_object, res);
	g_object_unref (self);
}

static void
files_abstract_directory_view_new_empty_folder (FilesAbstractDirectoryView* self)
{
	FilesViewSlot* _tmp0_;
	FilesDirectory* _tmp1_;
	FilesDirectory* _tmp2_;
	FilesViewSlot* _tmp3_;
	GFile* _tmp4_;
	GFile* _tmp5_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->slot;
	_tmp1_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp0_);
	_tmp2_ = _tmp1_;
	files_directory_block_monitor (_tmp2_);
	_tmp3_ = self->slot;
	_tmp4_ = files_abstract_slot_get_location ((FilesAbstractSlot*) _tmp3_);
	_tmp5_ = _tmp4_;
	marlin_file_operations_new_folder ((GtkWidget*) self, _tmp5_, NULL, ___lambda66__gasync_ready_callback, g_object_ref (self));
}

static void
_files_abstract_directory_view_after_new_file_added_files_directory_file_added (FilesDirectory* _sender,
                                                                                FilesFile* file,
                                                                                gpointer self)
{
	files_abstract_directory_view_after_new_file_added ((FilesAbstractDirectoryView*) self, file);
}

static void
files_abstract_directory_view_after_new_file_added (FilesAbstractDirectoryView* self,
                                                    FilesFile* file)
{
	FilesViewSlot* _tmp0_;
	FilesDirectory* _tmp1_;
	FilesDirectory* _tmp2_;
	guint _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->slot;
	_tmp1_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp0_);
	_tmp2_ = _tmp1_;
	g_signal_parse_name ("file-added", FILES_TYPE_DIRECTORY, &_tmp3_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp2_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp3_, 0, NULL, (GCallback) _files_abstract_directory_view_after_new_file_added_files_directory_file_added, self);
	if (file != NULL) {
		files_abstract_directory_view_rename_file (self, file);
	}
}

void
files_abstract_directory_view_rename_file (FilesAbstractDirectoryView* self,
                                           FilesFile* file_to_rename)
{
	gboolean _tmp0_;
	gboolean _tmp3_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file_to_rename != NULL);
	_tmp0_ = self->priv->_renaming;
	if (_tmp0_) {
		const gchar* _tmp1_;
		const gchar* _tmp2_;
		_tmp1_ = files_file_get_basename (file_to_rename);
		_tmp2_ = _tmp1_;
		g_warning ("AbstractDirectoryView.vala:1013: already renaming %s", _tmp2_);
		return;
	}
	if (self->is_writable) {
		_tmp3_ = TRUE;
	} else {
		FilesViewSlot* _tmp4_;
		FilesDirectory* _tmp5_;
		FilesDirectory* _tmp6_;
		gboolean _tmp7_;
		gboolean _tmp8_;
		_tmp4_ = self->slot;
		_tmp5_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp4_);
		_tmp6_ = _tmp5_;
		_tmp7_ = files_directory_get_is_local (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp3_ = !_tmp8_;
	}
	if (_tmp3_) {
		files_abstract_directory_view_start_renaming_file (self, file_to_rename);
	} else {
		g_warning ("AbstractDirectoryView.vala:1021: You do not have permission to rename " \
"this file");
	}
}

/** File operation callbacks */
void
files_abstract_directory_view_create_file_done (GFile* new_file,
                                                FilesAbstractDirectoryView* self)
{
	FilesViewSlot* _tmp0_;
	FilesDirectory* _tmp1_;
	FilesDirectory* _tmp2_;
	g_return_if_fail (self != NULL);
	if (new_file == NULL) {
		return;
	}
	_tmp0_ = self->slot;
	_tmp1_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp0_);
	_tmp2_ = _tmp1_;
	g_signal_connect_object (_tmp2_, "file-added", (GCallback) _files_abstract_directory_view_after_new_file_added_files_directory_file_added, self, G_CONNECT_AFTER);
	files_abstract_directory_view_unblock_directory_monitor (self);
}

static gboolean
__lambda61_ (FilesAbstractDirectoryView* self)
{
	GtkTreePath* _tmp0_;
	gboolean result;
	_tmp0_ = self->priv->deleted_path;
	files_abstract_directory_view_set_cursor (self, _tmp0_, FALSE, FALSE, FALSE);
	files_abstract_directory_view_unblock_directory_monitor (self);
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
___lambda61__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda61_ ((FilesAbstractDirectoryView*) self);
	return result;
}

void
files_abstract_directory_view_after_trash_or_delete (FilesAbstractDirectoryView* self)
{
	g_return_if_fail (self != NULL);
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ___lambda61__gsource_func, g_object_ref (self), g_object_unref);
}

static gboolean
__lambda62_ (FilesAbstractDirectoryView* self)
{
	FilesViewSlot* _tmp0_;
	FilesDirectory* _tmp1_;
	FilesDirectory* _tmp2_;
	gboolean result;
	_tmp0_ = self->slot;
	_tmp1_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp0_);
	_tmp2_ = _tmp1_;
	files_directory_unblock_monitor (_tmp2_);
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
___lambda62__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda62_ ((FilesAbstractDirectoryView*) self);
	return result;
}

static void
files_abstract_directory_view_unblock_directory_monitor (FilesAbstractDirectoryView* self)
{
	g_return_if_fail (self != NULL);
	g_idle_add_full (G_PRIORITY_LOW, ___lambda62__gsource_func, g_object_ref (self), g_object_unref);
}

static void
files_abstract_directory_view_trash_or_delete_selected_files (FilesAbstractDirectoryView* self,
                                                              gboolean delete_immediately)
{
	GList* selection = NULL;
	GList* _tmp0_;
	GList* _tmp1_;
	GList* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = files_abstract_directory_view_get_selected_files (self);
	_tmp1_ = files_abstract_directory_view_get_selected_files_for_transfer (self, _tmp0_);
	selection = _tmp1_;
	_tmp2_ = selection;
	if (_tmp2_ != NULL) {
		GList* _tmp3_;
		_tmp3_ = selection;
		files_abstract_directory_view_trash_or_delete_files (self, _tmp3_, TRUE, delete_immediately);
	}
	(selection == NULL) ? NULL : (selection = (_g_list_free__g_object_unref0_ (selection), NULL));
}

/** Selection actions */
static void
files_abstract_directory_view_on_selection_action_view_in_location (FilesAbstractDirectoryView* self,
                                                                    GSimpleAction* action,
                                                                    GVariant* param)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	files_abstract_directory_view_view_selected_file (self);
}

static void
files_abstract_directory_view_view_selected_file (FilesAbstractDirectoryView* self)
{
	GList* _tmp0_;
	GList* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->selected_files;
	if (_tmp0_ == NULL) {
		return;
	}
	_tmp1_ = self->selected_files;
	{
		GList* file_collection = NULL;
		GList* file_it = NULL;
		file_collection = _tmp1_;
		for (file_it = file_collection; file_it != NULL; file_it = file_it->next) {
			FilesFile* _tmp2_;
			FilesFile* file = NULL;
			_tmp2_ = _g_object_ref0 ((FilesFile*) file_it->data);
			file = _tmp2_;
			{
				GFile* loc = NULL;
				FilesFile* _tmp3_;
				gchar* _tmp4_;
				gchar* _tmp5_;
				GFile* _tmp6_;
				GFile* _tmp7_;
				GFile* _tmp8_;
				_tmp3_ = file;
				_tmp4_ = files_file_get_display_target_uri (_tmp3_);
				_tmp5_ = _tmp4_;
				_tmp6_ = g_file_new_for_uri (_tmp5_);
				_tmp7_ = _tmp6_;
				_g_free0 (_tmp5_);
				loc = _tmp7_;
				_tmp8_ = loc;
				g_signal_emit (self, files_abstract_directory_view_signals[FILES_ABSTRACT_DIRECTORY_VIEW_PATH_CHANGE_REQUEST_SIGNAL], 0, _tmp8_, FILES_OPEN_FLAG_NEW_TAB, TRUE);
				_g_object_unref0 (loc);
				_g_object_unref0 (file);
			}
		}
	}
}

static void
files_abstract_directory_view_on_selection_action_forget (FilesAbstractDirectoryView* self,
                                                          GSimpleAction* action,
                                                          GVariant* param)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	files_abstract_directory_view_forget_selected_file (self);
}

static void
files_abstract_directory_view_forget_selected_file (FilesAbstractDirectoryView* self)
{
	GList* _tmp0_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->selected_files;
	if (_tmp0_ == NULL) {
		return;
	}
	{
		GList* _tmp1_;
		_tmp1_ = self->selected_files;
		{
			GList* file_collection = NULL;
			GList* file_it = NULL;
			file_collection = _tmp1_;
			for (file_it = file_collection; file_it != NULL; file_it = file_it->next) {
				FilesFile* _tmp2_;
				FilesFile* file = NULL;
				_tmp2_ = _g_object_ref0 ((FilesFile*) file_it->data);
				file = _tmp2_;
				{
					GtkRecentManager* _tmp3_;
					FilesFile* _tmp4_;
					gchar* _tmp5_;
					gchar* _tmp6_;
					_tmp3_ = self->recent;
					_tmp4_ = file;
					_tmp5_ = files_file_get_display_target_uri (_tmp4_);
					_tmp6_ = _tmp5_;
					gtk_recent_manager_remove_item (_tmp3_, _tmp6_, &_inner_error0_);
					_g_free0 (_tmp6_);
					if (G_UNLIKELY (_inner_error0_ != NULL)) {
						_g_object_unref0 (file);
						goto __catch0_g_error;
					}
					_g_object_unref0 (file);
				}
			}
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* err = NULL;
		GError* _tmp7_;
		const gchar* _tmp8_;
		err = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp7_ = err;
		_tmp8_ = _tmp7_->message;
		g_critical ("AbstractDirectoryView.vala:1101: %s", _tmp8_);
		_g_error_free0 (err);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

static void
files_abstract_directory_view_on_selection_action_rename (FilesAbstractDirectoryView* self,
                                                          GSimpleAction* action,
                                                          GVariant* param)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	files_abstract_directory_view_rename_selected_file (self);
}

static void
files_abstract_directory_view_rename_selected_file (FilesAbstractDirectoryView* self)
{
	GList* _tmp0_;
	GList* _tmp1_;
	GList* _tmp2_;
	GList* _tmp3_;
	GList* _tmp4_;
	gconstpointer _tmp5_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->selected_files;
	if (_tmp0_ == NULL) {
		return;
	}
	_tmp1_ = self->selected_files;
	_tmp2_ = _tmp1_->next;
	if (_tmp2_ != NULL) {
		g_warning ("AbstractDirectoryView.vala:1115: Cannot rename multiple files (yet) - " \
"renaming first only");
	}
	_tmp3_ = self->selected_files;
	_tmp4_ = g_list_first (_tmp3_);
	_tmp5_ = _tmp4_->data;
	files_abstract_directory_view_rename_file (self, (FilesFile*) _tmp5_);
}

static void
files_abstract_directory_view_on_selection_action_cut (FilesAbstractDirectoryView* self,
                                                       GSimpleAction* action,
                                                       GVariant* param)
{
	GList* selection = NULL;
	GList* _tmp0_;
	GList* _tmp1_;
	FilesClipboardManager* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = files_abstract_directory_view_get_selected_files (self);
	_tmp1_ = files_abstract_directory_view_get_selected_files_for_transfer (self, _tmp0_);
	selection = _tmp1_;
	_tmp2_ = self->priv->clipboard;
	files_clipboard_manager_cut_files (_tmp2_, selection);
	(selection == NULL) ? NULL : (selection = (_g_list_free__g_object_unref0_ (selection), NULL));
}

static void
files_abstract_directory_view_on_selection_action_trash (FilesAbstractDirectoryView* self,
                                                         GSimpleAction* action,
                                                         GVariant* param)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	files_abstract_directory_view_trash_or_delete_selected_files (self, files_is_admin ());
}

static void
files_abstract_directory_view_on_selection_action_delete (FilesAbstractDirectoryView* self,
                                                          GSimpleAction* action,
                                                          GVariant* param)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	files_abstract_directory_view_trash_or_delete_selected_files (self, TRUE);
}

static void
files_abstract_directory_view_on_selection_action_restore (FilesAbstractDirectoryView* self,
                                                           GSimpleAction* action,
                                                           GVariant* param)
{
	GList* selection = NULL;
	GList* _tmp0_;
	GList* _tmp1_;
	FilesViewWindow* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = files_abstract_directory_view_get_selected_files (self);
	_tmp1_ = files_abstract_directory_view_get_selected_files_for_transfer (self, _tmp0_);
	selection = _tmp1_;
	_tmp2_ = self->window;
	files_file_utils_restore_files_from_trash (selection, (GtkWidget*) _tmp2_);
	(selection == NULL) ? NULL : (selection = (_g_list_free__g_object_unref0_ (selection), NULL));
}

static void
files_abstract_directory_view_on_selection_action_open_executable (FilesAbstractDirectoryView* self,
                                                                   GSimpleAction* action,
                                                                   GVariant* param)
{
	GList* selection = NULL;
	GList* _tmp0_;
	FilesFile* file = NULL;
	gconstpointer _tmp1_;
	FilesFile* _tmp2_;
	FilesFile* _tmp3_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = files_abstract_directory_view_get_files_for_action (self);
	selection = _tmp0_;
	_tmp1_ = selection->data;
	_tmp2_ = (FilesFile*) _tmp1_;
	_tmp3_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, FILES_TYPE_FILE) ? ((FilesFile*) _tmp2_) : NULL);
	file = _tmp3_;
	{
		files_file_execute (file, NULL, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp4_;
		const gchar* _tmp5_;
		FilesViewWindow* _tmp6_;
		GraniteMessageDialog* _tmp7_;
		GraniteMessageDialog* _tmp8_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		_tmp6_ = self->window;
		_tmp7_ = pf_dialogs_show_warning_dialog (_ ("Cannot execute this file"), _tmp5_, (GtkWindow*) _tmp6_);
		_tmp8_ = _tmp7_;
		_g_object_unref0 (_tmp8_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_object_unref0 (file);
		(selection == NULL) ? NULL : (selection = (_g_list_free__g_object_unref0_ (selection), NULL));
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_g_object_unref0 (file);
	(selection == NULL) ? NULL : (selection = (_g_list_free__g_object_unref0_ (selection), NULL));
}

static void
files_abstract_directory_view_on_selection_action_open_with_default (FilesAbstractDirectoryView* self,
                                                                     GSimpleAction* action,
                                                                     GVariant* param)
{
	GList* _tmp0_;
	GList* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = files_abstract_directory_view_get_files_for_action (self);
	_tmp1_ = _tmp0_;
	files_abstract_directory_view_activate_selected_items (self, FILES_OPEN_FLAG_APP, _tmp1_);
	(_tmp1_ == NULL) ? NULL : (_tmp1_ = (_g_list_free__g_object_unref0_ (_tmp1_), NULL));
}

static void
files_abstract_directory_view_on_selection_action_open_with_app (FilesAbstractDirectoryView* self,
                                                                 GSimpleAction* action,
                                                                 GVariant* param)
{
	GList* _tmp0_;
	gconstpointer _tmp1_;
	GList* _tmp2_;
	GList* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = self->priv->open_with_apps;
	_tmp1_ = g_list_nth_data (_tmp0_, (guint) g_variant_get_uint32 (param));
	_tmp2_ = files_abstract_directory_view_get_files_for_action (self);
	_tmp3_ = _tmp2_;
	files_abstract_directory_view_open_files_with (self, (GAppInfo*) _tmp1_, _tmp3_);
	(_tmp3_ == NULL) ? NULL : (_tmp3_ = (_g_list_free__g_object_unref0_ (_tmp3_), NULL));
}

static void
files_abstract_directory_view_on_selection_action_open_with_other_app (FilesAbstractDirectoryView* self)
{
	GList* selection = NULL;
	GList* _tmp0_;
	FilesFile* file = NULL;
	gconstpointer _tmp1_;
	FilesFile* _tmp2_;
	FilesFile* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = files_abstract_directory_view_get_files_for_action (self);
	selection = _tmp0_;
	_tmp1_ = selection->data;
	_tmp2_ = (FilesFile*) _tmp1_;
	_tmp3_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, FILES_TYPE_FILE) ? ((FilesFile*) _tmp2_) : NULL);
	file = _tmp3_;
	files_abstract_directory_view_open_file (self, file, NULL, NULL);
	_g_object_unref0 (file);
	(selection == NULL) ? NULL : (selection = (_g_list_free__g_object_unref0_ (selection), NULL));
}

static void
files_abstract_directory_view_on_common_action_bookmark (FilesAbstractDirectoryView* self,
                                                         GSimpleAction* action,
                                                         GVariant* param)
{
	GFile* location = NULL;
	GList* _tmp0_;
	FilesViewWindow* _tmp12_;
	GFile* _tmp13_;
	gchar* _tmp14_;
	gchar* _tmp15_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = self->selected_files;
	if (_tmp0_ != NULL) {
		GList* _tmp1_;
		gconstpointer _tmp2_;
		GFile* _tmp3_;
		GFile* _tmp4_;
		_tmp1_ = self->selected_files;
		_tmp2_ = _tmp1_->data;
		_tmp3_ = files_file_get_target_location ((FilesFile*) _tmp2_);
		_tmp4_ = _g_object_ref0 (_tmp3_);
		_g_object_unref0 (location);
		location = _tmp4_;
	} else {
		FilesViewSlot* _tmp5_;
		FilesDirectory* _tmp6_;
		FilesDirectory* _tmp7_;
		FilesFile* _tmp8_;
		FilesFile* _tmp9_;
		GFile* _tmp10_;
		GFile* _tmp11_;
		_tmp5_ = self->slot;
		_tmp6_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp5_);
		_tmp7_ = _tmp6_;
		_tmp8_ = files_directory_get_file (_tmp7_);
		_tmp9_ = _tmp8_;
		_tmp10_ = files_file_get_target_location (_tmp9_);
		_tmp11_ = _g_object_ref0 (_tmp10_);
		_g_object_unref0 (location);
		location = _tmp11_;
	}
	_tmp12_ = self->window;
	_tmp13_ = location;
	_tmp14_ = g_file_get_uri (_tmp13_);
	_tmp15_ = _tmp14_;
	files_view_window_bookmark_uri (_tmp12_, _tmp15_, "");
	_g_free0 (_tmp15_);
	_g_object_unref0 (location);
}

/** Background actions */
static void
files_abstract_directory_view_change_state_show_hidden (FilesAbstractDirectoryView* self,
                                                        GSimpleAction* action)
{
	FilesViewWindow* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = self->window;
	files_view_window_change_state_show_hidden (_tmp0_, action);
}

static void
files_abstract_directory_view_change_state_show_remote_thumbnails (FilesAbstractDirectoryView* self,
                                                                   GSimpleAction* action)
{
	FilesViewWindow* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = self->window;
	files_view_window_change_state_show_remote_thumbnails (_tmp0_, action);
}

static void
files_abstract_directory_view_change_state_show_local_thumbnails (FilesAbstractDirectoryView* self,
                                                                  GSimpleAction* action)
{
	FilesViewWindow* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = self->window;
	files_view_window_change_state_show_local_thumbnails (_tmp0_, action);
}

static void
files_abstract_directory_view_on_background_action_new (FilesAbstractDirectoryView* self,
                                                        GSimpleAction* action,
                                                        GVariant* param)
{
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	GQuark _tmp3_ = 0U;
	static GQuark _tmp2_label0 = 0;
	static GQuark _tmp2_label1 = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = g_variant_get_string (param, NULL);
	_tmp1_ = _tmp0_;
	_tmp3_ = (NULL == _tmp1_) ? 0 : g_quark_from_string (_tmp1_);
	if (_tmp3_ == ((0 != _tmp2_label0) ? _tmp2_label0 : (_tmp2_label0 = g_quark_from_static_string ("FOLDER")))) {
		switch (0) {
			default:
			{
				files_abstract_directory_view_new_empty_folder (self);
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label1) ? _tmp2_label1 : (_tmp2_label1 = g_quark_from_static_string ("FILE")))) {
		switch (0) {
			default:
			{
				files_abstract_directory_view_new_empty_file (self, NULL);
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				break;
			}
		}
	}
}

static void
files_abstract_directory_view_on_background_action_create_from (FilesAbstractDirectoryView* self,
                                                                GSimpleAction* action,
                                                                GVariant* param)
{
	gint index = 0;
	const gchar* _tmp0_;
	GList* _tmp1_;
	gconstpointer _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = g_variant_get_string (param, NULL);
	index = atoi (_tmp0_);
	_tmp1_ = files_abstract_directory_view_templates;
	_tmp2_ = g_list_nth_data (_tmp1_, (guint) index);
	files_abstract_directory_view_create_from_template (self, (GFile*) _tmp2_);
}

static void
files_abstract_directory_view_on_background_action_sort_by_changed (FilesAbstractDirectoryView* self,
                                                                    GSimpleAction* action,
                                                                    GVariant* val)
{
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	if (val != NULL) {
		const gchar* _tmp1_;
		_tmp1_ = g_variant_get_string (val, NULL);
		_tmp0_ = _tmp1_;
	} else {
		_tmp0_ = NULL;
	}
	files_abstract_directory_view_set_sort (self, _tmp0_, FALSE);
}

static void
files_abstract_directory_view_on_background_action_reverse_changed (FilesAbstractDirectoryView* self,
                                                                    GSimpleAction* action,
                                                                    GVariant* val)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	files_abstract_directory_view_set_sort (self, NULL, TRUE);
}

static void
files_abstract_directory_view_on_background_action_folders_first_changed (FilesAbstractDirectoryView* self,
                                                                          GSimpleAction* action,
                                                                          GVariant* val)
{
	FilesPreferences* prefs = NULL;
	FilesPreferences* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = files_preferences_get_default ();
	prefs = _tmp0_;
	_tmp1_ = files_preferences_get_sort_directories_first (prefs);
	_tmp2_ = _tmp1_;
	files_preferences_set_sort_directories_first (prefs, !_tmp2_);
	_g_object_unref0 (prefs);
}

static void
files_abstract_directory_view_set_sort (FilesAbstractDirectoryView* self,
                                        const gchar* col_name,
                                        gboolean reverse)
{
	gint sort_column_id = 0;
	GtkSortType sort_order = 0;
	FilesListModel* _tmp0_;
	gint _tmp1_ = 0;
	GtkSortType _tmp2_ = 0;
	gboolean _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->model;
	_tmp3_ = gtk_tree_sortable_get_sort_column_id ((GtkTreeSortable*) _tmp0_, &_tmp1_, &_tmp2_);
	sort_column_id = _tmp1_;
	sort_order = _tmp2_;
	if (_tmp3_) {
		FilesListModel* _tmp4_;
		if (col_name != NULL) {
			sort_column_id = (gint) files_list_model_column_id_from_string (col_name);
		}
		if (reverse) {
			if (sort_order == GTK_SORT_ASCENDING) {
				sort_order = GTK_SORT_DESCENDING;
			} else {
				sort_order = GTK_SORT_ASCENDING;
			}
		}
		_tmp4_ = self->model;
		gtk_tree_sortable_set_sort_column_id ((GtkTreeSortable*) _tmp4_, sort_column_id, sort_order);
	} else {
		g_warning ("AbstractDirectoryView.vala:1243: Set Sort: The model is unsorted - thi" \
"s should not happen");
	}
}

/** Common actions */
static void
files_abstract_directory_view_on_common_action_open_in (FilesAbstractDirectoryView* self,
                                                        GSimpleAction* action,
                                                        GVariant* param)
{
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	GQuark _tmp3_ = 0U;
	static GQuark _tmp2_label0 = 0;
	static GQuark _tmp2_label1 = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_g_object_unref0 (self->priv->default_app);
	self->priv->default_app = NULL;
	_tmp0_ = g_variant_get_string (param, NULL);
	_tmp1_ = _tmp0_;
	_tmp3_ = (NULL == _tmp1_) ? 0 : g_quark_from_string (_tmp1_);
	if (_tmp3_ == ((0 != _tmp2_label0) ? _tmp2_label0 : (_tmp2_label0 = g_quark_from_static_string ("TAB")))) {
		switch (0) {
			default:
			{
				GList* _tmp4_;
				GList* _tmp5_;
				_tmp4_ = files_abstract_directory_view_get_files_for_action (self);
				_tmp5_ = _tmp4_;
				files_abstract_directory_view_activate_selected_items (self, FILES_OPEN_FLAG_NEW_TAB, _tmp5_);
				(_tmp5_ == NULL) ? NULL : (_tmp5_ = (_g_list_free__g_object_unref0_ (_tmp5_), NULL));
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label1) ? _tmp2_label1 : (_tmp2_label1 = g_quark_from_static_string ("WINDOW")))) {
		switch (0) {
			default:
			{
				GList* _tmp6_;
				GList* _tmp7_;
				_tmp6_ = files_abstract_directory_view_get_files_for_action (self);
				_tmp7_ = _tmp6_;
				files_abstract_directory_view_activate_selected_items (self, FILES_OPEN_FLAG_NEW_WINDOW, _tmp7_);
				(_tmp7_ == NULL) ? NULL : (_tmp7_ = (_g_list_free__g_object_unref0_ (_tmp7_), NULL));
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				break;
			}
		}
	}
}

static void
files_abstract_directory_view_on_common_action_properties (FilesAbstractDirectoryView* self,
                                                           GSimpleAction* action,
                                                           GVariant* param)
{
	GList* _tmp0_;
	GList* _tmp1_;
	FilesViewWindow* _tmp2_;
	FilesViewPropertiesWindow* _tmp3_;
	FilesViewPropertiesWindow* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = files_abstract_directory_view_get_files_for_action (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->window;
	_tmp3_ = files_view_properties_window_new (_tmp1_, self, (GtkWindow*) _tmp2_);
	g_object_ref_sink (_tmp3_);
	_tmp4_ = _tmp3_;
	_g_object_unref0 (_tmp4_);
	(_tmp1_ == NULL) ? NULL : (_tmp1_ = (_g_list_free__g_object_unref0_ (_tmp1_), NULL));
}

static void
files_abstract_directory_view_on_common_action_copy_link (FilesAbstractDirectoryView* self,
                                                          GSimpleAction* action,
                                                          GVariant* param)
{
	FilesClipboardManager* _tmp0_;
	GList* _tmp1_;
	GList* _tmp2_;
	GList* _tmp3_;
	GList* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = self->priv->clipboard;
	_tmp1_ = files_abstract_directory_view_get_files_for_action (self);
	_tmp2_ = _tmp1_;
	_tmp3_ = files_abstract_directory_view_get_selected_files_for_transfer (self, _tmp2_);
	_tmp4_ = _tmp3_;
	files_clipboard_manager_copy_link_files (_tmp0_, _tmp4_);
	(_tmp4_ == NULL) ? NULL : (_tmp4_ = (_g_list_free__g_object_unref0_ (_tmp4_), NULL));
	(_tmp2_ == NULL) ? NULL : (_tmp2_ = (_g_list_free__g_object_unref0_ (_tmp2_), NULL));
}

static void
files_abstract_directory_view_on_common_action_copy (FilesAbstractDirectoryView* self,
                                                     GSimpleAction* action,
                                                     GVariant* param)
{
	FilesClipboardManager* _tmp0_;
	GList* _tmp1_;
	GList* _tmp2_;
	GList* _tmp3_;
	GList* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = self->priv->clipboard;
	_tmp1_ = files_abstract_directory_view_get_files_for_action (self);
	_tmp2_ = _tmp1_;
	_tmp3_ = files_abstract_directory_view_get_selected_files_for_transfer (self, _tmp2_);
	_tmp4_ = _tmp3_;
	files_clipboard_manager_copy_files (_tmp0_, _tmp4_);
	(_tmp4_ == NULL) ? NULL : (_tmp4_ = (_g_list_free__g_object_unref0_ (_tmp4_), NULL));
	(_tmp2_ == NULL) ? NULL : (_tmp2_ = (_g_list_free__g_object_unref0_ (_tmp2_), NULL));
}

static Block19Data*
block19_data_ref (Block19Data* _data19_)
{
	g_atomic_int_inc (&_data19_->_ref_count_);
	return _data19_;
}

static void
block19_data_unref (void * _userdata_)
{
	Block19Data* _data19_;
	_data19_ = (Block19Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data19_->_ref_count_)) {
		FilesAbstractDirectoryView* self;
		self = _data19_->self;
		_g_object_unref0 (_data19_->target);
		_g_object_unref0 (self);
		g_slice_free (Block19Data, _data19_);
	}
}

static void
___lambda112_ (Block19Data* _data19_,
               GObject* obj,
               GAsyncResult* res)
{
	FilesAbstractDirectoryView* self;
	FilesClipboardManager* _tmp0_;
	GFile* _tmp1_;
	self = _data19_->self;
	g_return_if_fail (res != NULL);
	_tmp0_ = self->priv->clipboard;
	files_clipboard_manager_paste_files_finish (_tmp0_, res);
	_tmp1_ = _data19_->target;
	if (g_file_has_uri_scheme (_tmp1_, "trash")) {
		files_abstract_directory_view_after_trash_or_delete (self);
	}
}

static void
____lambda112__gasync_ready_callback (GObject* source_object,
                                      GAsyncResult* res,
                                      gpointer self)
{
	___lambda112_ (self, source_object, res);
	block19_data_unref (self);
}

static void
files_abstract_directory_view_on_common_action_paste (FilesAbstractDirectoryView* self,
                                                      GSimpleAction* action,
                                                      GVariant* param)
{
	gboolean _tmp0_ = FALSE;
	FilesClipboardManager* _tmp1_;
	gboolean _tmp2_;
	gboolean _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp1_ = self->priv->clipboard;
	_tmp2_ = files_clipboard_manager_get_can_paste (_tmp1_);
	_tmp3_ = _tmp2_;
	if (_tmp3_) {
		gboolean _tmp4_ = FALSE;
		FilesClipboardManager* _tmp5_;
		gboolean _tmp6_;
		gboolean _tmp7_;
		_tmp5_ = self->priv->clipboard;
		_tmp6_ = files_clipboard_manager_get_files_linked (_tmp5_);
		_tmp7_ = _tmp6_;
		if (_tmp7_) {
			_tmp4_ = self->priv->in_trash;
		} else {
			_tmp4_ = FALSE;
		}
		_tmp0_ = !_tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		Block19Data* _data19_;
		FilesViewSlot* _tmp8_;
		GFile* _tmp9_;
		GFile* _tmp10_;
		GFile* _tmp11_;
		FilesClipboardManager* _tmp12_;
		GFile* _tmp13_;
		_data19_ = g_slice_new0 (Block19Data);
		_data19_->_ref_count_ = 1;
		_data19_->self = g_object_ref (self);
		_tmp8_ = self->slot;
		_tmp9_ = files_abstract_slot_get_location ((FilesAbstractSlot*) _tmp8_);
		_tmp10_ = _tmp9_;
		_tmp11_ = _g_object_ref0 (_tmp10_);
		_data19_->target = _tmp11_;
		_tmp12_ = self->priv->clipboard;
		_tmp13_ = _data19_->target;
		files_clipboard_manager_paste_files (_tmp12_, _tmp13_, G_TYPE_CHECK_INSTANCE_TYPE (self, gtk_widget_get_type ()) ? ((GtkWidget*) self) : NULL, ____lambda112__gasync_ready_callback, block19_data_ref (_data19_));
		block19_data_unref (_data19_);
		_data19_ = NULL;
	}
}

static Block20Data*
block20_data_ref (Block20Data* _data20_)
{
	g_atomic_int_inc (&_data20_->_ref_count_);
	return _data20_;
}

static void
block20_data_unref (void * _userdata_)
{
	Block20Data* _data20_;
	_data20_ = (Block20Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data20_->_ref_count_)) {
		FilesAbstractDirectoryView* self;
		self = _data20_->self;
		_g_object_unref0 (_data20_->target);
		_g_object_unref0 (self);
		g_slice_free (Block20Data, _data20_);
	}
}

static void
___lambda111_ (Block20Data* _data20_,
               GObject* obj,
               GAsyncResult* res)
{
	FilesAbstractDirectoryView* self;
	FilesClipboardManager* _tmp0_;
	GFile* _tmp1_;
	self = _data20_->self;
	g_return_if_fail (res != NULL);
	_tmp0_ = self->priv->clipboard;
	files_clipboard_manager_paste_files_finish (_tmp0_, res);
	_tmp1_ = _data20_->target;
	if (g_file_has_uri_scheme (_tmp1_, "trash")) {
		files_abstract_directory_view_after_trash_or_delete (self);
	}
}

static void
____lambda111__gasync_ready_callback (GObject* source_object,
                                      GAsyncResult* res,
                                      gpointer self)
{
	___lambda111_ (self, source_object, res);
	block20_data_unref (self);
}

static void
files_abstract_directory_view_on_common_action_paste_into (FilesAbstractDirectoryView* self,
                                                           GSimpleAction* action,
                                                           GVariant* param)
{
	FilesFile* file = NULL;
	GList* _tmp0_;
	GList* _tmp1_;
	gconstpointer _tmp2_;
	FilesFile* _tmp3_;
	FilesFile* _tmp4_;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	FilesFile* _tmp7_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = files_abstract_directory_view_get_files_for_action (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_list_nth_data (_tmp1_, (guint) 0);
	_tmp3_ = _g_object_ref0 ((FilesFile*) _tmp2_);
	_tmp4_ = _tmp3_;
	(_tmp1_ == NULL) ? NULL : (_tmp1_ = (_g_list_free__g_object_unref0_ (_tmp1_), NULL));
	file = _tmp4_;
	_tmp7_ = file;
	if (_tmp7_ != NULL) {
		FilesClipboardManager* _tmp8_;
		gboolean _tmp9_;
		gboolean _tmp10_;
		_tmp8_ = self->priv->clipboard;
		_tmp9_ = files_clipboard_manager_get_can_paste (_tmp8_);
		_tmp10_ = _tmp9_;
		_tmp6_ = _tmp10_;
	} else {
		_tmp6_ = FALSE;
	}
	if (_tmp6_) {
		gboolean _tmp11_ = FALSE;
		FilesClipboardManager* _tmp12_;
		gboolean _tmp13_;
		gboolean _tmp14_;
		_tmp12_ = self->priv->clipboard;
		_tmp13_ = files_clipboard_manager_get_files_linked (_tmp12_);
		_tmp14_ = _tmp13_;
		if (_tmp14_) {
			_tmp11_ = self->priv->in_trash;
		} else {
			_tmp11_ = FALSE;
		}
		_tmp5_ = !_tmp11_;
	} else {
		_tmp5_ = FALSE;
	}
	if (_tmp5_) {
		Block20Data* _data20_;
		gboolean _tmp15_ = FALSE;
		FilesFile* _tmp16_;
		FilesClipboardManager* _tmp26_;
		GFile* _tmp27_;
		_data20_ = g_slice_new0 (Block20Data);
		_data20_->_ref_count_ = 1;
		_data20_->self = g_object_ref (self);
		_tmp16_ = file;
		if (files_file_is_folder (_tmp16_)) {
			FilesClipboardManager* _tmp17_;
			FilesFile* _tmp18_;
			_tmp17_ = self->priv->clipboard;
			_tmp18_ = file;
			_tmp15_ = !files_clipboard_manager_has_file (_tmp17_, _tmp18_);
		} else {
			_tmp15_ = FALSE;
		}
		if (_tmp15_) {
			FilesFile* _tmp19_;
			GFile* _tmp20_;
			GFile* _tmp21_;
			_tmp19_ = file;
			_tmp20_ = files_file_get_target_location (_tmp19_);
			_tmp21_ = _g_object_ref0 (_tmp20_);
			_g_object_unref0 (_data20_->target);
			_data20_->target = _tmp21_;
		} else {
			FilesViewSlot* _tmp22_;
			GFile* _tmp23_;
			GFile* _tmp24_;
			GFile* _tmp25_;
			_tmp22_ = self->slot;
			_tmp23_ = files_abstract_slot_get_location ((FilesAbstractSlot*) _tmp22_);
			_tmp24_ = _tmp23_;
			_tmp25_ = _g_object_ref0 (_tmp24_);
			_g_object_unref0 (_data20_->target);
			_data20_->target = _tmp25_;
		}
		_tmp26_ = self->priv->clipboard;
		_tmp27_ = _data20_->target;
		files_clipboard_manager_paste_files (_tmp26_, _tmp27_, G_TYPE_CHECK_INSTANCE_TYPE (self, gtk_widget_get_type ()) ? ((GtkWidget*) self) : NULL, ____lambda111__gasync_ready_callback, block20_data_ref (_data20_));
		block20_data_unref (_data20_);
		_data20_ = NULL;
	}
	_g_object_unref0 (file);
}

static void
files_abstract_directory_view_toggle_select_all (FilesAbstractDirectoryView* self)
{
	g_return_if_fail (self != NULL);
	files_abstract_directory_view_update_selected_files_and_menu (self);
	if (self->priv->all_selected) {
		files_abstract_directory_view_unselect_all (self);
	} else {
		files_abstract_directory_view_select_all (self);
	}
}

static void
files_abstract_directory_view_on_directory_file_added (FilesAbstractDirectoryView* self,
                                                       FilesDirectory* dir,
                                                       FilesFile* file)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	if (file != NULL) {
		files_abstract_directory_view_add_file (self, file, dir, TRUE);
		files_abstract_directory_view_handle_free_space_change (self);
	} else {
		g_critical ("AbstractDirectoryView.vala:1327: Null file added");
	}
}

static void
files_abstract_directory_view_on_directory_file_loaded (FilesAbstractDirectoryView* self,
                                                        FilesDirectory* dir,
                                                        FilesFile* file)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	g_return_if_fail (file != NULL);
	files_abstract_directory_view_add_file (self, file, dir, FALSE);
}

static void
files_abstract_directory_view_on_directory_file_changed (FilesAbstractDirectoryView* self,
                                                         FilesDirectory* dir,
                                                         FilesFile* file)
{
	GFile* _tmp0_;
	GFile* _tmp1_;
	FilesFile* _tmp2_;
	FilesFile* _tmp3_;
	GFile* _tmp4_;
	GFile* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	g_return_if_fail (file != NULL);
	_tmp0_ = files_file_get_location (file);
	_tmp1_ = _tmp0_;
	_tmp2_ = files_directory_get_file (dir);
	_tmp3_ = _tmp2_;
	_tmp4_ = files_file_get_location (_tmp3_);
	_tmp5_ = _tmp4_;
	if (g_file_equal (_tmp1_, _tmp5_)) {
		FilesViewSlot* _tmp6_;
		FilesDirectory* _tmp7_;
		FilesDirectory* _tmp8_;
		FilesFile* _tmp9_;
		FilesFile* _tmp10_;
		_tmp6_ = self->slot;
		_tmp7_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = files_directory_get_file (_tmp8_);
		_tmp10_ = _tmp9_;
		self->is_writable = files_file_is_writable (_tmp10_);
	} else {
		FilesListModel* _tmp11_;
		gboolean _tmp12_ = FALSE;
		gboolean _tmp13_ = FALSE;
		FilesViewSlot* _tmp14_;
		FilesDirectory* _tmp15_;
		FilesDirectory* _tmp16_;
		gboolean _tmp17_;
		gboolean _tmp18_;
		files_abstract_directory_view_remove_marlin_icon_info_cache (self, file);
		_tmp11_ = self->model;
		files_list_model_file_changed (_tmp11_, file, dir);
		_tmp14_ = self->slot;
		_tmp15_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp14_);
		_tmp16_ = _tmp15_;
		_tmp17_ = files_directory_get_is_network (_tmp16_);
		_tmp18_ = _tmp17_;
		if (!_tmp18_) {
			gboolean _tmp19_;
			_tmp19_ = self->priv->_show_local_thumbnails;
			_tmp13_ = _tmp19_;
		} else {
			_tmp13_ = FALSE;
		}
		if (_tmp13_) {
			_tmp12_ = TRUE;
		} else {
			gboolean _tmp20_ = FALSE;
			gboolean _tmp21_;
			_tmp21_ = self->priv->_show_remote_thumbnails;
			if (_tmp21_) {
				FilesViewSlot* _tmp22_;
				FilesDirectory* _tmp23_;
				FilesDirectory* _tmp24_;
				gboolean _tmp25_;
				gboolean _tmp26_;
				_tmp22_ = self->slot;
				_tmp23_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp22_);
				_tmp24_ = _tmp23_;
				_tmp25_ = files_directory_get_can_open_files (_tmp24_);
				_tmp26_ = _tmp25_;
				_tmp20_ = _tmp26_;
			} else {
				_tmp20_ = FALSE;
			}
			_tmp12_ = _tmp20_;
		}
		if (_tmp12_) {
			FilesThumbnailer* _tmp27_;
			FilesPluginManager* _tmp28_;
			_tmp27_ = self->priv->thumbnailer;
			files_thumbnailer_queue_file (_tmp27_, file, NULL, self->large_thumbnails);
			_tmp28_ = plugins;
			if (_tmp28_ != NULL) {
				FilesPluginManager* _tmp29_;
				_tmp29_ = plugins;
				files_plugin_manager_update_file_info (_tmp29_, file);
			}
		}
	}
	files_abstract_directory_view_draw_when_idle (self);
}

static void
files_abstract_directory_view_on_directory_file_icon_changed (FilesAbstractDirectoryView* self,
                                                              FilesDirectory* dir,
                                                              FilesFile* file)
{
	FilesListModel* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	g_return_if_fail (file != NULL);
	_tmp0_ = self->model;
	files_list_model_file_changed (_tmp0_, file, dir);
	files_abstract_directory_view_draw_when_idle (self);
}

static void
files_abstract_directory_view_on_directory_file_deleted (FilesAbstractDirectoryView* self,
                                                         FilesDirectory* dir,
                                                         FilesFile* file)
{
	FilesListModel* _tmp0_;
	const gchar* _tmp1_;
	FilesPluginManager* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	g_return_if_fail (file != NULL);
	file->exists = FALSE;
	_tmp0_ = self->model;
	files_list_model_remove_file (_tmp0_, file, dir);
	files_abstract_directory_view_remove_marlin_icon_info_cache (self, file);
	_tmp1_ = files_file_get_thumbnail_path (file);
	if (_tmp1_ != NULL) {
		const gchar* _tmp2_;
		const gchar* _tmp3_;
		_tmp2_ = files_file_get_uri (file);
		_tmp3_ = _tmp2_;
		files_file_utils_remove_thumbnail_paths_for_uri (_tmp3_);
	}
	_tmp4_ = plugins;
	if (_tmp4_ != NULL) {
		FilesPluginManager* _tmp5_;
		_tmp5_ = plugins;
		files_plugin_manager_update_file_info (_tmp5_, file);
	}
	if (files_file_is_folder (file)) {
		FilesDirectory* file_dir = NULL;
		GFile* _tmp6_;
		GFile* _tmp7_;
		FilesDirectory* _tmp8_;
		FilesDirectory* _tmp9_;
		_tmp6_ = files_file_get_location (file);
		_tmp7_ = _tmp6_;
		_tmp8_ = files_directory_cache_lookup (_tmp7_);
		file_dir = _tmp8_;
		_tmp9_ = file_dir;
		if (_tmp9_ != NULL) {
			FilesDirectory* _tmp10_;
			FilesViewSlot* _tmp11_;
			FilesDirectory* _tmp12_;
			_tmp10_ = file_dir;
			files_directory_purge_dir_from_cache (_tmp10_);
			_tmp11_ = self->slot;
			_tmp12_ = file_dir;
			g_signal_emit_by_name (_tmp11_, "folder-deleted", file, _tmp12_);
		}
		_g_object_unref0 (file_dir);
	}
	files_abstract_directory_view_handle_free_space_change (self);
}

static void
files_abstract_directory_view_on_directory_done_loading (FilesAbstractDirectoryView* self,
                                                         FilesDirectory* dir)
{
	FilesViewSlot* _tmp0_;
	FilesDirectory* _tmp1_;
	FilesDirectory* _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	FilesViewSlot* _tmp5_;
	FilesDirectory* _tmp6_;
	FilesDirectory* _tmp7_;
	gboolean _tmp8_;
	gboolean _tmp9_;
	FilesViewSlot* _tmp10_;
	FilesDirectory* _tmp11_;
	FilesDirectory* _tmp12_;
	FilesFile* _tmp13_;
	FilesFile* _tmp14_;
	FilesViewSlot* _tmp15_;
	FilesDirectory* _tmp16_;
	FilesDirectory* _tmp17_;
	gboolean _tmp18_;
	gboolean _tmp19_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	files_abstract_directory_view_disconnect_directory_loading_handlers (self, dir);
	_tmp0_ = self->slot;
	_tmp1_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = files_directory_get_is_trash (_tmp2_);
	_tmp4_ = _tmp3_;
	self->priv->in_trash = _tmp4_;
	_tmp5_ = self->slot;
	_tmp6_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = files_directory_get_is_recent (_tmp7_);
	_tmp9_ = _tmp8_;
	files_abstract_directory_view_set_in_recent (self, _tmp9_);
	_tmp10_ = self->slot;
	_tmp11_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp10_);
	_tmp12_ = _tmp11_;
	_tmp13_ = files_directory_get_file (_tmp12_);
	_tmp14_ = _tmp13_;
	self->priv->in_network_root = files_file_is_root_network_folder (_tmp14_);
	_tmp15_ = self->slot;
	_tmp16_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp15_);
	_tmp17_ = _tmp16_;
	_tmp18_ = files_directory_get_can_load (_tmp17_);
	_tmp19_ = _tmp18_;
	if (_tmp19_) {
		FilesViewSlot* _tmp20_;
		FilesDirectory* _tmp21_;
		FilesDirectory* _tmp22_;
		FilesFile* _tmp23_;
		FilesFile* _tmp24_;
		gboolean _tmp25_;
		_tmp20_ = self->slot;
		_tmp21_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp20_);
		_tmp22_ = _tmp21_;
		_tmp23_ = files_directory_get_file (_tmp22_);
		_tmp24_ = _tmp23_;
		self->is_writable = files_file_is_writable (_tmp24_);
		_tmp25_ = self->priv->_in_recent;
		if (_tmp25_) {
			FilesListModel* _tmp26_;
			_tmp26_ = self->model;
			gtk_tree_sortable_set_sort_column_id ((GtkTreeSortable*) _tmp26_, (gint) FILES_LIST_MODEL_COLUMN_ID_MODIFIED, GTK_SORT_DESCENDING);
		} else {
			FilesViewSlot* _tmp27_;
			FilesDirectory* _tmp28_;
			FilesDirectory* _tmp29_;
			FilesFile* _tmp30_;
			FilesFile* _tmp31_;
			GFileInfo* _tmp32_;
			_tmp27_ = self->slot;
			_tmp28_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp27_);
			_tmp29_ = _tmp28_;
			_tmp30_ = files_directory_get_file (_tmp29_);
			_tmp31_ = _tmp30_;
			_tmp32_ = _tmp31_->info;
			if (_tmp32_ != NULL) {
				FilesListModel* _tmp33_;
				FilesViewSlot* _tmp34_;
				FilesDirectory* _tmp35_;
				FilesDirectory* _tmp36_;
				FilesFile* _tmp37_;
				FilesFile* _tmp38_;
				FilesViewSlot* _tmp39_;
				FilesDirectory* _tmp40_;
				FilesDirectory* _tmp41_;
				FilesFile* _tmp42_;
				FilesFile* _tmp43_;
				_tmp33_ = self->model;
				_tmp34_ = self->slot;
				_tmp35_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp34_);
				_tmp36_ = _tmp35_;
				_tmp37_ = files_directory_get_file (_tmp36_);
				_tmp38_ = _tmp37_;
				_tmp39_ = self->slot;
				_tmp40_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp39_);
				_tmp41_ = _tmp40_;
				_tmp42_ = files_directory_get_file (_tmp41_);
				_tmp43_ = _tmp42_;
				gtk_tree_sortable_set_sort_column_id ((GtkTreeSortable*) _tmp33_, _tmp38_->sort_column_id, _tmp43_->sort_order);
			}
		}
	} else {
		self->is_writable = FALSE;
	}
	files_abstract_directory_view_thaw_tree (self);
	files_abstract_directory_view_schedule_thumbnail_color_tag_timeout (self);
}

/** Handle zoom level change */
static void
files_abstract_directory_view_on_zoom_level_changed (FilesAbstractDirectoryView* self,
                                                     FilesZoomLevel zoom)
{
	gint size = 0;
	gint _tmp0_;
	gint _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	FilesListModel* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	g_return_if_fail (self != NULL);
	_tmp0_ = files_abstract_directory_view_get_icon_size (self);
	_tmp1_ = _tmp0_;
	size = _tmp1_ * gtk_widget_get_scale_factor ((GtkWidget*) self);
	if (!self->large_thumbnails) {
		_tmp3_ = size > 128;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		_tmp2_ = TRUE;
	} else {
		gboolean _tmp4_ = FALSE;
		if (self->large_thumbnails) {
			_tmp4_ = size <= 128;
		} else {
			_tmp4_ = FALSE;
		}
		_tmp2_ = _tmp4_;
	}
	if (_tmp2_) {
		FilesViewSlot* _tmp5_;
		self->large_thumbnails = size > 128;
		_tmp5_ = self->slot;
		files_view_slot_refresh_files (_tmp5_);
		files_abstract_directory_view_schedule_thumbnail_color_tag_timeout (self);
	}
	_tmp6_ = self->model;
	_tmp7_ = files_abstract_directory_view_get_icon_size (self);
	_tmp8_ = _tmp7_;
	files_list_model_set_icon_size (_tmp6_, _tmp8_);
	files_abstract_directory_view_change_zoom_level (self);
}

/** Handle Preference changes */
static GVariant*
_variant_new4 (gboolean value)
{
	return g_variant_ref_sink (g_variant_new_boolean (value));
}

static void
files_abstract_directory_view_on_show_hidden_files_changed (FilesAbstractDirectoryView* self,
                                                            GObject* prefs,
                                                            GParamSpec* pspec)
{
	gboolean show = FALSE;
	gboolean _tmp0_;
	gboolean _tmp1_;
	FilesListModel* _tmp2_;
	FilesViewSlot* _tmp4_;
	FilesDirectory* _tmp5_;
	FilesDirectory* _tmp6_;
	GSimpleActionGroup* _tmp7_;
	GVariant* _tmp8_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (prefs != NULL);
	g_return_if_fail (pspec != NULL);
	_tmp0_ = files_preferences_get_show_hidden_files (G_TYPE_CHECK_INSTANCE_CAST (prefs, FILES_TYPE_PREFERENCES, FilesPreferences));
	_tmp1_ = _tmp0_;
	show = _tmp1_;
	_tmp2_ = self->model;
	files_list_model_set_show_hidden_files (_tmp2_, show);
	files_abstract_directory_view_cancel (self);
	files_abstract_directory_view_unselect_all (self);
	if (!show) {
		FilesListModel* _tmp3_;
		files_abstract_directory_view_block_model (self);
		_tmp3_ = self->model;
		gtk_tree_store_clear ((GtkTreeStore*) _tmp3_);
	}
	_tmp4_ = self->slot;
	_tmp5_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp4_);
	_tmp6_ = _tmp5_;
	files_abstract_directory_view_directory_hidden_changed (self, _tmp6_, show);
	if (!show) {
		files_abstract_directory_view_unblock_model (self);
	}
	_tmp7_ = self->priv->background_actions;
	_tmp8_ = _variant_new4 (show);
	files_abstract_directory_view_action_set_state (self, _tmp7_, "show-hidden", _tmp8_);
	_g_variant_unref0 (_tmp8_);
}

static GVariant*
_variant_new5 (gboolean value)
{
	return g_variant_ref_sink (g_variant_new_boolean (value));
}

static void
files_abstract_directory_view_on_show_remote_thumbnails_changed (FilesAbstractDirectoryView* self,
                                                                 GObject* prefs,
                                                                 GParamSpec* pspec)
{
	gboolean _tmp0_;
	gboolean _tmp1_;
	GSimpleActionGroup* _tmp2_;
	gboolean _tmp3_;
	GVariant* _tmp4_;
	FilesViewSlot* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (prefs != NULL);
	g_return_if_fail (pspec != NULL);
	_tmp0_ = files_preferences_get_show_remote_thumbnails (G_TYPE_CHECK_INSTANCE_CAST (prefs, FILES_TYPE_PREFERENCES, FilesPreferences));
	_tmp1_ = _tmp0_;
	files_abstract_directory_view_set_show_remote_thumbnails (self, _tmp1_);
	_tmp2_ = self->priv->background_actions;
	_tmp3_ = self->priv->_show_remote_thumbnails;
	_tmp4_ = _variant_new5 (_tmp3_);
	files_abstract_directory_view_action_set_state (self, _tmp2_, "show-remote-thumbnails", _tmp4_);
	_g_variant_unref0 (_tmp4_);
	_tmp5_ = self->slot;
	files_abstract_slot_reload ((FilesAbstractSlot*) _tmp5_, FALSE);
}

static GVariant*
_variant_new6 (gboolean value)
{
	return g_variant_ref_sink (g_variant_new_boolean (value));
}

static void
files_abstract_directory_view_on_show_local_thumbnails_changed (FilesAbstractDirectoryView* self,
                                                                GObject* prefs,
                                                                GParamSpec* pspec)
{
	gboolean _tmp0_;
	gboolean _tmp1_;
	GSimpleActionGroup* _tmp2_;
	gboolean _tmp3_;
	GVariant* _tmp4_;
	FilesViewSlot* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (prefs != NULL);
	g_return_if_fail (pspec != NULL);
	_tmp0_ = files_preferences_get_show_local_thumbnails (G_TYPE_CHECK_INSTANCE_CAST (prefs, FILES_TYPE_PREFERENCES, FilesPreferences));
	_tmp1_ = _tmp0_;
	files_abstract_directory_view_set_show_local_thumbnails (self, _tmp1_);
	_tmp2_ = self->priv->background_actions;
	_tmp3_ = self->priv->_show_local_thumbnails;
	_tmp4_ = _variant_new6 (_tmp3_);
	files_abstract_directory_view_action_set_state (self, _tmp2_, "show-local-thumbnails", _tmp4_);
	_g_variant_unref0 (_tmp4_);
	_tmp5_ = self->slot;
	files_abstract_slot_reload ((FilesAbstractSlot*) _tmp5_, FALSE);
}

static void
files_abstract_directory_view_on_sort_directories_first_changed (FilesAbstractDirectoryView* self,
                                                                 GObject* prefs,
                                                                 GParamSpec* pspec)
{
	gboolean sort_directories_first = FALSE;
	gboolean _tmp0_;
	gboolean _tmp1_;
	FilesListModel* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (prefs != NULL);
	g_return_if_fail (pspec != NULL);
	_tmp0_ = files_preferences_get_sort_directories_first (G_TYPE_CHECK_INSTANCE_CAST (prefs, FILES_TYPE_PREFERENCES, FilesPreferences));
	_tmp1_ = _tmp0_;
	sort_directories_first = _tmp1_;
	_tmp2_ = self->model;
	files_list_model_set_should_sort_directories_first (_tmp2_, sort_directories_first);
}

static void
files_abstract_directory_view_directory_hidden_changed (FilesAbstractDirectoryView* self,
                                                        FilesDirectory* dir,
                                                        gboolean show)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	g_signal_connect_object (dir, "file-loaded", (GCallback) _files_abstract_directory_view_on_directory_file_loaded_files_directory_file_loaded, self, 0);
	files_directory_load_hiddens (dir);
}

/** Handle popup menu events */
static void
_vala_GdkEvent_free (GdkEvent* self)
{
	g_boxed_free (gdk_event_get_type (), self);
}

static gboolean
files_abstract_directory_view_on_popup_menu (FilesAbstractDirectoryView* self)
{
	GdkEvent* event = NULL;
	GdkEvent* _tmp0_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = gtk_get_current_event ();
	event = _tmp0_;
	files_abstract_directory_view_show_context_menu (self, event);
	result = TRUE;
	__vala_GdkEvent_free0 (event);
	return result;
}

/** Handle Button events */
static gboolean
files_abstract_directory_view_on_drag_timeout_button_release (FilesAbstractDirectoryView* self,
                                                              GdkEventButton* event)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	files_abstract_directory_view_cancel_drag_timer (self);
	result = TRUE;
	return result;
}

/** Handle Motion events */
static gboolean
files_abstract_directory_view_on_drag_timeout_motion_notify (FilesAbstractDirectoryView* self,
                                                             GdkEventMotion* event)
{
	GdkDragContext* context = NULL;
	GtkWidget* widget = NULL;
	GtkWidget* _tmp0_;
	GtkWidget* _tmp1_;
	gdouble x = 0.0;
	gdouble y = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	GtkWidget* _tmp4_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = gtk_bin_get_child ((GtkBin*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	widget = _tmp1_;
	gdk_event_get_coords ((GdkEvent*) event, &_tmp2_, &_tmp3_);
	x = _tmp2_;
	y = _tmp3_;
	_tmp4_ = widget;
	if (gtk_drag_check_threshold (_tmp4_, (gint) self->priv->drag_x, (gint) self->priv->drag_y, (gint) x, (gint) y)) {
		GtkTargetList* target_list = NULL;
		GtkTargetList* _tmp5_;
		GdkDragAction actions = 0U;
		GtkWidget* _tmp6_;
		GtkTargetList* _tmp7_;
		GdkDragContext* _tmp8_;
		GdkDragContext* _tmp9_;
		files_abstract_directory_view_cancel_drag_timer (self);
		self->should_activate = FALSE;
		_tmp5_ = gtk_target_list_new (FILES_ABSTRACT_DIRECTORY_VIEW_DRAG_TARGETS, G_N_ELEMENTS (FILES_ABSTRACT_DIRECTORY_VIEW_DRAG_TARGETS));
		target_list = _tmp5_;
		actions = FILES_ABSTRACT_DIRECTORY_VIEW_FILE_DRAG_ACTIONS;
		if (self->priv->drag_button == GDK_BUTTON_SECONDARY) {
			actions |= GDK_ACTION_ASK;
		}
		_tmp6_ = widget;
		_tmp7_ = target_list;
		_tmp8_ = gtk_drag_begin_with_coordinates (_tmp6_, _tmp7_, actions, self->priv->drag_button, (GdkEvent*) event, (gint) x, (gint) y);
		_tmp9_ = _g_object_ref0 (_tmp8_);
		_g_object_unref0 (context);
		context = _tmp9_;
		result = TRUE;
		_gtk_target_list_unref0 (target_list);
		_g_object_unref0 (widget);
		_g_object_unref0 (context);
		return result;
	} else {
		result = FALSE;
		_g_object_unref0 (widget);
		_g_object_unref0 (context);
		return result;
	}
}

/** Handle TreeModel events */
static void
files_abstract_directory_view_real_on_row_deleted (FilesAbstractDirectoryView* self,
                                                   GtkTreePath* path)
{
	g_return_if_fail (path != NULL);
	files_abstract_directory_view_unselect_all (self);
}

void
files_abstract_directory_view_on_row_deleted (FilesAbstractDirectoryView* self,
                                              GtkTreePath* path)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->on_row_deleted) {
		_klass_->on_row_deleted (self, path);
	}
}

/** Handle clipboard signal */
static void
files_abstract_directory_view_on_clipboard_changed (FilesAbstractDirectoryView* self)
{
	g_return_if_fail (self != NULL);
	gtk_widget_queue_draw ((GtkWidget*) self);
}

/** DRAG AND DROP SOURCE */
static void
files_abstract_directory_view_on_drag_begin (FilesAbstractDirectoryView* self,
                                             GdkDragContext* context)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	self->should_activate = FALSE;
}

static void
files_abstract_directory_view_on_drag_data_get (FilesAbstractDirectoryView* self,
                                                GdkDragContext* context,
                                                GtkSelectionData* selection_data,
                                                guint info,
                                                guint timestamp)
{
	GList* _tmp0_;
	GList* _tmp3_;
	FilesFile* file = NULL;
	GList* _tmp4_;
	GList* _tmp5_;
	gconstpointer _tmp6_;
	FilesFile* _tmp7_;
	gboolean _tmp8_ = FALSE;
	FilesFile* _tmp9_;
	GList* _tmp14_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	g_return_if_fail (selection_data != NULL);
	_tmp0_ = self->source_drag_file_list;
	if (_tmp0_ == NULL) {
		GList* _tmp1_;
		GList* _tmp2_;
		_tmp1_ = files_abstract_directory_view_get_selected_files (self);
		_tmp2_ = files_abstract_directory_view_get_selected_files_for_transfer (self, _tmp1_);
		(self->source_drag_file_list == NULL) ? NULL : (self->source_drag_file_list = (_g_list_free__g_object_unref0_ (self->source_drag_file_list), NULL));
		self->source_drag_file_list = _tmp2_;
	}
	_tmp3_ = self->source_drag_file_list;
	if (_tmp3_ == NULL) {
		return;
	}
	_tmp4_ = self->source_drag_file_list;
	_tmp5_ = g_list_first (_tmp4_);
	_tmp6_ = _tmp5_->data;
	_tmp7_ = _g_object_ref0 ((FilesFile*) _tmp6_);
	file = _tmp7_;
	_tmp9_ = file;
	if (_tmp9_ != NULL) {
		FilesFile* _tmp10_;
		GdkPixbuf* _tmp11_;
		_tmp10_ = file;
		_tmp11_ = _tmp10_->pix;
		_tmp8_ = _tmp11_ != NULL;
	} else {
		_tmp8_ = FALSE;
	}
	if (_tmp8_) {
		FilesFile* _tmp12_;
		GdkPixbuf* _tmp13_;
		_tmp12_ = file;
		_tmp13_ = _tmp12_->pix;
		gtk_drag_set_icon_gicon (context, (GIcon*) _tmp13_, 0, 0);
	} else {
		gtk_drag_set_icon_name (context, "stock-file", 0, 0);
	}
	_tmp14_ = self->source_drag_file_list;
	files_dnd_handler_set_selection_data_from_file_list (selection_data, _tmp14_, "");
	_g_object_unref0 (file);
}

static void
files_abstract_directory_view_on_drag_data_delete (FilesAbstractDirectoryView* self,
                                                   GdkDragContext* context)
{
	GtkWidget* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	_tmp0_ = gtk_bin_get_child ((GtkBin*) self);
	g_signal_stop_emission_by_name (_tmp0_, "drag-data-delete");
}

static void
files_abstract_directory_view_on_drag_end (FilesAbstractDirectoryView* self,
                                           GdkDragContext* context)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	(self->source_drag_file_list == NULL) ? NULL : (self->source_drag_file_list = (_g_list_free__g_object_unref0_ (self->source_drag_file_list), NULL));
	self->source_drag_file_list = NULL;
}

/** DRAG AND DROP DESTINATION */
static gboolean
files_abstract_directory_view_on_drag_motion (FilesAbstractDirectoryView* self,
                                              GdkDragContext* context,
                                              gint x,
                                              gint y,
                                              guint timestamp)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (context != NULL, FALSE);
	if (self->priv->destination_data_ready) {
		files_abstract_directory_view_check_destination_actions_and_target_file (self, context, x, y, timestamp);
	} else {
		files_abstract_directory_view_get_drag_data (self, context, x, y, timestamp);
		result = FALSE;
		return result;
	}
	if (self->priv->drag_scroll_timer_id == ((guint) 0)) {
		files_abstract_directory_view_start_drag_scroll_timer (self, context);
	}
	gdk_drag_status (context, self->priv->current_suggested_action, (guint32) timestamp);
	result = TRUE;
	return result;
}

static gboolean
files_abstract_directory_view_on_drag_drop (FilesAbstractDirectoryView* self,
                                            GdkDragContext* context,
                                            gint x,
                                            gint y,
                                            guint timestamp)
{
	GtkTargetList* list = NULL;
	gchar* uri = NULL;
	GdkAtom target = (GdkAtom) 0U;
	GtkWidget* _tmp0_;
	GtkTargetList* _tmp1_;
	GtkWidget* _tmp19_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (context != NULL, FALSE);
	list = NULL;
	uri = NULL;
	self->priv->drop_occurred = TRUE;
	_tmp0_ = gtk_bin_get_child ((GtkBin*) self);
	_tmp1_ = list;
	target = gtk_drag_dest_find_target (_tmp0_, context, _tmp1_);
	if (target == gdk_atom_intern_static_string ("XdndDirectSave0")) {
		FilesFile* target_file = NULL;
		FilesFile* _tmp2_;
		gchar* filename = NULL;
		FilesDndHandler* _tmp3_;
		gchar* _tmp4_;
		gboolean _tmp5_ = FALSE;
		FilesFile* _tmp6_;
		_tmp2_ = files_abstract_directory_view_get_drop_target_file (self, x, y);
		target_file = _tmp2_;
		_tmp3_ = files_abstract_directory_view_dnd_handler;
		_tmp4_ = files_dnd_handler_get_source_filename (_tmp3_, context);
		filename = _tmp4_;
		_tmp6_ = target_file;
		if (_tmp6_ != NULL) {
			const gchar* _tmp7_;
			_tmp7_ = filename;
			_tmp5_ = _tmp7_ != NULL;
		} else {
			_tmp5_ = FALSE;
		}
		if (_tmp5_) {
			FilesFile* _tmp8_;
			GFile* _tmp9_;
			const gchar* _tmp10_;
			GFile* _tmp11_;
			GFile* _tmp12_;
			gchar* _tmp13_;
			FilesDndHandler* _tmp14_;
			const gchar* _tmp15_;
			_tmp8_ = target_file;
			_tmp9_ = files_file_get_target_location (_tmp8_);
			_tmp10_ = filename;
			_tmp11_ = g_file_resolve_relative_path (_tmp9_, _tmp10_);
			_tmp12_ = _tmp11_;
			_tmp13_ = g_file_get_uri (_tmp12_);
			_g_free0 (uri);
			uri = _tmp13_;
			_g_object_unref0 (_tmp12_);
			_tmp14_ = files_abstract_directory_view_dnd_handler;
			_tmp15_ = uri;
			files_dnd_handler_set_source_uri (_tmp14_, context, _tmp15_);
		} else {
			FilesViewWindow* _tmp16_;
			GraniteMessageDialog* _tmp17_;
			GraniteMessageDialog* _tmp18_;
			_tmp16_ = self->window;
			_tmp17_ = pf_dialogs_show_error_dialog (_ ("Cannot drop this file"), _ ("Invalid file name provided"), (GtkWindow*) _tmp16_);
			_tmp18_ = _tmp17_;
			_g_object_unref0 (_tmp18_);
			result = FALSE;
			_g_free0 (filename);
			_g_object_unref0 (target_file);
			_g_free0 (uri);
			_gtk_target_list_unref0 (list);
			return result;
		}
		_g_free0 (filename);
		_g_object_unref0 (target_file);
	}
	_tmp19_ = gtk_bin_get_child ((GtkBin*) self);
	gtk_drag_get_data (_tmp19_, context, target, (guint32) timestamp);
	result = TRUE;
	_g_free0 (uri);
	_gtk_target_list_unref0 (list);
	return result;
}

static void
files_abstract_directory_view_on_drag_data_received (FilesAbstractDirectoryView* self,
                                                     GdkDragContext* context,
                                                     gint x,
                                                     gint y,
                                                     GtkSelectionData* selection_data,
                                                     guint info,
                                                     guint timestamp)
{
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	g_return_if_fail (selection_data != NULL);
	if (info == ((guint) FILES_TARGET_TYPE_TEXT_URI_LIST)) {
		GList* _tmp1_;
		_tmp1_ = self->priv->destination_drop_file_list;
		_tmp0_ = _tmp1_ == NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gchar* text = NULL;
		gchar* _tmp2_ = NULL;
		gboolean _tmp3_;
		_tmp3_ = files_dnd_handler_selection_data_is_uri_list (selection_data, info, &_tmp2_);
		_g_free0 (text);
		text = _tmp2_;
		if (_tmp3_) {
			const gchar* _tmp4_;
			GList* _tmp5_;
			_tmp4_ = text;
			_tmp5_ = files_file_utils_files_from_uris (_tmp4_);
			(self->priv->destination_drop_file_list == NULL) ? NULL : (self->priv->destination_drop_file_list = (_g_list_free__g_object_unref0_ (self->priv->destination_drop_file_list), NULL));
			self->priv->destination_drop_file_list = _tmp5_;
			self->priv->destination_data_ready = TRUE;
		}
		_g_free0 (text);
	}
	if (self->priv->drop_occurred) {
		gboolean success = FALSE;
		success = FALSE;
		self->priv->drop_occurred = FALSE;
		switch (info) {
			case FILES_TARGET_TYPE_XDND_DIRECT_SAVE0:
			{
				FilesDndHandler* _tmp6_;
				FilesFile* _tmp7_;
				_tmp6_ = files_abstract_directory_view_dnd_handler;
				_tmp7_ = self->priv->drop_target_file;
				success = files_dnd_handler_handle_xdnddirectsave (_tmp6_, context, _tmp7_, selection_data);
				break;
			}
			case FILES_TARGET_TYPE_NETSCAPE_URL:
			{
				FilesDndHandler* _tmp8_;
				FilesFile* _tmp9_;
				_tmp8_ = files_abstract_directory_view_dnd_handler;
				_tmp9_ = self->priv->drop_target_file;
				success = files_dnd_handler_handle_netscape_url (_tmp8_, context, _tmp9_, selection_data);
				break;
			}
			case FILES_TARGET_TYPE_TEXT_URI_LIST:
			{
				GList* _tmp10_;
				FilesDndHandler* _tmp11_;
				GtkWidget* _tmp12_;
				FilesFile* _tmp13_;
				GList* _tmp14_;
				GtkWindow* _tmp15_;
				GtkApplicationWindow* _tmp16_;
				if ((self->priv->current_actions & FILES_ABSTRACT_DIRECTORY_VIEW_FILE_DRAG_ACTIONS) == 0) {
					break;
				}
				_tmp10_ = self->selected_files;
				if (_tmp10_ != NULL) {
					files_abstract_directory_view_unselect_all (self);
				}
				_tmp11_ = files_abstract_directory_view_dnd_handler;
				_tmp12_ = gtk_bin_get_child ((GtkBin*) self);
				_tmp13_ = self->priv->drop_target_file;
				_tmp14_ = self->priv->destination_drop_file_list;
				_tmp15_ = files_get_active_window ();
				_tmp16_ = G_TYPE_CHECK_INSTANCE_CAST (_tmp15_, gtk_application_window_get_type (), GtkApplicationWindow);
				success = files_dnd_handler_handle_file_drag_actions (_tmp11_, _tmp12_, context, _tmp13_, _tmp14_, self->priv->current_actions, self->priv->current_suggested_action, _tmp16_, (guint32) timestamp);
				_g_object_unref0 (_tmp16_);
				break;
			}
			default:
			{
				break;
			}
		}
		gtk_drag_finish (context, success, FALSE, (guint32) timestamp);
		files_abstract_directory_view_clear_destination_drag_data (self);
	}
}

static void
files_abstract_directory_view_on_drag_leave (FilesAbstractDirectoryView* self,
                                             GdkDragContext* context,
                                             guint timestamp)
{
	FilesIconRenderer* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	_tmp0_ = self->icon_renderer;
	files_icon_renderer_set_drop_file (_tmp0_, NULL);
	files_abstract_directory_view_cancel_timeout (self, &self->priv->drag_scroll_timer_id);
	files_abstract_directory_view_cancel_timeout (self, &self->priv->drag_enter_timer_id);
	_tmp1_ = files_abstract_directory_view_get_drop_highlight (self);
	_tmp2_ = _tmp1_;
	if (_tmp2_) {
		files_abstract_directory_view_set_drop_highlight (self, FALSE);
		gtk_widget_queue_draw ((GtkWidget*) self);
	}
	files_abstract_directory_view_highlight_path (self, NULL);
	files_abstract_directory_view_clear_destination_drag_data (self);
}

/** DnD destination helpers */
static void
files_abstract_directory_view_clear_destination_drag_data (FilesAbstractDirectoryView* self)
{
	g_return_if_fail (self != NULL);
	self->priv->destination_data_ready = FALSE;
	self->current_target_type = GDK_NONE;
	(self->priv->destination_drop_file_list == NULL) ? NULL : (self->priv->destination_drop_file_list = (_g_list_free__g_object_unref0_ (self->priv->destination_drop_file_list), NULL));
	self->priv->destination_drop_file_list = NULL;
	files_abstract_directory_view_cancel_timeout (self, &self->priv->drag_scroll_timer_id);
}

static FilesFile*
files_abstract_directory_view_get_drop_target_file (FilesAbstractDirectoryView* self,
                                                    gint win_x,
                                                    gint win_y)
{
	GtkTreePath* path = NULL;
	GtkTreePath* _tmp0_;
	FilesFile* file = NULL;
	GtkTreePath* _tmp1_;
	GtkTreePath* _tmp15_;
	FilesFile* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = files_abstract_directory_view_get_path_at_pos (self, win_x, win_y);
	path = _tmp0_;
	file = NULL;
	_tmp1_ = path;
	if (_tmp1_ != NULL) {
		FilesListModel* _tmp2_;
		GtkTreePath* _tmp3_;
		FilesFile* _tmp4_;
		FilesFile* _tmp5_;
		_tmp2_ = self->model;
		_tmp3_ = path;
		_tmp4_ = files_list_model_file_for_path (_tmp2_, _tmp3_);
		_g_object_unref0 (file);
		file = _tmp4_;
		_tmp5_ = file;
		if (_tmp5_ == NULL) {
			GtkTreePath* folder_path = NULL;
			GtkTreePath* _tmp6_;
			GtkTreePath* _tmp7_;
			GtkTreePath* _tmp8_;
			FilesListModel* _tmp9_;
			GtkTreePath* _tmp10_;
			FilesFile* _tmp11_;
			_tmp6_ = path;
			_tmp7_ = gtk_tree_path_copy (_tmp6_);
			folder_path = _tmp7_;
			_tmp8_ = folder_path;
			gtk_tree_path_up (_tmp8_);
			_tmp9_ = self->model;
			_tmp10_ = folder_path;
			_tmp11_ = files_list_model_file_for_path (_tmp9_, _tmp10_);
			_g_object_unref0 (file);
			file = _tmp11_;
			__vala_GtkTreePath_free0 (folder_path);
		} else {
			gboolean _tmp12_ = FALSE;
			FilesFile* _tmp13_;
			_tmp13_ = file;
			if (!files_file_is_folder (_tmp13_)) {
				FilesFile* _tmp14_;
				_tmp14_ = file;
				_tmp12_ = !files_file_is_executable (_tmp14_);
			} else {
				_tmp12_ = FALSE;
			}
			if (_tmp12_) {
				_g_object_unref0 (file);
				file = NULL;
				__vala_GtkTreePath_free0 (path);
				path = NULL;
			}
		}
	}
	_tmp15_ = path;
	if (_tmp15_ == NULL) {
		FilesViewSlot* _tmp16_;
		FilesDirectory* _tmp17_;
		FilesDirectory* _tmp18_;
		FilesFile* _tmp19_;
		FilesFile* _tmp20_;
		FilesFile* _tmp21_;
		_tmp16_ = self->slot;
		_tmp17_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp16_);
		_tmp18_ = _tmp17_;
		_tmp19_ = files_directory_get_file (_tmp18_);
		_tmp20_ = _tmp19_;
		_tmp21_ = _g_object_ref0 (_tmp20_);
		_g_object_unref0 (file);
		file = _tmp21_;
	}
	result = file;
	__vala_GtkTreePath_free0 (path);
	return result;
}

static void
files_abstract_directory_view_get_drag_data (FilesAbstractDirectoryView* self,
                                             GdkDragContext* context,
                                             gint x,
                                             gint y,
                                             guint timestamp)
{
	GtkTargetList* list = NULL;
	GdkAtom target = (GdkAtom) 0U;
	GtkWidget* _tmp0_;
	GtkTargetList* _tmp1_;
	gboolean _tmp2_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	list = NULL;
	_tmp0_ = gtk_bin_get_child ((GtkBin*) self);
	_tmp1_ = list;
	target = gtk_drag_dest_find_target (_tmp0_, context, _tmp1_);
	self->current_target_type = target;
	if (target == gdk_atom_intern_static_string ("XdndDirectSave0")) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = target == gdk_atom_intern_static_string ("_NETSCAPE_URL");
	}
	if (_tmp2_) {
		gboolean _tmp3_ = FALSE;
		gboolean _tmp4_ = FALSE;
		FilesFile* _tmp5_;
		_tmp5_ = self->priv->drop_target_file;
		if (_tmp5_ != NULL) {
			FilesFile* _tmp6_;
			_tmp6_ = self->priv->drop_target_file;
			_tmp4_ = files_file_is_folder (_tmp6_);
		} else {
			_tmp4_ = FALSE;
		}
		if (_tmp4_) {
			FilesFile* _tmp7_;
			_tmp7_ = self->priv->drop_target_file;
			_tmp3_ = files_file_is_writable (_tmp7_);
		} else {
			_tmp3_ = FALSE;
		}
		if (_tmp3_) {
			FilesIconRenderer* _tmp8_;
			FilesFile* _tmp9_;
			GtkTreePath* _tmp10_;
			GtkTreePath* _tmp11_;
			_tmp8_ = self->icon_renderer;
			_tmp9_ = self->priv->drop_target_file;
			g_object_set ((GObject*) _tmp8_, "drop-file", _tmp9_, NULL);
			_tmp10_ = files_abstract_directory_view_get_path_at_pos (self, x, y);
			_tmp11_ = _tmp10_;
			files_abstract_directory_view_highlight_path (self, _tmp11_);
			__vala_GtkTreePath_free0 (_tmp11_);
		}
		self->priv->destination_data_ready = TRUE;
	} else {
		gboolean _tmp12_ = FALSE;
		if (target != GDK_NONE) {
			GList* _tmp13_;
			_tmp13_ = self->priv->destination_drop_file_list;
			_tmp12_ = _tmp13_ == NULL;
		} else {
			_tmp12_ = FALSE;
		}
		if (_tmp12_) {
			GtkWidget* _tmp14_;
			_tmp14_ = gtk_bin_get_child ((GtkBin*) self);
			gtk_drag_get_data (_tmp14_, context, target, (guint32) timestamp);
		}
	}
	_gtk_target_list_unref0 (list);
}

static gboolean
_____lambda119_ (FilesAbstractDirectoryView* self)
{
	FilesFile* _tmp0_;
	GFile* _tmp1_;
	gboolean result;
	_tmp0_ = self->priv->drop_target_file;
	_tmp1_ = files_file_get_target_location (_tmp0_);
	files_abstract_directory_view_load_location (self, _tmp1_);
	self->priv->drag_enter_timer_id = (guint) 0;
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
______lambda119__gsource_func (gpointer self)
{
	gboolean result;
	result = _____lambda119_ ((FilesAbstractDirectoryView*) self);
	return result;
}

static void
files_abstract_directory_view_check_destination_actions_and_target_file (FilesAbstractDirectoryView* self,
                                                                         GdkDragContext* context,
                                                                         gint x,
                                                                         gint y,
                                                                         guint timestamp)
{
	const gchar* _tmp0_ = NULL;
	FilesFile* _tmp1_;
	gchar* current_uri = NULL;
	gchar* _tmp5_;
	FilesFile* _tmp6_;
	const gchar* _tmp7_ = NULL;
	FilesFile* _tmp8_;
	gchar* uri = NULL;
	gchar* _tmp12_;
	const gchar* _tmp13_;
	const gchar* _tmp14_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	_tmp1_ = self->priv->drop_target_file;
	if (_tmp1_ != NULL) {
		FilesFile* _tmp2_;
		const gchar* _tmp3_;
		const gchar* _tmp4_;
		_tmp2_ = self->priv->drop_target_file;
		_tmp3_ = files_file_get_uri (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp0_ = _tmp4_;
	} else {
		_tmp0_ = "";
	}
	_tmp5_ = g_strdup (_tmp0_);
	current_uri = _tmp5_;
	_tmp6_ = files_abstract_directory_view_get_drop_target_file (self, x, y);
	_g_object_unref0 (self->priv->drop_target_file);
	self->priv->drop_target_file = _tmp6_;
	_tmp8_ = self->priv->drop_target_file;
	if (_tmp8_ != NULL) {
		FilesFile* _tmp9_;
		const gchar* _tmp10_;
		const gchar* _tmp11_;
		_tmp9_ = self->priv->drop_target_file;
		_tmp10_ = files_file_get_uri (_tmp9_);
		_tmp11_ = _tmp10_;
		_tmp7_ = _tmp11_;
	} else {
		_tmp7_ = "";
	}
	_tmp12_ = g_strdup (_tmp7_);
	uri = _tmp12_;
	_tmp13_ = uri;
	_tmp14_ = current_uri;
	if (g_strcmp0 (_tmp13_, _tmp14_) != 0) {
		FilesFile* _tmp15_;
		files_abstract_directory_view_cancel_timeout (self, &self->priv->drag_enter_timer_id);
		self->priv->current_actions = GDK_ACTION_DEFAULT;
		self->priv->current_suggested_action = GDK_ACTION_DEFAULT;
		_tmp15_ = self->priv->drop_target_file;
		if (_tmp15_ != NULL) {
			FilesFile* _tmp20_;
			GtkTreePath* _tmp21_;
			GtkTreePath* _tmp22_;
			gboolean _tmp23_ = FALSE;
			FilesFile* _tmp24_;
			if (self->current_target_type == gdk_atom_intern_static_string ("XdndDirectSave0")) {
				self->priv->current_suggested_action = GDK_ACTION_COPY;
				self->priv->current_actions = self->priv->current_suggested_action;
			} else {
				FilesFile* _tmp16_;
				GList* _tmp17_;
				GdkDragAction _tmp18_ = 0U;
				GdkDragAction _tmp19_;
				_tmp16_ = self->priv->drop_target_file;
				_tmp17_ = self->priv->destination_drop_file_list;
				_tmp19_ = files_file_utils_file_accepts_drop (_tmp16_, _tmp17_, context, &_tmp18_);
				self->priv->current_suggested_action = _tmp18_;
				self->priv->current_actions = _tmp19_;
			}
			_tmp20_ = self->priv->drop_target_file;
			_tmp21_ = files_abstract_directory_view_get_path_at_pos (self, x, y);
			_tmp22_ = _tmp21_;
			files_abstract_directory_view_highlight_drop_file (self, _tmp20_, self->priv->current_actions, _tmp22_);
			__vala_GtkTreePath_free0 (_tmp22_);
			_tmp24_ = self->priv->drop_target_file;
			if (files_file_is_folder (_tmp24_)) {
				FilesFile* _tmp25_;
				_tmp25_ = self->priv->drop_target_file;
				_tmp23_ = files_abstract_directory_view_is_valid_drop_folder (self, _tmp25_);
			} else {
				_tmp23_ = FALSE;
			}
			if (_tmp23_) {
				self->priv->drag_enter_timer_id = g_timeout_add_full (G_PRIORITY_LOW, (guint) 1000, ______lambda119__gsource_func, g_object_ref (self), g_object_unref);
			}
		}
	}
	_g_free0 (uri);
	_g_free0 (current_uri);
}

static gboolean
files_abstract_directory_view_is_valid_drop_folder (FilesAbstractDirectoryView* self,
                                                    FilesFile* file)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	FilesViewSlot* _tmp4_;
	const gchar* _tmp5_;
	const gchar* _tmp6_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (file != NULL, FALSE);
	_tmp2_ = files_file_get_uri (file);
	_tmp3_ = _tmp2_;
	_tmp4_ = self->slot;
	_tmp5_ = files_abstract_slot_get_uri ((FilesAbstractSlot*) _tmp4_);
	_tmp6_ = _tmp5_;
	if (g_strcmp0 (_tmp3_, _tmp6_) != 0) {
		GList* _tmp7_;
		_tmp7_ = self->source_drag_file_list;
		_tmp1_ = _tmp7_ != NULL;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		GList* _tmp8_;
		_tmp8_ = self->source_drag_file_list;
		_tmp0_ = g_list_index (_tmp8_, file) < 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		result = TRUE;
		return result;
	} else {
		result = FALSE;
		return result;
	}
}

static void
files_abstract_directory_view_highlight_drop_file (FilesAbstractDirectoryView* self,
                                                   FilesFile* drop_file,
                                                   GdkDragAction action,
                                                   GtkTreePath* path)
{
	gboolean can_drop = FALSE;
	gboolean _tmp0_;
	gboolean _tmp1_;
	FilesFile* _tmp2_ = NULL;
	FilesIconRenderer* _tmp3_;
	GtkTreePath* _tmp4_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (drop_file != NULL);
	can_drop = action > GDK_ACTION_DEFAULT;
	_tmp0_ = files_abstract_directory_view_get_drop_highlight (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_ != can_drop) {
		files_abstract_directory_view_set_drop_highlight (self, can_drop);
		gtk_widget_queue_draw ((GtkWidget*) self);
	}
	if (can_drop) {
		_tmp2_ = drop_file;
	} else {
		_tmp2_ = NULL;
	}
	_tmp3_ = self->icon_renderer;
	files_icon_renderer_set_drop_file (_tmp3_, _tmp2_);
	if (can_drop) {
		_tmp4_ = path;
	} else {
		_tmp4_ = NULL;
	}
	files_abstract_directory_view_highlight_path (self, _tmp4_);
}

/** MENU FUNCTIONS */
static GdkEvent*
_vala_GdkEvent_copy (GdkEvent* self)
{
	return g_boxed_copy (gdk_event_get_type (), self);
}

static gpointer
__vala_GdkEvent_copy0 (gpointer self)
{
	return self ? _vala_GdkEvent_copy (self) : NULL;
}

static Block21Data*
block21_data_ref (Block21Data* _data21_)
{
	g_atomic_int_inc (&_data21_->_ref_count_);
	return _data21_;
}

static void
block21_data_unref (void * _userdata_)
{
	Block21Data* _data21_;
	_data21_ = (Block21Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data21_->_ref_count_)) {
		FilesAbstractDirectoryView* self;
		self = _data21_->self;
		__vala_GdkEvent_free0 (_data21_->event);
		_g_object_unref0 (self);
		g_slice_free (Block21Data, _data21_);
	}
}

static gboolean
___lambda121_ (Block21Data* _data21_)
{
	FilesAbstractDirectoryView* self;
	gboolean result;
	self = _data21_->self;
	files_abstract_directory_view_on_drag_timeout_button_release (self, (GdkEventButton*) _data21_->event);
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
____lambda121__gsource_func (gpointer self)
{
	gboolean result;
	result = ___lambda121_ (self);
	return result;
}

void
files_abstract_directory_view_start_drag_timer (FilesAbstractDirectoryView* self,
                                                GdkEvent* event)
{
	Block21Data* _data21_;
	GdkEvent* _tmp0_;
	guint button = 0U;
	guint _tmp1_ = 0U;
	gboolean _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (event != NULL);
	_data21_ = g_slice_new0 (Block21Data);
	_data21_->_ref_count_ = 1;
	_data21_->self = g_object_ref (self);
	_tmp0_ = __vala_GdkEvent_copy0 (event);
	__vala_GdkEvent_free0 (_data21_->event);
	_data21_->event = _tmp0_;
	files_abstract_directory_view_connect_drag_timeout_motion_and_release_events (self);
	_tmp2_ = gdk_event_get_button (_data21_->event, &_tmp1_);
	button = _tmp1_;
	if (_tmp2_) {
		self->priv->drag_button = (gint) button;
		self->priv->drag_timer_id = g_timeout_add_full (G_PRIORITY_LOW, (guint) 300, ____lambda121__gsource_func, block21_data_ref (_data21_), block21_data_unref);
	}
	block21_data_unref (_data21_);
	_data21_ = NULL;
}

static GVariant*
_variant_new7 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}

static GVariant*
_variant_new8 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}

void
files_abstract_directory_view_show_context_menu (FilesAbstractDirectoryView* self,
                                                 GdkEvent* event)
{
	GtkMenu* menu = NULL;
	GtkMenu* _tmp0_;
	GList* selection = NULL;
	GList* _tmp1_;
	FilesFile* selected_file = NULL;
	GList* _tmp2_;
	gconstpointer _tmp3_;
	FilesFile* _tmp4_;
	GtkMenu* open_submenu = NULL;
	GtkMenu* _tmp5_;
	GSimpleActionGroup* _tmp6_;
	gboolean _tmp38_ = FALSE;
	gboolean _tmp39_ = FALSE;
	FilesFile* _tmp40_;
	GtkMenuItem* open_submenu_item = NULL;
	GtkMenuItem* _tmp123_;
	GtkMenu* _tmp124_;
	GList* _tmp125_;
	GList* _tmp126_;
	gboolean _tmp127_;
	GtkMenuItem* paste_menuitem = NULL;
	GtkMenuItem* _tmp137_;
	GtkMenuItem* _tmp138_;
	GtkMenuItem* bookmark_menuitem = NULL;
	GtkMenuItem* _tmp139_;
	GtkMenuItem* _tmp140_;
	GraniteAccelLabel* _tmp141_;
	GraniteAccelLabel* _tmp142_;
	GtkMenuItem* _tmp143_;
	GtkMenuItem* properties_menuitem = NULL;
	GtkMenuItem* _tmp144_;
	GtkMenuItem* _tmp145_;
	GraniteAccelLabel* _tmp146_;
	GraniteAccelLabel* _tmp147_;
	GtkMenuItem* _tmp148_;
	GtkMenuItem* select_all_menuitem = NULL;
	GtkMenuItem* deselect_all_menuitem = NULL;
	GtkMenuItem* invert_selection_menuitem = NULL;
	GList* _tmp174_;
	GtkMenu* _tmp421_;
	GtkMenu* _tmp422_;
	FilesViewSlot* _tmp423_;
	FilesDirectory* _tmp424_;
	FilesDirectory* _tmp425_;
	GtkMenu* _tmp428_;
	GtkMenu* _tmp429_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (event != NULL);
	files_abstract_directory_view_cancel_drag_timer (self);
	files_abstract_directory_view_update_menu_actions (self);
	_tmp0_ = (GtkMenu*) gtk_menu_new ();
	g_object_ref_sink (_tmp0_);
	menu = _tmp0_;
	_tmp1_ = files_abstract_directory_view_get_files_for_action (self);
	selection = _tmp1_;
	_tmp2_ = selection;
	_tmp3_ = _tmp2_->data;
	_tmp4_ = _g_object_ref0 ((FilesFile*) _tmp3_);
	selected_file = _tmp4_;
	_tmp5_ = (GtkMenu*) gtk_menu_new ();
	g_object_ref_sink (_tmp5_);
	open_submenu = _tmp5_;
	_tmp6_ = self->priv->common_actions;
	if (g_action_group_get_action_enabled ((GActionGroup*) _tmp6_, "open-in")) {
		GtkMenuItem* new_tab_menuitem = NULL;
		GtkMenuItem* _tmp7_;
		GList* _tmp8_;
		GtkMenuItem* _tmp17_;
		GVariant* _tmp18_;
		GtkMenuItem* new_window_menuitem = NULL;
		GtkMenuItem* _tmp19_;
		GList* _tmp20_;
		GtkMenuItem* _tmp29_;
		GVariant* _tmp30_;
		GtkMenu* _tmp31_;
		GtkMenuItem* _tmp32_;
		GtkMenu* _tmp33_;
		GtkMenuItem* _tmp34_;
		GtkMenu* _tmp35_;
		GtkSeparatorMenuItem* _tmp36_;
		GtkSeparatorMenuItem* _tmp37_;
		_tmp7_ = (GtkMenuItem*) gtk_menu_item_new ();
		g_object_ref_sink (_tmp7_);
		new_tab_menuitem = _tmp7_;
		_tmp8_ = self->selected_files;
		if (_tmp8_ != NULL) {
			GtkMenuItem* _tmp9_;
			GraniteAccelLabel* _tmp10_;
			GraniteAccelLabel* _tmp11_;
			GtkMenuItem* _tmp12_;
			_tmp9_ = new_tab_menuitem;
			_tmp10_ = granite_accel_label_new (_ ("New Tab"), "<Shift>Return");
			g_object_ref_sink (_tmp10_);
			_tmp11_ = _tmp10_;
			gtk_container_add ((GtkContainer*) _tmp9_, (GtkWidget*) _tmp11_);
			_g_object_unref0 (_tmp11_);
			_tmp12_ = new_tab_menuitem;
			gtk_actionable_set_action_name ((GtkActionable*) _tmp12_, "common.open-in");
		} else {
			GtkMenuItem* _tmp13_;
			GraniteAccelLabel* _tmp14_;
			GraniteAccelLabel* _tmp15_;
			GtkMenuItem* _tmp16_;
			_tmp13_ = new_tab_menuitem;
			_tmp14_ = granite_accel_label_new_from_action_name (_ ("New Tab"), "win.tab::TAB");
			g_object_ref_sink (_tmp14_);
			_tmp15_ = _tmp14_;
			gtk_container_add ((GtkContainer*) _tmp13_, (GtkWidget*) _tmp15_);
			_g_object_unref0 (_tmp15_);
			_tmp16_ = new_tab_menuitem;
			gtk_actionable_set_action_name ((GtkActionable*) _tmp16_, "win.tab");
		}
		_tmp17_ = new_tab_menuitem;
		_tmp18_ = _variant_new7 ("TAB");
		g_object_set ((GtkActionable*) _tmp17_, "action-target", _tmp18_, NULL);
		_g_variant_unref0 (_tmp18_);
		_tmp19_ = (GtkMenuItem*) gtk_menu_item_new ();
		g_object_ref_sink (_tmp19_);
		new_window_menuitem = _tmp19_;
		_tmp20_ = self->selected_files;
		if (_tmp20_ != NULL) {
			GtkMenuItem* _tmp21_;
			GraniteAccelLabel* _tmp22_;
			GraniteAccelLabel* _tmp23_;
			GtkMenuItem* _tmp24_;
			_tmp21_ = new_window_menuitem;
			_tmp22_ = granite_accel_label_new (_ ("New Window"), "<Shift><Ctrl>Return");
			g_object_ref_sink (_tmp22_);
			_tmp23_ = _tmp22_;
			gtk_container_add ((GtkContainer*) _tmp21_, (GtkWidget*) _tmp23_);
			_g_object_unref0 (_tmp23_);
			_tmp24_ = new_window_menuitem;
			gtk_actionable_set_action_name ((GtkActionable*) _tmp24_, "common.open-in");
		} else {
			GtkMenuItem* _tmp25_;
			GraniteAccelLabel* _tmp26_;
			GraniteAccelLabel* _tmp27_;
			GtkMenuItem* _tmp28_;
			_tmp25_ = new_window_menuitem;
			_tmp26_ = granite_accel_label_new_from_action_name (_ ("New Window"), "win.tab::WINDOW");
			g_object_ref_sink (_tmp26_);
			_tmp27_ = _tmp26_;
			gtk_container_add ((GtkContainer*) _tmp25_, (GtkWidget*) _tmp27_);
			_g_object_unref0 (_tmp27_);
			_tmp28_ = new_window_menuitem;
			gtk_actionable_set_action_name ((GtkActionable*) _tmp28_, "win.tab");
		}
		_tmp29_ = new_window_menuitem;
		_tmp30_ = _variant_new8 ("WINDOW");
		g_object_set ((GtkActionable*) _tmp29_, "action-target", _tmp30_, NULL);
		_g_variant_unref0 (_tmp30_);
		_tmp31_ = open_submenu;
		_tmp32_ = new_tab_menuitem;
		gtk_container_add ((GtkContainer*) _tmp31_, (GtkWidget*) _tmp32_);
		_tmp33_ = open_submenu;
		_tmp34_ = new_window_menuitem;
		gtk_container_add ((GtkContainer*) _tmp33_, (GtkWidget*) _tmp34_);
		_tmp35_ = open_submenu;
		_tmp36_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
		g_object_ref_sink (_tmp36_);
		_tmp37_ = _tmp36_;
		gtk_container_add ((GtkContainer*) _tmp35_, (GtkWidget*) _tmp37_);
		_g_object_unref0 (_tmp37_);
		_g_object_unref0 (new_window_menuitem);
		_g_object_unref0 (new_tab_menuitem);
	}
	_tmp40_ = selected_file;
	if (!files_file_is_mountable (_tmp40_)) {
		FilesFile* _tmp41_;
		_tmp41_ = selected_file;
		_tmp39_ = !files_file_is_root_network_folder (_tmp41_);
	} else {
		_tmp39_ = FALSE;
	}
	if (_tmp39_) {
		FilesFile* _tmp42_;
		_tmp42_ = selected_file;
		_tmp38_ = files_abstract_directory_view_can_open_file (self, _tmp42_, FALSE);
	} else {
		_tmp38_ = FALSE;
	}
	if (_tmp38_) {
		gboolean _tmp43_ = FALSE;
		FilesFile* _tmp44_;
		GList* _tmp65_;
		GList* _tmp66_;
		FilesFile* _tmp67_;
		gboolean _tmp68_ = FALSE;
		GList* _tmp69_;
		gboolean _tmp114_ = FALSE;
		GList* _tmp115_;
		_tmp44_ = selected_file;
		if (!files_file_is_folder (_tmp44_)) {
			FilesFile* _tmp45_;
			_tmp45_ = selected_file;
			_tmp43_ = files_file_is_executable (_tmp45_);
		} else {
			_tmp43_ = FALSE;
		}
		if (_tmp43_) {
			GtkMenuItem* run_menuitem = NULL;
			GtkMenuItem* _tmp46_;
			GtkMenuItem* _tmp47_;
			GtkMenu* _tmp48_;
			GtkMenuItem* _tmp49_;
			_tmp46_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_ ("Run"));
			g_object_ref_sink (_tmp46_);
			run_menuitem = _tmp46_;
			_tmp47_ = run_menuitem;
			gtk_actionable_set_action_name ((GtkActionable*) _tmp47_, "selection.open");
			_tmp48_ = menu;
			_tmp49_ = run_menuitem;
			gtk_container_add ((GtkContainer*) _tmp48_, (GtkWidget*) _tmp49_);
			_g_object_unref0 (run_menuitem);
		} else {
			gboolean _tmp50_ = FALSE;
			GAppInfo* _tmp51_;
			_tmp51_ = self->priv->default_app;
			if (_tmp51_ != NULL) {
				GAppInfo* _tmp52_;
				const gchar* _tmp53_;
				_tmp52_ = self->priv->default_app;
				_tmp53_ = g_app_info_get_id (_tmp52_);
				_tmp50_ = g_strcmp0 (_tmp53_, FILES_APP_ID ".desktop") != 0;
			} else {
				_tmp50_ = FALSE;
			}
			if (_tmp50_) {
				GtkMenuItem* open_menuitem = NULL;
				GtkMenuItem* _tmp54_;
				GtkMenuItem* _tmp55_;
				GAppInfo* _tmp56_;
				const gchar* _tmp57_;
				gchar* _tmp58_;
				gchar* _tmp59_;
				GraniteAccelLabel* _tmp60_;
				GraniteAccelLabel* _tmp61_;
				GtkMenuItem* _tmp62_;
				GtkMenu* _tmp63_;
				GtkMenuItem* _tmp64_;
				_tmp54_ = (GtkMenuItem*) gtk_menu_item_new ();
				g_object_ref_sink (_tmp54_);
				open_menuitem = _tmp54_;
				_tmp55_ = open_menuitem;
				_tmp56_ = self->priv->default_app;
				_tmp57_ = g_app_info_get_display_name (_tmp56_);
				_tmp58_ = g_strdup_printf (_ ("Open in %s"), _tmp57_);
				_tmp59_ = _tmp58_;
				_tmp60_ = granite_accel_label_new (_tmp59_, "Return");
				g_object_ref_sink (_tmp60_);
				_tmp61_ = _tmp60_;
				gtk_container_add ((GtkContainer*) _tmp55_, (GtkWidget*) _tmp61_);
				_g_object_unref0 (_tmp61_);
				_g_free0 (_tmp59_);
				_tmp62_ = open_menuitem;
				gtk_actionable_set_action_name ((GtkActionable*) _tmp62_, "selection.open-with-default");
				_tmp63_ = menu;
				_tmp64_ = open_menuitem;
				gtk_container_add ((GtkContainer*) _tmp63_, (GtkWidget*) _tmp64_);
				_g_object_unref0 (open_menuitem);
			}
		}
		_tmp65_ = selection;
		_tmp66_ = files_mime_actions_get_applications_for_files (_tmp65_);
		(self->priv->open_with_apps == NULL) ? NULL : (self->priv->open_with_apps = (_g_list_free__g_object_unref0_ (self->priv->open_with_apps), NULL));
		self->priv->open_with_apps = _tmp66_;
		_tmp67_ = selected_file;
		if (files_file_is_executable (_tmp67_) == FALSE) {
			files_abstract_directory_view_filter_default_app_from_open_with_apps (self);
		}
		files_abstract_directory_view_filter_this_app_from_open_with_apps (self);
		_tmp69_ = self->priv->open_with_apps;
		if (_tmp69_ != NULL) {
			GList* _tmp70_;
			gconstpointer _tmp71_;
			_tmp70_ = self->priv->open_with_apps;
			_tmp71_ = _tmp70_->data;
			_tmp68_ = ((GAppInfo*) _tmp71_) != NULL;
		} else {
			_tmp68_ = FALSE;
		}
		if (_tmp68_) {
			const gchar* last_label = NULL;
			const gchar* last_exec = NULL;
			guint count = 0U;
			GList* _tmp72_;
			last_label = "";
			last_exec = "";
			count = (guint) 0;
			_tmp72_ = self->priv->open_with_apps;
			{
				GList* app_info_collection = NULL;
				GList* app_info_it = NULL;
				app_info_collection = _tmp72_;
				for (app_info_it = app_info_collection; app_info_it != NULL; app_info_it = app_info_it->next) {
					GAppInfo* app_info = NULL;
					app_info = (GAppInfo*) app_info_it->data;
					{
						const gchar* label = NULL;
						GAppInfo* _tmp73_;
						const gchar* _tmp74_;
						const gchar* exec = NULL;
						GAppInfo* _tmp75_;
						const gchar* _tmp76_;
						gchar** _tmp77_;
						gchar** _tmp78_;
						gchar** _tmp79_;
						gint _tmp79__length1;
						const gchar* _tmp80_;
						const gchar* _tmp81_;
						gboolean _tmp82_ = FALSE;
						const gchar* _tmp83_;
						const gchar* _tmp84_;
						const gchar* _tmp108_;
						const gchar* _tmp109_;
						guint _tmp110_;
						_tmp73_ = app_info;
						_tmp74_ = g_app_info_get_display_name (_tmp73_);
						label = _tmp74_;
						_tmp75_ = app_info;
						_tmp76_ = g_app_info_get_executable (_tmp75_);
						_tmp78_ = _tmp77_ = g_strsplit (_tmp76_, " ", 0);
						_tmp79_ = _tmp78_;
						_tmp79__length1 = _vala_array_length (_tmp77_);
						_tmp80_ = _tmp79_[0];
						_tmp81_ = _tmp80_;
						_tmp79_ = (_vala_array_free (_tmp79_, _tmp79__length1, (GDestroyNotify) g_free), NULL);
						exec = _tmp81_;
						_tmp83_ = label;
						_tmp84_ = last_label;
						if (g_strcmp0 (_tmp83_, _tmp84_) != 0) {
							_tmp82_ = TRUE;
						} else {
							const gchar* _tmp85_;
							const gchar* _tmp86_;
							_tmp85_ = exec;
							_tmp86_ = last_exec;
							_tmp82_ = g_strcmp0 (_tmp85_, _tmp86_) != 0;
						}
						if (_tmp82_) {
							GtkImage* app_image = NULL;
							GAppInfo* _tmp87_;
							GIcon* _tmp88_;
							GtkImage* _tmp89_;
							GtkImage* _tmp90_;
							GtkGrid* label_grid = NULL;
							GtkGrid* _tmp91_;
							GtkGrid* _tmp92_;
							GtkImage* _tmp93_;
							GtkGrid* _tmp94_;
							const gchar* _tmp95_;
							GtkLabel* _tmp96_;
							GtkLabel* _tmp97_;
							GtkMenuItem* menuitem = NULL;
							GtkMenuItem* _tmp98_;
							GtkMenuItem* _tmp99_;
							GtkGrid* _tmp100_;
							GtkMenuItem* _tmp101_;
							GVariant* _tmp102_;
							GVariant* _tmp103_;
							gchar* _tmp104_;
							gchar* _tmp105_;
							GtkMenu* _tmp106_;
							GtkMenuItem* _tmp107_;
							_tmp87_ = app_info;
							_tmp88_ = g_app_info_get_icon (_tmp87_);
							_tmp89_ = (GtkImage*) gtk_image_new_from_gicon (_tmp88_, (GtkIconSize) GTK_ICON_SIZE_MENU);
							g_object_ref_sink (_tmp89_);
							app_image = _tmp89_;
							_tmp90_ = app_image;
							gtk_image_set_pixel_size (_tmp90_, 16);
							_tmp91_ = (GtkGrid*) gtk_grid_new ();
							g_object_ref_sink (_tmp91_);
							label_grid = _tmp91_;
							_tmp92_ = label_grid;
							_tmp93_ = app_image;
							gtk_container_add ((GtkContainer*) _tmp92_, (GtkWidget*) _tmp93_);
							_tmp94_ = label_grid;
							_tmp95_ = label;
							_tmp96_ = (GtkLabel*) gtk_label_new (_tmp95_);
							g_object_ref_sink (_tmp96_);
							_tmp97_ = _tmp96_;
							gtk_container_add ((GtkContainer*) _tmp94_, (GtkWidget*) _tmp97_);
							_g_object_unref0 (_tmp97_);
							_tmp98_ = (GtkMenuItem*) gtk_menu_item_new ();
							g_object_ref_sink (_tmp98_);
							menuitem = _tmp98_;
							_tmp99_ = menuitem;
							_tmp100_ = label_grid;
							gtk_container_add ((GtkContainer*) _tmp99_, (GtkWidget*) _tmp100_);
							_tmp101_ = menuitem;
							_tmp102_ = g_variant_new_uint32 ((guint32) count);
							g_variant_ref_sink (_tmp102_);
							_tmp103_ = _tmp102_;
							_tmp104_ = g_action_print_detailed_name ("selection.open-with-app", _tmp103_);
							_tmp105_ = _tmp104_;
							gtk_actionable_set_detailed_action_name ((GtkActionable*) _tmp101_, _tmp105_);
							_g_free0 (_tmp105_);
							_g_variant_unref0 (_tmp103_);
							_tmp106_ = open_submenu;
							_tmp107_ = menuitem;
							gtk_container_add ((GtkContainer*) _tmp106_, (GtkWidget*) _tmp107_);
							_g_object_unref0 (menuitem);
							_g_object_unref0 (label_grid);
							_g_object_unref0 (app_image);
						}
						_tmp108_ = label;
						last_label = _tmp108_;
						_tmp109_ = exec;
						last_exec = _tmp109_;
						_tmp110_ = count;
						count = _tmp110_ + 1;
					}
				}
			}
			if (count > ((guint) 0)) {
				GtkMenu* _tmp111_;
				GtkSeparatorMenuItem* _tmp112_;
				GtkSeparatorMenuItem* _tmp113_;
				_tmp111_ = open_submenu;
				_tmp112_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
				g_object_ref_sink (_tmp112_);
				_tmp113_ = _tmp112_;
				gtk_container_add ((GtkContainer*) _tmp111_, (GtkWidget*) _tmp113_);
				_g_object_unref0 (_tmp113_);
			}
		}
		_tmp115_ = selection;
		if (_tmp115_ != NULL) {
			GList* _tmp116_;
			GList* _tmp117_;
			GList* _tmp118_;
			_tmp116_ = selection;
			_tmp117_ = g_list_first (_tmp116_);
			_tmp118_ = _tmp117_->next;
			_tmp114_ = _tmp118_ == NULL;
		} else {
			_tmp114_ = FALSE;
		}
		if (_tmp114_) {
			GtkMenuItem* other_apps_menuitem = NULL;
			GtkMenuItem* _tmp119_;
			GtkMenuItem* _tmp120_;
			GtkMenu* _tmp121_;
			GtkMenuItem* _tmp122_;
			_tmp119_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_ ("Other Application…"));
			g_object_ref_sink (_tmp119_);
			other_apps_menuitem = _tmp119_;
			_tmp120_ = other_apps_menuitem;
			gtk_actionable_set_action_name ((GtkActionable*) _tmp120_, "selection.open-with-other-app");
			_tmp121_ = open_submenu;
			_tmp122_ = other_apps_menuitem;
			gtk_container_add ((GtkContainer*) _tmp121_, (GtkWidget*) _tmp122_);
			_g_object_unref0 (other_apps_menuitem);
		}
	}
	_tmp123_ = (GtkMenuItem*) gtk_menu_item_new ();
	g_object_ref_sink (_tmp123_);
	open_submenu_item = _tmp123_;
	_tmp124_ = open_submenu;
	_tmp125_ = gtk_container_get_children ((GtkContainer*) _tmp124_);
	_tmp126_ = _tmp125_;
	_tmp127_ = g_list_length (_tmp126_) > ((guint) 0);
	(_tmp126_ == NULL) ? NULL : (_tmp126_ = (g_list_free (_tmp126_), NULL));
	if (_tmp127_) {
		GtkMenuItem* _tmp128_;
		GtkMenu* _tmp129_;
		gboolean _tmp130_ = FALSE;
		FilesFile* _tmp131_;
		GtkMenu* _tmp135_;
		GtkMenuItem* _tmp136_;
		_tmp128_ = open_submenu_item;
		_tmp129_ = open_submenu;
		gtk_menu_item_set_submenu (_tmp128_, _tmp129_);
		_tmp131_ = selected_file;
		if (files_file_is_folder (_tmp131_)) {
			_tmp130_ = TRUE;
		} else {
			FilesFile* _tmp132_;
			_tmp132_ = selected_file;
			_tmp130_ = files_file_is_root_network_folder (_tmp132_);
		}
		if (_tmp130_) {
			GtkMenuItem* _tmp133_;
			_tmp133_ = open_submenu_item;
			gtk_menu_item_set_label (_tmp133_, _ ("Open in"));
		} else {
			GtkMenuItem* _tmp134_;
			_tmp134_ = open_submenu_item;
			gtk_menu_item_set_label (_tmp134_, _ ("Open with"));
		}
		_tmp135_ = menu;
		_tmp136_ = open_submenu_item;
		gtk_container_add ((GtkContainer*) _tmp135_, (GtkWidget*) _tmp136_);
	}
	_tmp137_ = (GtkMenuItem*) gtk_menu_item_new ();
	g_object_ref_sink (_tmp137_);
	paste_menuitem = _tmp137_;
	_tmp138_ = paste_menuitem;
	gtk_actionable_set_action_name ((GtkActionable*) _tmp138_, "common.paste");
	_tmp139_ = (GtkMenuItem*) gtk_menu_item_new ();
	g_object_ref_sink (_tmp139_);
	bookmark_menuitem = _tmp139_;
	_tmp140_ = bookmark_menuitem;
	_tmp141_ = granite_accel_label_new (_ ("Add to Bookmarks"), "<Ctrl>d");
	g_object_ref_sink (_tmp141_);
	_tmp142_ = _tmp141_;
	gtk_container_add ((GtkContainer*) _tmp140_, (GtkWidget*) _tmp142_);
	_g_object_unref0 (_tmp142_);
	_tmp143_ = bookmark_menuitem;
	gtk_actionable_set_action_name ((GtkActionable*) _tmp143_, "common.bookmark");
	_tmp144_ = (GtkMenuItem*) gtk_menu_item_new ();
	g_object_ref_sink (_tmp144_);
	properties_menuitem = _tmp144_;
	_tmp145_ = properties_menuitem;
	_tmp146_ = granite_accel_label_new (_ ("Properties"), "<Alt>Return");
	g_object_ref_sink (_tmp146_);
	_tmp147_ = _tmp146_;
	gtk_container_add ((GtkContainer*) _tmp145_, (GtkWidget*) _tmp147_);
	_g_object_unref0 (_tmp147_);
	_tmp148_ = properties_menuitem;
	gtk_actionable_set_action_name ((GtkActionable*) _tmp148_, "common.properties");
	select_all_menuitem = NULL;
	deselect_all_menuitem = NULL;
	invert_selection_menuitem = NULL;
	if (!self->priv->all_selected) {
		gchar* _tmp149_;
		GtkMenuItem* _tmp150_ = NULL;
		GtkMenuItem* _tmp151_;
		GtkMenuItem* _tmp152_;
		const gchar* _tmp153_;
		const gchar* _tmp154_;
		GraniteAccelLabel* _tmp155_;
		GraniteAccelLabel* _tmp156_;
		GList* _tmp157_;
		_tmp149_ = g_strdup ("common.select-all");
		_tmp150_ = (GtkMenuItem*) gtk_menu_item_new ();
		gtk_actionable_set_action_name ((GtkActionable*) _tmp150_, _tmp149_);
		_g_free0 (_tmp149_);
		g_object_ref_sink (_tmp150_);
		_g_object_unref0 (select_all_menuitem);
		select_all_menuitem = _tmp150_;
		_tmp151_ = select_all_menuitem;
		_tmp152_ = select_all_menuitem;
		_tmp153_ = gtk_actionable_get_action_name ((GtkActionable*) _tmp152_);
		_tmp154_ = _tmp153_;
		_tmp155_ = granite_accel_label_new_from_action_name (_ ("Select All"), _tmp154_);
		g_object_ref_sink (_tmp155_);
		_tmp156_ = _tmp155_;
		gtk_container_add ((GtkContainer*) _tmp151_, (GtkWidget*) _tmp156_);
		_g_object_unref0 (_tmp156_);
		_tmp157_ = files_abstract_directory_view_get_selected_files (self);
		if (_tmp157_ != NULL) {
			gchar* _tmp158_;
			GtkMenuItem* _tmp159_ = NULL;
			GtkMenuItem* _tmp160_;
			GtkMenuItem* _tmp161_;
			const gchar* _tmp162_;
			const gchar* _tmp163_;
			GraniteAccelLabel* _tmp164_;
			GraniteAccelLabel* _tmp165_;
			_tmp158_ = g_strdup ("selection.invert-selection");
			_tmp159_ = (GtkMenuItem*) gtk_menu_item_new ();
			gtk_actionable_set_action_name ((GtkActionable*) _tmp159_, _tmp158_);
			_g_free0 (_tmp158_);
			g_object_ref_sink (_tmp159_);
			_g_object_unref0 (invert_selection_menuitem);
			invert_selection_menuitem = _tmp159_;
			_tmp160_ = invert_selection_menuitem;
			_tmp161_ = invert_selection_menuitem;
			_tmp162_ = gtk_actionable_get_action_name ((GtkActionable*) _tmp161_);
			_tmp163_ = _tmp162_;
			_tmp164_ = granite_accel_label_new_from_action_name (_ ("Invert Selection"), _tmp163_);
			g_object_ref_sink (_tmp164_);
			_tmp165_ = _tmp164_;
			gtk_container_add ((GtkContainer*) _tmp160_, (GtkWidget*) _tmp165_);
			_g_object_unref0 (_tmp165_);
		}
	} else {
		gchar* _tmp166_;
		GtkMenuItem* _tmp167_ = NULL;
		GtkMenuItem* _tmp168_;
		GtkMenuItem* _tmp169_;
		const gchar* _tmp170_;
		const gchar* _tmp171_;
		GraniteAccelLabel* _tmp172_;
		GraniteAccelLabel* _tmp173_;
		_tmp166_ = g_strdup ("common.select-all");
		_tmp167_ = (GtkMenuItem*) gtk_menu_item_new ();
		gtk_actionable_set_action_name ((GtkActionable*) _tmp167_, _tmp166_);
		_g_free0 (_tmp166_);
		g_object_ref_sink (_tmp167_);
		_g_object_unref0 (deselect_all_menuitem);
		deselect_all_menuitem = _tmp167_;
		_tmp168_ = deselect_all_menuitem;
		_tmp169_ = deselect_all_menuitem;
		_tmp170_ = gtk_actionable_get_action_name ((GtkActionable*) _tmp169_);
		_tmp171_ = _tmp170_;
		_tmp172_ = granite_accel_label_new_from_action_name (_ ("Deselect All"), _tmp171_);
		g_object_ref_sink (_tmp172_);
		_tmp173_ = _tmp172_;
		gtk_container_add ((GtkContainer*) _tmp168_, (GtkWidget*) _tmp173_);
		_g_object_unref0 (_tmp173_);
	}
	_tmp174_ = files_abstract_directory_view_get_selected_files (self);
	if (_tmp174_ != NULL) {
		GtkMenuItem* cut_menuitem = NULL;
		GtkMenuItem* _tmp175_;
		GtkMenuItem* _tmp176_;
		GraniteAccelLabel* _tmp177_;
		GraniteAccelLabel* _tmp178_;
		GtkMenuItem* _tmp179_;
		GtkMenuItem* copy_menuitem = NULL;
		GtkMenuItem* _tmp180_;
		GtkMenuItem* _tmp181_;
		GraniteAccelLabel* _tmp182_;
		GraniteAccelLabel* _tmp183_;
		GtkMenuItem* _tmp184_;
		GtkMenuItem* trash_menuitem = NULL;
		GtkMenuItem* _tmp185_;
		GtkMenuItem* _tmp186_;
		GraniteAccelLabel* _tmp187_;
		GraniteAccelLabel* _tmp188_;
		GtkMenuItem* _tmp189_;
		GtkMenuItem* delete_menuitem = NULL;
		gchar* _tmp190_;
		GtkMenuItem* _tmp191_ = NULL;
		GtkMenuItem* _tmp192_;
		GtkStyleContext* _tmp193_;
		gboolean _tmp194_ = FALSE;
		_tmp175_ = (GtkMenuItem*) gtk_menu_item_new ();
		g_object_ref_sink (_tmp175_);
		cut_menuitem = _tmp175_;
		_tmp176_ = cut_menuitem;
		_tmp177_ = granite_accel_label_new (_ ("Cut"), "<Ctrl>x");
		g_object_ref_sink (_tmp177_);
		_tmp178_ = _tmp177_;
		gtk_container_add ((GtkContainer*) _tmp176_, (GtkWidget*) _tmp178_);
		_g_object_unref0 (_tmp178_);
		_tmp179_ = cut_menuitem;
		gtk_actionable_set_action_name ((GtkActionable*) _tmp179_, "selection.cut");
		_tmp180_ = (GtkMenuItem*) gtk_menu_item_new ();
		g_object_ref_sink (_tmp180_);
		copy_menuitem = _tmp180_;
		_tmp181_ = copy_menuitem;
		_tmp182_ = granite_accel_label_new (_ ("Copy"), "<Ctrl>c");
		g_object_ref_sink (_tmp182_);
		_tmp183_ = _tmp182_;
		gtk_container_add ((GtkContainer*) _tmp181_, (GtkWidget*) _tmp183_);
		_g_object_unref0 (_tmp183_);
		_tmp184_ = copy_menuitem;
		gtk_actionable_set_action_name ((GtkActionable*) _tmp184_, "common.copy");
		_tmp185_ = (GtkMenuItem*) gtk_menu_item_new ();
		g_object_ref_sink (_tmp185_);
		trash_menuitem = _tmp185_;
		_tmp186_ = trash_menuitem;
		_tmp187_ = granite_accel_label_new (_ ("Move to Trash"), "Delete");
		g_object_ref_sink (_tmp187_);
		_tmp188_ = _tmp187_;
		gtk_container_add ((GtkContainer*) _tmp186_, (GtkWidget*) _tmp188_);
		_g_object_unref0 (_tmp188_);
		_tmp189_ = trash_menuitem;
		gtk_actionable_set_action_name ((GtkActionable*) _tmp189_, "selection.trash");
		_tmp190_ = g_strdup ("selection.delete");
		_tmp191_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_ ("Delete Permanently"));
		gtk_actionable_set_action_name ((GtkActionable*) _tmp191_, _tmp190_);
		_g_free0 (_tmp190_);
		g_object_ref_sink (_tmp191_);
		delete_menuitem = _tmp191_;
		_tmp192_ = delete_menuitem;
		_tmp193_ = gtk_widget_get_style_context ((GtkWidget*) _tmp192_);
		gtk_style_context_add_class (_tmp193_, GTK_STYLE_CLASS_DESTRUCTIVE_ACTION);
		if (self->priv->in_trash) {
			_tmp194_ = files_abstract_directory_view_valid_selection_for_restore (self);
		} else {
			_tmp194_ = FALSE;
		}
		if (_tmp194_) {
			GtkMenuItem* restore_menuitem = NULL;
			GtkMenuItem* _tmp195_;
			GtkMenuItem* _tmp196_;
			GtkMenu* _tmp197_;
			GtkSeparatorMenuItem* _tmp198_;
			GtkSeparatorMenuItem* _tmp199_;
			GtkMenu* _tmp200_;
			GtkMenuItem* _tmp201_;
			GtkMenu* _tmp202_;
			GtkMenuItem* _tmp203_;
			GtkMenu* _tmp204_;
			GtkSeparatorMenuItem* _tmp205_;
			GtkSeparatorMenuItem* _tmp206_;
			GtkMenu* _tmp207_;
			GtkMenuItem* _tmp208_;
			GtkMenuItem* _tmp209_;
			GtkMenuItem* _tmp212_;
			GtkMenuItem* _tmp215_;
			GtkMenu* _tmp218_;
			GtkSeparatorMenuItem* _tmp219_;
			GtkSeparatorMenuItem* _tmp220_;
			GtkMenu* _tmp221_;
			GtkMenuItem* _tmp222_;
			_tmp195_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_ ("Restore from Trash"));
			g_object_ref_sink (_tmp195_);
			restore_menuitem = _tmp195_;
			_tmp196_ = restore_menuitem;
			gtk_actionable_set_action_name ((GtkActionable*) _tmp196_, "selection.restore");
			_tmp197_ = menu;
			_tmp198_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
			g_object_ref_sink (_tmp198_);
			_tmp199_ = _tmp198_;
			gtk_container_add ((GtkContainer*) _tmp197_, (GtkWidget*) _tmp199_);
			_g_object_unref0 (_tmp199_);
			_tmp200_ = menu;
			_tmp201_ = restore_menuitem;
			gtk_container_add ((GtkContainer*) _tmp200_, (GtkWidget*) _tmp201_);
			_tmp202_ = menu;
			_tmp203_ = delete_menuitem;
			gtk_container_add ((GtkContainer*) _tmp202_, (GtkWidget*) _tmp203_);
			_tmp204_ = menu;
			_tmp205_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
			g_object_ref_sink (_tmp205_);
			_tmp206_ = _tmp205_;
			gtk_container_add ((GtkContainer*) _tmp204_, (GtkWidget*) _tmp206_);
			_g_object_unref0 (_tmp206_);
			_tmp207_ = menu;
			_tmp208_ = cut_menuitem;
			gtk_container_add ((GtkContainer*) _tmp207_, (GtkWidget*) _tmp208_);
			_tmp209_ = select_all_menuitem;
			if (_tmp209_ != NULL) {
				GtkMenu* _tmp210_;
				GtkMenuItem* _tmp211_;
				_tmp210_ = menu;
				_tmp211_ = select_all_menuitem;
				gtk_container_add ((GtkContainer*) _tmp210_, (GtkWidget*) _tmp211_);
			}
			_tmp212_ = deselect_all_menuitem;
			if (_tmp212_ != NULL) {
				GtkMenu* _tmp213_;
				GtkMenuItem* _tmp214_;
				_tmp213_ = menu;
				_tmp214_ = deselect_all_menuitem;
				gtk_container_add ((GtkContainer*) _tmp213_, (GtkWidget*) _tmp214_);
			}
			_tmp215_ = invert_selection_menuitem;
			if (_tmp215_ != NULL) {
				GtkMenu* _tmp216_;
				GtkMenuItem* _tmp217_;
				_tmp216_ = menu;
				_tmp217_ = invert_selection_menuitem;
				gtk_container_add ((GtkContainer*) _tmp216_, (GtkWidget*) _tmp217_);
			}
			_tmp218_ = menu;
			_tmp219_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
			g_object_ref_sink (_tmp219_);
			_tmp220_ = _tmp219_;
			gtk_container_add ((GtkContainer*) _tmp218_, (GtkWidget*) _tmp220_);
			_g_object_unref0 (_tmp220_);
			_tmp221_ = menu;
			_tmp222_ = properties_menuitem;
			gtk_container_add ((GtkContainer*) _tmp221_, (GtkWidget*) _tmp222_);
			_g_object_unref0 (restore_menuitem);
		} else {
			gboolean _tmp223_;
			_tmp223_ = self->priv->_in_recent;
			if (_tmp223_) {
				GtkMenuItem* open_parent_menuitem = NULL;
				GtkMenuItem* _tmp224_;
				GtkMenuItem* _tmp225_;
				GtkMenuItem* forget_menuitem = NULL;
				GtkMenuItem* _tmp226_;
				GtkMenuItem* _tmp227_;
				GtkMenu* _tmp228_;
				GtkMenuItem* _tmp229_;
				GtkMenu* _tmp230_;
				GtkSeparatorMenuItem* _tmp231_;
				GtkSeparatorMenuItem* _tmp232_;
				GtkMenu* _tmp233_;
				GtkMenuItem* _tmp234_;
				GtkMenu* _tmp235_;
				GtkMenuItem* _tmp236_;
				GtkMenuItem* _tmp237_;
				GtkMenuItem* _tmp240_;
				GtkMenuItem* _tmp243_;
				GtkMenu* _tmp246_;
				GtkMenuItem* _tmp247_;
				GtkMenu* _tmp248_;
				GtkSeparatorMenuItem* _tmp249_;
				GtkSeparatorMenuItem* _tmp250_;
				GtkMenu* _tmp251_;
				GtkMenuItem* _tmp252_;
				_tmp224_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_ ("Open Parent Folder"));
				g_object_ref_sink (_tmp224_);
				open_parent_menuitem = _tmp224_;
				_tmp225_ = open_parent_menuitem;
				gtk_actionable_set_action_name ((GtkActionable*) _tmp225_, "selection.view-in-location");
				_tmp226_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_ ("Remove from History"));
				g_object_ref_sink (_tmp226_);
				forget_menuitem = _tmp226_;
				_tmp227_ = forget_menuitem;
				gtk_actionable_set_action_name ((GtkActionable*) _tmp227_, "selection.forget");
				_tmp228_ = menu;
				_tmp229_ = open_parent_menuitem;
				gtk_container_add ((GtkContainer*) _tmp228_, (GtkWidget*) _tmp229_);
				_tmp230_ = menu;
				_tmp231_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
				g_object_ref_sink (_tmp231_);
				_tmp232_ = _tmp231_;
				gtk_container_add ((GtkContainer*) _tmp230_, (GtkWidget*) _tmp232_);
				_g_object_unref0 (_tmp232_);
				_tmp233_ = menu;
				_tmp234_ = forget_menuitem;
				gtk_container_add ((GtkContainer*) _tmp233_, (GtkWidget*) _tmp234_);
				_tmp235_ = menu;
				_tmp236_ = copy_menuitem;
				gtk_container_add ((GtkContainer*) _tmp235_, (GtkWidget*) _tmp236_);
				_tmp237_ = select_all_menuitem;
				if (_tmp237_ != NULL) {
					GtkMenu* _tmp238_;
					GtkMenuItem* _tmp239_;
					_tmp238_ = menu;
					_tmp239_ = select_all_menuitem;
					gtk_container_add ((GtkContainer*) _tmp238_, (GtkWidget*) _tmp239_);
				}
				_tmp240_ = deselect_all_menuitem;
				if (_tmp240_ != NULL) {
					GtkMenu* _tmp241_;
					GtkMenuItem* _tmp242_;
					_tmp241_ = menu;
					_tmp242_ = deselect_all_menuitem;
					gtk_container_add ((GtkContainer*) _tmp241_, (GtkWidget*) _tmp242_);
				}
				_tmp243_ = invert_selection_menuitem;
				if (_tmp243_ != NULL) {
					GtkMenu* _tmp244_;
					GtkMenuItem* _tmp245_;
					_tmp244_ = menu;
					_tmp245_ = invert_selection_menuitem;
					gtk_container_add ((GtkContainer*) _tmp244_, (GtkWidget*) _tmp245_);
				}
				_tmp246_ = menu;
				_tmp247_ = trash_menuitem;
				gtk_container_add ((GtkContainer*) _tmp246_, (GtkWidget*) _tmp247_);
				_tmp248_ = menu;
				_tmp249_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
				g_object_ref_sink (_tmp249_);
				_tmp250_ = _tmp249_;
				gtk_container_add ((GtkContainer*) _tmp248_, (GtkWidget*) _tmp250_);
				_g_object_unref0 (_tmp250_);
				_tmp251_ = menu;
				_tmp252_ = properties_menuitem;
				gtk_container_add ((GtkContainer*) _tmp251_, (GtkWidget*) _tmp252_);
				_g_object_unref0 (forget_menuitem);
				_g_object_unref0 (open_parent_menuitem);
			} else {
				gboolean _tmp334_ = FALSE;
				GSimpleActionGroup* _tmp335_;
				GtkMenu* _tmp343_;
				GtkSeparatorMenuItem* _tmp344_;
				GtkSeparatorMenuItem* _tmp345_;
				GtkMenu* _tmp346_;
				GtkMenuItem* _tmp347_;
				if (files_abstract_directory_view_valid_selection_for_edit (self)) {
					GtkMenuItem* rename_menuitem = NULL;
					GtkMenuItem* _tmp253_;
					GtkMenuItem* _tmp254_;
					GraniteAccelLabel* _tmp255_;
					GraniteAccelLabel* _tmp256_;
					GtkMenuItem* _tmp257_;
					GtkMenuItem* copy_link_menuitem = NULL;
					GtkMenuItem* _tmp258_;
					GtkMenuItem* _tmp259_;
					GraniteAccelLabel* _tmp260_;
					GraniteAccelLabel* _tmp261_;
					GtkMenuItem* _tmp262_;
					GtkMenu* _tmp263_;
					GList* _tmp264_;
					GList* _tmp265_;
					GtkMenuItem* _tmp266_;
					GList* _tmp267_;
					gboolean _tmp268_;
					GtkMenu* _tmp272_;
					GtkMenuItem* _tmp273_;
					GtkMenu* _tmp274_;
					GtkMenuItem* _tmp275_;
					GtkMenu* _tmp276_;
					GtkMenuItem* _tmp277_;
					gboolean _tmp278_ = FALSE;
					gboolean _tmp279_ = FALSE;
					GSimpleActionGroup* _tmp280_;
					GtkMenuItem* _tmp310_;
					GtkMenuItem* _tmp313_;
					GtkMenuItem* _tmp316_;
					GtkMenu* _tmp319_;
					GtkSeparatorMenuItem* _tmp320_;
					GtkSeparatorMenuItem* _tmp321_;
					gboolean _tmp322_ = FALSE;
					FilesViewSlot* _tmp323_;
					FilesDirectory* _tmp324_;
					FilesDirectory* _tmp325_;
					gboolean _tmp326_;
					gboolean _tmp327_;
					GtkMenu* _tmp332_;
					GtkMenuItem* _tmp333_;
					_tmp253_ = (GtkMenuItem*) gtk_menu_item_new ();
					g_object_ref_sink (_tmp253_);
					rename_menuitem = _tmp253_;
					_tmp254_ = rename_menuitem;
					_tmp255_ = granite_accel_label_new (_ ("Rename…"), "F2");
					g_object_ref_sink (_tmp255_);
					_tmp256_ = _tmp255_;
					gtk_container_add ((GtkContainer*) _tmp254_, (GtkWidget*) _tmp256_);
					_g_object_unref0 (_tmp256_);
					_tmp257_ = rename_menuitem;
					gtk_actionable_set_action_name ((GtkActionable*) _tmp257_, "selection.rename");
					_tmp258_ = (GtkMenuItem*) gtk_menu_item_new ();
					g_object_ref_sink (_tmp258_);
					copy_link_menuitem = _tmp258_;
					_tmp259_ = copy_link_menuitem;
					_tmp260_ = granite_accel_label_new (_ ("Copy as Link"), "<Shift><Ctrl>c");
					g_object_ref_sink (_tmp260_);
					_tmp261_ = _tmp260_;
					gtk_container_add ((GtkContainer*) _tmp259_, (GtkWidget*) _tmp261_);
					_g_object_unref0 (_tmp261_);
					_tmp262_ = copy_link_menuitem;
					gtk_actionable_set_action_name ((GtkActionable*) _tmp262_, "common.copy-link");
					_tmp263_ = menu;
					_tmp264_ = gtk_container_get_children ((GtkContainer*) _tmp263_);
					_tmp265_ = _tmp264_;
					_tmp266_ = open_submenu_item;
					_tmp267_ = g_list_find (_tmp265_, (GtkWidget*) _tmp266_);
					_tmp268_ = _tmp267_ != NULL;
					(_tmp265_ == NULL) ? NULL : (_tmp265_ = (g_list_free (_tmp265_), NULL));
					if (_tmp268_) {
						GtkMenu* _tmp269_;
						GtkSeparatorMenuItem* _tmp270_;
						GtkSeparatorMenuItem* _tmp271_;
						_tmp269_ = menu;
						_tmp270_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
						g_object_ref_sink (_tmp270_);
						_tmp271_ = _tmp270_;
						gtk_container_add ((GtkContainer*) _tmp269_, (GtkWidget*) _tmp271_);
						_g_object_unref0 (_tmp271_);
					}
					_tmp272_ = menu;
					_tmp273_ = cut_menuitem;
					gtk_container_add ((GtkContainer*) _tmp272_, (GtkWidget*) _tmp273_);
					_tmp274_ = menu;
					_tmp275_ = copy_menuitem;
					gtk_container_add ((GtkContainer*) _tmp274_, (GtkWidget*) _tmp275_);
					_tmp276_ = menu;
					_tmp277_ = copy_link_menuitem;
					gtk_container_add ((GtkContainer*) _tmp276_, (GtkWidget*) _tmp277_);
					_tmp280_ = self->priv->common_actions;
					if (g_action_group_get_action_enabled ((GActionGroup*) _tmp280_, "paste-into")) {
						FilesClipboardManager* _tmp281_;
						_tmp281_ = self->priv->clipboard;
						_tmp279_ = _tmp281_ != NULL;
					} else {
						_tmp279_ = FALSE;
					}
					if (_tmp279_) {
						FilesClipboardManager* _tmp282_;
						gboolean _tmp283_;
						gboolean _tmp284_;
						_tmp282_ = self->priv->clipboard;
						_tmp283_ = files_clipboard_manager_get_can_paste (_tmp282_);
						_tmp284_ = _tmp283_;
						_tmp278_ = _tmp284_;
					} else {
						_tmp278_ = FALSE;
					}
					if (_tmp278_) {
						GtkMenuItem* paste_into_menuitem = NULL;
						gchar* _tmp285_;
						GtkMenuItem* _tmp286_ = NULL;
						FilesClipboardManager* _tmp287_;
						gboolean _tmp288_;
						gboolean _tmp289_;
						GtkMenu* _tmp296_;
						GtkMenuItem* _tmp297_;
						_tmp285_ = g_strdup ("common.paste-into");
						_tmp286_ = (GtkMenuItem*) gtk_menu_item_new ();
						gtk_actionable_set_action_name ((GtkActionable*) _tmp286_, _tmp285_);
						_g_free0 (_tmp285_);
						g_object_ref_sink (_tmp286_);
						paste_into_menuitem = _tmp286_;
						_tmp287_ = self->priv->clipboard;
						_tmp288_ = files_clipboard_manager_get_files_linked (_tmp287_);
						_tmp289_ = _tmp288_;
						if (_tmp289_) {
							GtkMenuItem* _tmp290_;
							GraniteAccelLabel* _tmp291_;
							GraniteAccelLabel* _tmp292_;
							_tmp290_ = paste_into_menuitem;
							_tmp291_ = granite_accel_label_new (_ ("Paste Link into Folder"), "<Shift><Ctrl>v");
							g_object_ref_sink (_tmp291_);
							_tmp292_ = _tmp291_;
							gtk_container_add ((GtkContainer*) _tmp290_, (GtkWidget*) _tmp292_);
							_g_object_unref0 (_tmp292_);
						} else {
							GtkMenuItem* _tmp293_;
							GraniteAccelLabel* _tmp294_;
							GraniteAccelLabel* _tmp295_;
							_tmp293_ = paste_into_menuitem;
							_tmp294_ = granite_accel_label_new (_ ("Paste into Folder"), "<Shift><Ctrl>v");
							g_object_ref_sink (_tmp294_);
							_tmp295_ = _tmp294_;
							gtk_container_add ((GtkContainer*) _tmp293_, (GtkWidget*) _tmp295_);
							_g_object_unref0 (_tmp295_);
						}
						_tmp296_ = menu;
						_tmp297_ = paste_into_menuitem;
						gtk_container_add ((GtkContainer*) _tmp296_, (GtkWidget*) _tmp297_);
						_g_object_unref0 (paste_into_menuitem);
					} else {
						gboolean _tmp298_ = FALSE;
						gboolean _tmp299_ = FALSE;
						GSimpleActionGroup* _tmp300_;
						_tmp300_ = self->priv->common_actions;
						if (g_action_group_get_action_enabled ((GActionGroup*) _tmp300_, "paste")) {
							FilesClipboardManager* _tmp301_;
							_tmp301_ = self->priv->clipboard;
							_tmp299_ = _tmp301_ != NULL;
						} else {
							_tmp299_ = FALSE;
						}
						if (_tmp299_) {
							FilesClipboardManager* _tmp302_;
							gboolean _tmp303_;
							gboolean _tmp304_;
							_tmp302_ = self->priv->clipboard;
							_tmp303_ = files_clipboard_manager_get_can_paste (_tmp302_);
							_tmp304_ = _tmp303_;
							_tmp298_ = _tmp304_;
						} else {
							_tmp298_ = FALSE;
						}
						if (_tmp298_) {
							GtkMenuItem* _tmp305_;
							GraniteAccelLabel* _tmp306_;
							GraniteAccelLabel* _tmp307_;
							GtkMenu* _tmp308_;
							GtkMenuItem* _tmp309_;
							_tmp305_ = paste_menuitem;
							_tmp306_ = granite_accel_label_new (_ ("Paste"), "<Ctrl>v");
							g_object_ref_sink (_tmp306_);
							_tmp307_ = _tmp306_;
							gtk_container_add ((GtkContainer*) _tmp305_, (GtkWidget*) _tmp307_);
							_g_object_unref0 (_tmp307_);
							_tmp308_ = menu;
							_tmp309_ = paste_menuitem;
							gtk_container_add ((GtkContainer*) _tmp308_, (GtkWidget*) _tmp309_);
						}
					}
					_tmp310_ = select_all_menuitem;
					if (_tmp310_ != NULL) {
						GtkMenu* _tmp311_;
						GtkMenuItem* _tmp312_;
						_tmp311_ = menu;
						_tmp312_ = select_all_menuitem;
						gtk_container_add ((GtkContainer*) _tmp311_, (GtkWidget*) _tmp312_);
					}
					_tmp313_ = deselect_all_menuitem;
					if (_tmp313_ != NULL) {
						GtkMenu* _tmp314_;
						GtkMenuItem* _tmp315_;
						_tmp314_ = menu;
						_tmp315_ = deselect_all_menuitem;
						gtk_container_add ((GtkContainer*) _tmp314_, (GtkWidget*) _tmp315_);
					}
					_tmp316_ = invert_selection_menuitem;
					if (_tmp316_ != NULL) {
						GtkMenu* _tmp317_;
						GtkMenuItem* _tmp318_;
						_tmp317_ = menu;
						_tmp318_ = invert_selection_menuitem;
						gtk_container_add ((GtkContainer*) _tmp317_, (GtkWidget*) _tmp318_);
					}
					_tmp319_ = menu;
					_tmp320_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
					g_object_ref_sink (_tmp320_);
					_tmp321_ = _tmp320_;
					gtk_container_add ((GtkContainer*) _tmp319_, (GtkWidget*) _tmp321_);
					_g_object_unref0 (_tmp321_);
					_tmp323_ = self->slot;
					_tmp324_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp323_);
					_tmp325_ = _tmp324_;
					_tmp326_ = files_directory_get_has_trash_dirs (_tmp325_);
					_tmp327_ = _tmp326_;
					if (_tmp327_) {
						_tmp322_ = !files_is_admin ();
					} else {
						_tmp322_ = FALSE;
					}
					if (_tmp322_) {
						GtkMenu* _tmp328_;
						GtkMenuItem* _tmp329_;
						_tmp328_ = menu;
						_tmp329_ = trash_menuitem;
						gtk_container_add ((GtkContainer*) _tmp328_, (GtkWidget*) _tmp329_);
					} else {
						GtkMenu* _tmp330_;
						GtkMenuItem* _tmp331_;
						_tmp330_ = menu;
						_tmp331_ = delete_menuitem;
						gtk_container_add ((GtkContainer*) _tmp330_, (GtkWidget*) _tmp331_);
					}
					_tmp332_ = menu;
					_tmp333_ = rename_menuitem;
					gtk_container_add ((GtkContainer*) _tmp332_, (GtkWidget*) _tmp333_);
					_g_object_unref0 (copy_link_menuitem);
					_g_object_unref0 (rename_menuitem);
				}
				_tmp335_ = self->priv->common_actions;
				if (g_action_group_get_action_enabled ((GActionGroup*) _tmp335_, "bookmark")) {
					FilesViewWindow* _tmp336_;
					GList* _tmp337_;
					gconstpointer _tmp338_;
					const gchar* _tmp339_;
					const gchar* _tmp340_;
					_tmp336_ = self->window;
					_tmp337_ = self->selected_files;
					_tmp338_ = _tmp337_->data;
					_tmp339_ = files_file_get_uri ((FilesFile*) _tmp338_);
					_tmp340_ = _tmp339_;
					_tmp334_ = files_view_window_can_bookmark_uri (_tmp336_, _tmp340_);
				} else {
					_tmp334_ = FALSE;
				}
				if (_tmp334_) {
					GtkMenu* _tmp341_;
					GtkMenuItem* _tmp342_;
					_tmp341_ = menu;
					_tmp342_ = bookmark_menuitem;
					gtk_container_add ((GtkContainer*) _tmp341_, (GtkWidget*) _tmp342_);
				}
				_tmp343_ = menu;
				_tmp344_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
				g_object_ref_sink (_tmp344_);
				_tmp345_ = _tmp344_;
				gtk_container_add ((GtkContainer*) _tmp343_, (GtkWidget*) _tmp345_);
				_g_object_unref0 (_tmp345_);
				_tmp346_ = menu;
				_tmp347_ = properties_menuitem;
				gtk_container_add ((GtkContainer*) _tmp346_, (GtkWidget*) _tmp347_);
			}
		}
		_g_object_unref0 (delete_menuitem);
		_g_object_unref0 (trash_menuitem);
		_g_object_unref0 (copy_menuitem);
		_g_object_unref0 (cut_menuitem);
	} else {
		if (self->priv->in_trash) {
			gboolean _tmp348_ = FALSE;
			FilesClipboardManager* _tmp349_;
			_tmp349_ = self->priv->clipboard;
			if (_tmp349_ != NULL) {
				FilesClipboardManager* _tmp350_;
				_tmp350_ = self->priv->clipboard;
				_tmp348_ = files_clipboard_manager_has_cutted_file (_tmp350_, NULL);
			} else {
				_tmp348_ = FALSE;
			}
			if (_tmp348_) {
				GtkMenuItem* _tmp351_;
				GraniteAccelLabel* _tmp352_;
				GraniteAccelLabel* _tmp353_;
				GtkMenu* _tmp354_;
				GtkMenuItem* _tmp355_;
				GtkMenuItem* _tmp356_;
				_tmp351_ = paste_menuitem;
				_tmp352_ = granite_accel_label_new (_ ("Paste into Folder"), "<Ctrl>v");
				g_object_ref_sink (_tmp352_);
				_tmp353_ = _tmp352_;
				gtk_container_add ((GtkContainer*) _tmp351_, (GtkWidget*) _tmp353_);
				_g_object_unref0 (_tmp353_);
				_tmp354_ = menu;
				_tmp355_ = paste_menuitem;
				gtk_container_add ((GtkContainer*) _tmp354_, (GtkWidget*) _tmp355_);
				_tmp356_ = select_all_menuitem;
				if (_tmp356_ != NULL) {
					GtkMenu* _tmp357_;
					GtkMenuItem* _tmp358_;
					_tmp357_ = menu;
					_tmp358_ = select_all_menuitem;
					gtk_container_add ((GtkContainer*) _tmp357_, (GtkWidget*) _tmp358_);
				}
			}
		} else {
			gboolean _tmp359_;
			_tmp359_ = self->priv->_in_recent;
			if (_tmp359_) {
				GtkMenuItem* _tmp360_;
				GtkMenu* _tmp363_;
				GtkSeparatorMenuItem* _tmp364_;
				GtkSeparatorMenuItem* _tmp365_;
				GtkMenu* _tmp366_;
				FilesAbstractDirectoryViewSortSubMenuItem* _tmp367_;
				FilesAbstractDirectoryViewSortSubMenuItem* _tmp368_;
				GtkMenu* _tmp369_;
				GtkSeparatorMenuItem* _tmp370_;
				GtkSeparatorMenuItem* _tmp371_;
				_tmp360_ = select_all_menuitem;
				if (_tmp360_ != NULL) {
					GtkMenu* _tmp361_;
					GtkMenuItem* _tmp362_;
					_tmp361_ = menu;
					_tmp362_ = select_all_menuitem;
					gtk_container_add ((GtkContainer*) _tmp361_, (GtkWidget*) _tmp362_);
				}
				_tmp363_ = menu;
				_tmp364_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
				g_object_ref_sink (_tmp364_);
				_tmp365_ = _tmp364_;
				gtk_container_add ((GtkContainer*) _tmp363_, (GtkWidget*) _tmp365_);
				_g_object_unref0 (_tmp365_);
				_tmp366_ = menu;
				_tmp367_ = files_abstract_directory_view_sort_sub_menu_item_new ();
				g_object_ref_sink (_tmp367_);
				_tmp368_ = _tmp367_;
				gtk_container_add ((GtkContainer*) _tmp366_, (GtkWidget*) _tmp368_);
				_g_object_unref0 (_tmp368_);
				_tmp369_ = menu;
				_tmp370_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
				g_object_ref_sink (_tmp370_);
				_tmp371_ = _tmp370_;
				gtk_container_add ((GtkContainer*) _tmp369_, (GtkWidget*) _tmp371_);
				_g_object_unref0 (_tmp371_);
			} else {
				gboolean _tmp400_ = FALSE;
				GSimpleActionGroup* _tmp401_;
				if (!self->priv->in_network_root) {
					GtkMenu* _tmp372_;
					GtkSeparatorMenuItem* _tmp373_;
					GtkSeparatorMenuItem* _tmp374_;
					gboolean _tmp375_ = FALSE;
					FilesClipboardManager* _tmp376_;
					GtkMenu* _tmp389_;
					GtkMenuItem* _tmp390_;
					GtkMenuItem* _tmp391_;
					GtkMenu* _tmp397_;
					FilesAbstractDirectoryViewSortSubMenuItem* _tmp398_;
					FilesAbstractDirectoryViewSortSubMenuItem* _tmp399_;
					_tmp372_ = menu;
					_tmp373_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
					g_object_ref_sink (_tmp373_);
					_tmp374_ = _tmp373_;
					gtk_container_add ((GtkContainer*) _tmp372_, (GtkWidget*) _tmp374_);
					_g_object_unref0 (_tmp374_);
					_tmp376_ = self->priv->clipboard;
					if (_tmp376_ != NULL) {
						FilesClipboardManager* _tmp377_;
						gboolean _tmp378_;
						gboolean _tmp379_;
						_tmp377_ = self->priv->clipboard;
						_tmp378_ = files_clipboard_manager_get_can_paste (_tmp377_);
						_tmp379_ = _tmp378_;
						_tmp375_ = _tmp379_;
					} else {
						_tmp375_ = FALSE;
					}
					if (_tmp375_) {
						FilesClipboardManager* _tmp380_;
						gboolean _tmp381_;
						gboolean _tmp382_;
						_tmp380_ = self->priv->clipboard;
						_tmp381_ = files_clipboard_manager_get_files_linked (_tmp380_);
						_tmp382_ = _tmp381_;
						if (_tmp382_) {
							GtkMenuItem* _tmp383_;
							GraniteAccelLabel* _tmp384_;
							GraniteAccelLabel* _tmp385_;
							_tmp383_ = paste_menuitem;
							_tmp384_ = granite_accel_label_new (_ ("Paste Link into Folder"), "<Ctrl>v");
							g_object_ref_sink (_tmp384_);
							_tmp385_ = _tmp384_;
							gtk_container_add ((GtkContainer*) _tmp383_, (GtkWidget*) _tmp385_);
							_g_object_unref0 (_tmp385_);
						} else {
							GtkMenuItem* _tmp386_;
							GraniteAccelLabel* _tmp387_;
							GraniteAccelLabel* _tmp388_;
							_tmp386_ = paste_menuitem;
							_tmp387_ = granite_accel_label_new (_ ("Paste"), "<Ctrl>v");
							g_object_ref_sink (_tmp387_);
							_tmp388_ = _tmp387_;
							gtk_container_add ((GtkContainer*) _tmp386_, (GtkWidget*) _tmp388_);
							_g_object_unref0 (_tmp388_);
						}
					}
					_tmp389_ = menu;
					_tmp390_ = paste_menuitem;
					gtk_container_add ((GtkContainer*) _tmp389_, (GtkWidget*) _tmp390_);
					_tmp391_ = select_all_menuitem;
					if (_tmp391_ != NULL) {
						GtkMenu* _tmp392_;
						GtkMenuItem* _tmp393_;
						_tmp392_ = menu;
						_tmp393_ = select_all_menuitem;
						gtk_container_add ((GtkContainer*) _tmp392_, (GtkWidget*) _tmp393_);
					}
					if (self->is_writable) {
						GtkMenu* _tmp394_;
						FilesAbstractDirectoryViewNewSubMenuItem* _tmp395_;
						FilesAbstractDirectoryViewNewSubMenuItem* _tmp396_;
						_tmp394_ = menu;
						_tmp395_ = files_abstract_directory_view_new_sub_menu_item_new ();
						g_object_ref_sink (_tmp395_);
						_tmp396_ = _tmp395_;
						gtk_container_add ((GtkContainer*) _tmp394_, (GtkWidget*) _tmp396_);
						_g_object_unref0 (_tmp396_);
					}
					_tmp397_ = menu;
					_tmp398_ = files_abstract_directory_view_sort_sub_menu_item_new ();
					g_object_ref_sink (_tmp398_);
					_tmp399_ = _tmp398_;
					gtk_container_add ((GtkContainer*) _tmp397_, (GtkWidget*) _tmp399_);
					_g_object_unref0 (_tmp399_);
				}
				_tmp401_ = self->priv->common_actions;
				if (g_action_group_get_action_enabled ((GActionGroup*) _tmp401_, "bookmark")) {
					FilesViewWindow* _tmp402_;
					FilesViewSlot* _tmp403_;
					FilesDirectory* _tmp404_;
					FilesDirectory* _tmp405_;
					FilesFile* _tmp406_;
					FilesFile* _tmp407_;
					const gchar* _tmp408_;
					const gchar* _tmp409_;
					_tmp402_ = self->window;
					_tmp403_ = self->slot;
					_tmp404_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp403_);
					_tmp405_ = _tmp404_;
					_tmp406_ = files_directory_get_file (_tmp405_);
					_tmp407_ = _tmp406_;
					_tmp408_ = files_file_get_uri (_tmp407_);
					_tmp409_ = _tmp408_;
					_tmp400_ = files_view_window_can_bookmark_uri (_tmp402_, _tmp409_);
				} else {
					_tmp400_ = FALSE;
				}
				if (_tmp400_) {
					GtkMenu* _tmp410_;
					GtkMenuItem* _tmp411_;
					_tmp410_ = menu;
					_tmp411_ = bookmark_menuitem;
					gtk_container_add ((GtkContainer*) _tmp410_, (GtkWidget*) _tmp411_);
				}
				if (!self->priv->in_network_root) {
					GtkMenu* _tmp412_;
					GtkSeparatorMenuItem* _tmp413_;
					GtkSeparatorMenuItem* _tmp414_;
					GtkMenu* _tmp415_;
					GtkMenuItem* _tmp416_;
					_tmp412_ = menu;
					_tmp413_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
					g_object_ref_sink (_tmp413_);
					_tmp414_ = _tmp413_;
					gtk_container_add ((GtkContainer*) _tmp412_, (GtkWidget*) _tmp414_);
					_g_object_unref0 (_tmp414_);
					_tmp415_ = menu;
					_tmp416_ = properties_menuitem;
					gtk_container_add ((GtkContainer*) _tmp415_, (GtkWidget*) _tmp416_);
				}
			}
		}
	}
	if (!self->priv->in_trash) {
		FilesPluginManager* _tmp417_;
		GtkMenu* _tmp418_;
		GList* _tmp419_;
		GList* _tmp420_;
		_tmp417_ = plugins;
		_tmp418_ = menu;
		_tmp419_ = files_abstract_directory_view_get_files_for_action (self);
		_tmp420_ = _tmp419_;
		files_plugin_manager_hook_context_menu (_tmp417_, G_TYPE_CHECK_INSTANCE_TYPE (_tmp418_, gtk_widget_get_type ()) ? ((GtkWidget*) _tmp418_) : NULL, _tmp420_);
		(_tmp420_ == NULL) ? NULL : (_tmp420_ = (_g_list_free__g_object_unref0_ (_tmp420_), NULL));
	}
	_tmp421_ = menu;
	gtk_menu_set_screen (_tmp421_, NULL);
	_tmp422_ = menu;
	gtk_menu_attach_to_widget (_tmp422_, (GtkWidget*) self, NULL);
	_tmp423_ = self->slot;
	_tmp424_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp423_);
	_tmp425_ = _tmp424_;
	if (files_directory_is_empty (_tmp425_)) {
		GtkMenu* _tmp426_;
		GtkStyleContext* _tmp427_;
		_tmp426_ = menu;
		_tmp427_ = gtk_widget_get_style_context ((GtkWidget*) _tmp426_);
		gtk_style_context_add_class (_tmp427_, GTK_STYLE_CLASS_CONTEXT_MENU);
	}
	_tmp428_ = menu;
	gtk_widget_show_all ((GtkWidget*) _tmp428_);
	_tmp429_ = menu;
	gtk_menu_popup_at_pointer (_tmp429_, event);
	_g_object_unref0 (invert_selection_menuitem);
	_g_object_unref0 (deselect_all_menuitem);
	_g_object_unref0 (select_all_menuitem);
	_g_object_unref0 (properties_menuitem);
	_g_object_unref0 (bookmark_menuitem);
	_g_object_unref0 (paste_menuitem);
	_g_object_unref0 (open_submenu_item);
	_g_object_unref0 (open_submenu);
	_g_object_unref0 (selected_file);
	(selection == NULL) ? NULL : (selection = (_g_list_free__g_object_unref0_ (selection), NULL));
	_g_object_unref0 (menu);
}

static gboolean
files_abstract_directory_view_valid_selection_for_edit (FilesAbstractDirectoryView* self)
{
	GList* _tmp0_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = files_abstract_directory_view_get_selected_files (self);
	{
		GList* file_collection = NULL;
		GList* file_it = NULL;
		file_collection = _tmp0_;
		for (file_it = file_collection; file_it != NULL; file_it = file_it->next) {
			FilesFile* file = NULL;
			file = (FilesFile*) file_it->data;
			{
				FilesFile* _tmp1_;
				_tmp1_ = file;
				if (files_file_is_root_network_folder (_tmp1_)) {
					result = FALSE;
					return result;
				}
			}
		}
	}
	result = TRUE;
	return result;
}

static gboolean
files_abstract_directory_view_valid_selection_for_restore (FilesAbstractDirectoryView* self)
{
	GList* _tmp0_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = files_abstract_directory_view_get_selected_files (self);
	{
		GList* file_collection = NULL;
		GList* file_it = NULL;
		file_collection = _tmp0_;
		for (file_it = file_collection; file_it != NULL; file_it = file_it->next) {
			FilesFile* file = NULL;
			file = (FilesFile*) file_it->data;
			{
				FilesFile* _tmp1_;
				GFile* _tmp2_;
				GFile* _tmp3_;
				gchar* _tmp4_;
				gchar* _tmp5_;
				gboolean _tmp6_;
				_tmp1_ = file;
				_tmp2_ = files_file_get_directory (_tmp1_);
				_tmp3_ = _tmp2_;
				_tmp4_ = g_file_get_basename (_tmp3_);
				_tmp5_ = _tmp4_;
				_tmp6_ = !(g_strcmp0 (_tmp5_, "/") == 0);
				_g_free0 (_tmp5_);
				if (_tmp6_) {
					result = FALSE;
					return result;
				}
			}
		}
	}
	result = TRUE;
	return result;
}

static void
files_abstract_directory_view_update_menu_actions (FilesAbstractDirectoryView* self)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	gboolean _tmp2_;
	GList* selection = NULL;
	GList* _tmp8_;
	FilesFile* file = NULL;
	gboolean is_selected = FALSE;
	GList* _tmp9_;
	gboolean _tmp10_ = FALSE;
	gboolean more_than_one_selected = FALSE;
	gboolean single_folder = FALSE;
	gboolean only_folders = FALSE;
	GList* _tmp14_;
	gboolean can_rename = FALSE;
	gboolean can_show_properties = FALSE;
	gboolean can_copy = FALSE;
	gboolean can_open = FALSE;
	gboolean can_paste_into = FALSE;
	gboolean can_bookmark = FALSE;
	gboolean _tmp31_ = FALSE;
	gboolean _tmp32_ = FALSE;
	FilesFile* _tmp46_;
	FilesFile* _tmp47_;
	gboolean _tmp48_ = FALSE;
	gboolean _tmp49_;
	gboolean _tmp50_ = FALSE;
	gboolean _tmp51_;
	GSimpleActionGroup* _tmp52_;
	GSimpleActionGroup* _tmp53_;
	gboolean _tmp54_;
	GSimpleActionGroup* _tmp55_;
	gboolean _tmp56_;
	gboolean _tmp57_ = FALSE;
	gboolean _tmp58_ = FALSE;
	gboolean _tmp59_;
	GSimpleActionGroup* _tmp60_;
	GSimpleActionGroup* _tmp61_;
	gboolean _tmp62_;
	gboolean _tmp63_ = FALSE;
	gboolean _tmp64_ = FALSE;
	gboolean _tmp65_ = FALSE;
	gboolean _tmp66_;
	GSimpleActionGroup* _tmp67_;
	gboolean _tmp68_ = FALSE;
	gboolean _tmp69_;
	GSimpleActionGroup* _tmp70_;
	gboolean _tmp71_ = FALSE;
	gboolean _tmp72_;
	GSimpleActionGroup* _tmp73_;
	gboolean _tmp74_ = FALSE;
	gboolean _tmp75_;
	GSimpleActionGroup* _tmp76_;
	gboolean _tmp77_ = FALSE;
	gboolean _tmp78_ = FALSE;
	gboolean _tmp79_;
	GSimpleActionGroup* _tmp80_;
	gboolean _tmp81_ = FALSE;
	gboolean _tmp82_ = FALSE;
	gboolean _tmp83_;
	GSimpleActionGroup* _tmp89_;
	gboolean _tmp90_ = FALSE;
	gboolean _tmp91_;
	GSimpleActionGroup* _tmp92_;
	gboolean _tmp93_ = FALSE;
	gboolean _tmp94_;
	GSimpleActionGroup* _tmp95_;
	gboolean _tmp96_ = FALSE;
	gboolean _tmp97_;
	GSimpleActionGroup* _tmp98_;
	gboolean _tmp99_ = FALSE;
	gboolean _tmp100_;
	GSimpleActionGroup* _tmp101_;
	gboolean _tmp102_ = FALSE;
	gboolean _tmp103_;
	GSimpleActionGroup* _tmp104_;
	gboolean _tmp105_ = FALSE;
	gboolean _tmp106_ = FALSE;
	gboolean _tmp107_;
	GSimpleActionGroup* _tmp108_;
	gboolean _tmp109_ = FALSE;
	gboolean _tmp110_ = FALSE;
	gboolean _tmp111_ = FALSE;
	gboolean _tmp112_;
	GSimpleActionGroup* _tmp114_;
	gboolean _tmp115_ = FALSE;
	gboolean _tmp116_;
	GSimpleActionGroup* _tmp117_;
	GList* _tmp118_;
	g_return_if_fail (self != NULL);
	_tmp1_ = files_abstract_directory_view_get_is_frozen (self);
	_tmp2_ = _tmp1_;
	if (_tmp2_) {
		_tmp0_ = TRUE;
	} else {
		FilesViewSlot* _tmp3_;
		FilesDirectory* _tmp4_;
		FilesDirectory* _tmp5_;
		gboolean _tmp6_;
		gboolean _tmp7_;
		_tmp3_ = self->slot;
		_tmp4_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp3_);
		_tmp5_ = _tmp4_;
		_tmp6_ = files_directory_get_can_load (_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp0_ = !_tmp7_;
	}
	if (_tmp0_) {
		return;
	}
	_tmp8_ = files_abstract_directory_view_get_files_for_action (self);
	selection = _tmp8_;
	_tmp9_ = selection;
	is_selected = _tmp9_ != NULL;
	if (is_selected) {
		GList* _tmp11_;
		GList* _tmp12_;
		GList* _tmp13_;
		_tmp11_ = selection;
		_tmp12_ = g_list_first (_tmp11_);
		_tmp13_ = _tmp12_->next;
		_tmp10_ = _tmp13_ != NULL;
	} else {
		_tmp10_ = FALSE;
	}
	more_than_one_selected = _tmp10_;
	single_folder = FALSE;
	_tmp14_ = selection;
	only_folders = files_abstract_directory_view_selection_only_contains_folders (self, _tmp14_);
	can_rename = FALSE;
	can_show_properties = FALSE;
	can_copy = FALSE;
	can_open = FALSE;
	can_paste_into = FALSE;
	can_bookmark = FALSE;
	if (is_selected) {
		GList* _tmp15_;
		gconstpointer _tmp16_;
		FilesFile* _tmp17_;
		FilesFile* _tmp18_;
		_tmp15_ = selection;
		_tmp16_ = _tmp15_->data;
		_tmp17_ = _g_object_ref0 ((FilesFile*) _tmp16_);
		_g_object_unref0 (file);
		file = _tmp17_;
		_tmp18_ = file;
		if (_tmp18_ != NULL) {
			gboolean _tmp19_ = FALSE;
			gboolean _tmp21_ = FALSE;
			if (!more_than_one_selected) {
				FilesFile* _tmp20_;
				_tmp20_ = file;
				_tmp19_ = files_file_is_folder (_tmp20_);
			} else {
				_tmp19_ = FALSE;
			}
			single_folder = _tmp19_;
			can_rename = self->is_writable;
			if (single_folder) {
				FilesFile* _tmp22_;
				_tmp22_ = file;
				_tmp21_ = files_file_is_writable (_tmp22_);
			} else {
				_tmp21_ = FALSE;
			}
			can_paste_into = _tmp21_;
		} else {
			g_critical ("AbstractDirectoryView.vala:2467: File in selection is null");
		}
	} else {
		FilesViewSlot* _tmp23_;
		FilesDirectory* _tmp24_;
		FilesDirectory* _tmp25_;
		FilesFile* _tmp26_;
		FilesFile* _tmp27_;
		FilesFile* _tmp28_;
		gboolean _tmp29_ = FALSE;
		_tmp23_ = self->slot;
		_tmp24_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp23_);
		_tmp25_ = _tmp24_;
		_tmp26_ = files_directory_get_file (_tmp25_);
		_tmp27_ = _tmp26_;
		_tmp28_ = _g_object_ref0 (_tmp27_);
		_g_object_unref0 (file);
		file = _tmp28_;
		if (!more_than_one_selected) {
			FilesFile* _tmp30_;
			_tmp30_ = file;
			_tmp29_ = files_file_is_folder (_tmp30_);
		} else {
			_tmp29_ = FALSE;
		}
		single_folder = _tmp29_;
		can_paste_into = self->is_writable;
	}
	if (!more_than_one_selected) {
		_tmp32_ = TRUE;
	} else {
		_tmp32_ = single_folder;
	}
	if (_tmp32_) {
		gboolean _tmp33_ = FALSE;
		gboolean _tmp34_ = FALSE;
		FilesViewSlot* _tmp35_;
		FilesDirectory* _tmp36_;
		FilesDirectory* _tmp37_;
		gboolean _tmp38_;
		gboolean _tmp39_;
		_tmp35_ = self->slot;
		_tmp36_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp35_);
		_tmp37_ = _tmp36_;
		_tmp38_ = files_directory_get_is_local (_tmp37_);
		_tmp39_ = _tmp38_;
		if (_tmp39_) {
			_tmp34_ = TRUE;
		} else {
			gboolean _tmp40_ = FALSE;
			FilesFile* _tmp41_;
			const gchar* _tmp42_;
			_tmp41_ = file;
			_tmp42_ = files_file_get_ftype (_tmp41_);
			if (_tmp42_ != NULL) {
				FilesFile* _tmp43_;
				const gchar* _tmp44_;
				_tmp43_ = file;
				_tmp44_ = files_file_get_ftype (_tmp43_);
				_tmp40_ = g_strcmp0 (_tmp44_, "inode/directory") == 0;
			} else {
				_tmp40_ = FALSE;
			}
			_tmp34_ = _tmp40_;
		}
		if (_tmp34_) {
			_tmp33_ = TRUE;
		} else {
			FilesFile* _tmp45_;
			_tmp45_ = file;
			_tmp33_ = files_file_is_smb_server (_tmp45_);
		}
		_tmp31_ = _tmp33_;
	} else {
		_tmp31_ = FALSE;
	}
	can_bookmark = _tmp31_;
	_tmp46_ = file;
	can_copy = files_file_is_readable (_tmp46_);
	_tmp47_ = file;
	can_open = files_abstract_directory_view_can_open_file (self, _tmp47_, FALSE);
	_tmp49_ = self->priv->_in_recent;
	if (_tmp49_) {
		_tmp48_ = more_than_one_selected;
	} else {
		_tmp48_ = FALSE;
	}
	can_show_properties = !_tmp48_;
	_tmp51_ = self->priv->_in_recent;
	if (!_tmp51_) {
		_tmp50_ = self->is_writable;
	} else {
		_tmp50_ = FALSE;
	}
	_tmp52_ = self->priv->common_actions;
	files_abstract_directory_view_action_set_enabled (self, _tmp52_, "paste", _tmp50_);
	_tmp53_ = self->priv->common_actions;
	_tmp54_ = self->priv->_renaming;
	files_abstract_directory_view_action_set_enabled (self, _tmp53_, "paste-into", (!_tmp54_) & can_paste_into);
	_tmp55_ = self->priv->common_actions;
	_tmp56_ = self->priv->_renaming;
	files_abstract_directory_view_action_set_enabled (self, _tmp55_, "open-in", (!_tmp56_) & only_folders);
	_tmp59_ = self->priv->_renaming;
	if ((!_tmp59_) & is_selected) {
		_tmp58_ = !more_than_one_selected;
	} else {
		_tmp58_ = FALSE;
	}
	if (_tmp58_) {
		_tmp57_ = can_rename;
	} else {
		_tmp57_ = FALSE;
	}
	_tmp60_ = self->priv->selection_actions;
	files_abstract_directory_view_action_set_enabled (self, _tmp60_, "rename", _tmp57_);
	_tmp61_ = self->priv->selection_actions;
	_tmp62_ = self->priv->_renaming;
	files_abstract_directory_view_action_set_enabled (self, _tmp61_, "view-in-location", (!_tmp62_) & is_selected);
	_tmp66_ = self->priv->_renaming;
	if (!_tmp66_) {
		_tmp65_ = is_selected;
	} else {
		_tmp65_ = FALSE;
	}
	if (_tmp65_) {
		_tmp64_ = !more_than_one_selected;
	} else {
		_tmp64_ = FALSE;
	}
	if (_tmp64_) {
		_tmp63_ = can_open;
	} else {
		_tmp63_ = FALSE;
	}
	_tmp67_ = self->priv->selection_actions;
	files_abstract_directory_view_action_set_enabled (self, _tmp67_, "open", _tmp63_);
	_tmp69_ = self->priv->_renaming;
	if (!_tmp69_) {
		_tmp68_ = can_open;
	} else {
		_tmp68_ = FALSE;
	}
	_tmp70_ = self->priv->selection_actions;
	files_abstract_directory_view_action_set_enabled (self, _tmp70_, "open-with-app", _tmp68_);
	_tmp72_ = self->priv->_renaming;
	if (!_tmp72_) {
		_tmp71_ = can_open;
	} else {
		_tmp71_ = FALSE;
	}
	_tmp73_ = self->priv->selection_actions;
	files_abstract_directory_view_action_set_enabled (self, _tmp73_, "open-with-default", _tmp71_);
	_tmp75_ = self->priv->_renaming;
	if (!_tmp75_) {
		_tmp74_ = can_open;
	} else {
		_tmp74_ = FALSE;
	}
	_tmp76_ = self->priv->selection_actions;
	files_abstract_directory_view_action_set_enabled (self, _tmp76_, "open-with-other-app", _tmp74_);
	_tmp79_ = self->priv->_renaming;
	if (!_tmp79_) {
		_tmp78_ = self->is_writable;
	} else {
		_tmp78_ = FALSE;
	}
	if (_tmp78_) {
		_tmp77_ = is_selected;
	} else {
		_tmp77_ = FALSE;
	}
	_tmp80_ = self->priv->selection_actions;
	files_abstract_directory_view_action_set_enabled (self, _tmp80_, "cut", _tmp77_);
	_tmp83_ = self->priv->_renaming;
	if (!_tmp83_) {
		_tmp82_ = self->is_writable;
	} else {
		_tmp82_ = FALSE;
	}
	if (_tmp82_) {
		FilesViewSlot* _tmp84_;
		FilesDirectory* _tmp85_;
		FilesDirectory* _tmp86_;
		gboolean _tmp87_;
		gboolean _tmp88_;
		_tmp84_ = self->slot;
		_tmp85_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp84_);
		_tmp86_ = _tmp85_;
		_tmp87_ = files_directory_get_has_trash_dirs (_tmp86_);
		_tmp88_ = _tmp87_;
		_tmp81_ = _tmp88_;
	} else {
		_tmp81_ = FALSE;
	}
	_tmp89_ = self->priv->selection_actions;
	files_abstract_directory_view_action_set_enabled (self, _tmp89_, "trash", _tmp81_);
	_tmp91_ = self->priv->_renaming;
	if (!_tmp91_) {
		_tmp90_ = self->is_writable;
	} else {
		_tmp90_ = FALSE;
	}
	_tmp92_ = self->priv->selection_actions;
	files_abstract_directory_view_action_set_enabled (self, _tmp92_, "delete", _tmp90_);
	_tmp94_ = self->priv->_renaming;
	if (!_tmp94_) {
		_tmp93_ = is_selected;
	} else {
		_tmp93_ = FALSE;
	}
	_tmp95_ = self->priv->selection_actions;
	files_abstract_directory_view_action_set_enabled (self, _tmp95_, "invert-selection", _tmp93_);
	_tmp97_ = self->priv->_renaming;
	if (!_tmp97_) {
		_tmp96_ = is_selected;
	} else {
		_tmp96_ = FALSE;
	}
	_tmp98_ = self->priv->common_actions;
	files_abstract_directory_view_action_set_enabled (self, _tmp98_, "select-all", _tmp96_);
	_tmp100_ = self->priv->_renaming;
	if (!_tmp100_) {
		_tmp99_ = can_show_properties;
	} else {
		_tmp99_ = FALSE;
	}
	_tmp101_ = self->priv->common_actions;
	files_abstract_directory_view_action_set_enabled (self, _tmp101_, "properties", _tmp99_);
	_tmp103_ = self->priv->_renaming;
	if (!_tmp103_) {
		_tmp102_ = can_bookmark;
	} else {
		_tmp102_ = FALSE;
	}
	_tmp104_ = self->priv->common_actions;
	files_abstract_directory_view_action_set_enabled (self, _tmp104_, "bookmark", _tmp102_);
	_tmp107_ = self->priv->_renaming;
	if (!_tmp107_) {
		_tmp106_ = !self->priv->in_trash;
	} else {
		_tmp106_ = FALSE;
	}
	if (_tmp106_) {
		_tmp105_ = can_copy;
	} else {
		_tmp105_ = FALSE;
	}
	_tmp108_ = self->priv->common_actions;
	files_abstract_directory_view_action_set_enabled (self, _tmp108_, "copy", _tmp105_);
	_tmp112_ = self->priv->_renaming;
	if (!_tmp112_) {
		_tmp111_ = !self->priv->in_trash;
	} else {
		_tmp111_ = FALSE;
	}
	if (_tmp111_) {
		gboolean _tmp113_;
		_tmp113_ = self->priv->_in_recent;
		_tmp110_ = !_tmp113_;
	} else {
		_tmp110_ = FALSE;
	}
	if (_tmp110_) {
		_tmp109_ = can_copy;
	} else {
		_tmp109_ = FALSE;
	}
	_tmp114_ = self->priv->common_actions;
	files_abstract_directory_view_action_set_enabled (self, _tmp114_, "copy-link", _tmp109_);
	_tmp116_ = self->priv->_renaming;
	if (!_tmp116_) {
		_tmp115_ = !more_than_one_selected;
	} else {
		_tmp115_ = FALSE;
	}
	_tmp117_ = self->priv->common_actions;
	files_abstract_directory_view_action_set_enabled (self, _tmp117_, "bookmark", _tmp115_);
	_tmp118_ = selection;
	files_abstract_directory_view_update_default_app (self, _tmp118_);
	files_abstract_directory_view_update_menu_actions_sort (self);
	_g_object_unref0 (file);
	(selection == NULL) ? NULL : (selection = (_g_list_free__g_object_unref0_ (selection), NULL));
}

static void
files_abstract_directory_view_update_menu_actions_sort (FilesAbstractDirectoryView* self)
{
	gint sort_column_id = 0;
	GtkSortType sort_order = 0;
	FilesListModel* _tmp0_;
	gint _tmp1_ = 0;
	GtkSortType _tmp2_ = 0;
	gboolean _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->model;
	_tmp3_ = gtk_tree_sortable_get_sort_column_id ((GtkTreeSortable*) _tmp0_, &_tmp1_, &_tmp2_);
	sort_column_id = _tmp1_;
	sort_order = _tmp2_;
	if (_tmp3_) {
		GVariant* val = NULL;
		const gchar* _tmp4_;
		GVariant* _tmp5_;
		GSimpleActionGroup* _tmp6_;
		GVariant* _tmp7_;
		GVariant* _tmp8_;
		GSimpleActionGroup* _tmp9_;
		GVariant* _tmp10_;
		FilesPreferences* _tmp11_;
		FilesPreferences* _tmp12_;
		gboolean _tmp13_;
		gboolean _tmp14_;
		GVariant* _tmp15_;
		GSimpleActionGroup* _tmp16_;
		GVariant* _tmp17_;
		_tmp4_ = files_list_model_column_id_to_string ((FilesListModelColumnID) sort_column_id);
		_tmp5_ = g_variant_new_string (_tmp4_);
		g_variant_ref_sink (_tmp5_);
		val = _tmp5_;
		_tmp6_ = self->priv->background_actions;
		_tmp7_ = val;
		files_abstract_directory_view_action_set_state (self, _tmp6_, "sort-by", _tmp7_);
		_tmp8_ = g_variant_new_boolean (sort_order == GTK_SORT_DESCENDING);
		g_variant_ref_sink (_tmp8_);
		_g_variant_unref0 (val);
		val = _tmp8_;
		_tmp9_ = self->priv->background_actions;
		_tmp10_ = val;
		files_abstract_directory_view_action_set_state (self, _tmp9_, "reverse", _tmp10_);
		_tmp11_ = files_preferences_get_default ();
		_tmp12_ = _tmp11_;
		_tmp13_ = files_preferences_get_sort_directories_first (_tmp12_);
		_tmp14_ = _tmp13_;
		_tmp15_ = g_variant_new_boolean (_tmp14_);
		g_variant_ref_sink (_tmp15_);
		_g_variant_unref0 (val);
		val = _tmp15_;
		_g_object_unref0 (_tmp12_);
		_tmp16_ = self->priv->background_actions;
		_tmp17_ = val;
		files_abstract_directory_view_action_set_state (self, _tmp16_, "folders-first", _tmp17_);
		_g_variant_unref0 (val);
	} else {
		g_warning ("AbstractDirectoryView.vala:2522: Update menu actions sort: The model i" \
"s unsorted - this should not happen");
	}
}

static void
files_abstract_directory_view_update_default_app (FilesAbstractDirectoryView* self,
                                                  GList* selection)
{
	GAppInfo* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = files_mime_actions_get_default_application_for_files (selection);
	_g_object_unref0 (self->priv->default_app);
	self->priv->default_app = _tmp0_;
	return;
}

/** Menu helpers */
static void
files_abstract_directory_view_action_set_enabled (FilesAbstractDirectoryView* self,
                                                  GSimpleActionGroup* action_group,
                                                  const gchar* name,
                                                  gboolean enabled)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	if (action_group != NULL) {
		GSimpleAction* action = NULL;
		GAction* _tmp0_;
		GSimpleAction* _tmp1_;
		GSimpleAction* _tmp2_;
		_tmp0_ = g_action_map_lookup_action ((GActionMap*) action_group, name);
		_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, g_simple_action_get_type ()) ? ((GSimpleAction*) _tmp0_) : NULL);
		action = _tmp1_;
		_tmp2_ = action;
		if (_tmp2_ != NULL) {
			GSimpleAction* _tmp3_;
			_tmp3_ = action;
			g_simple_action_set_enabled (_tmp3_, enabled);
			_g_object_unref0 (action);
			return;
		}
		_g_object_unref0 (action);
	}
	g_critical ("AbstractDirectoryView.vala:2541: Action name not found: %s - cannot en" \
"able", name);
}

static void
files_abstract_directory_view_action_set_state (FilesAbstractDirectoryView* self,
                                                GSimpleActionGroup* action_group,
                                                const gchar* name,
                                                GVariant* val)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (val != NULL);
	if (action_group != NULL) {
		GSimpleAction* action = NULL;
		GAction* _tmp0_;
		GSimpleAction* _tmp1_;
		GSimpleAction* _tmp2_;
		_tmp0_ = g_action_map_lookup_action ((GActionMap*) action_group, name);
		_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, g_simple_action_get_type ()) ? ((GSimpleAction*) _tmp0_) : NULL);
		action = _tmp1_;
		_tmp2_ = action;
		if (_tmp2_ != NULL) {
			GSimpleAction* _tmp3_;
			_tmp3_ = action;
			g_simple_action_set_state (_tmp3_, val);
			_g_object_unref0 (action);
			return;
		}
		_g_object_unref0 (action);
	}
	g_critical ("AbstractDirectoryView.vala:2552: Action name not found: %s - cannot se" \
"t state", name);
}

static gint
___lambda55_ (GFile* a,
              GFile* b)
{
	GCompareFunc _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gint _tmp9_;
	gint result;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = ((GCompareFunc) g_strcmp0);
	_tmp1_ = g_file_get_basename (a);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_utf8_strdown (_tmp2_, (gssize) -1);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_file_get_basename (b);
	_tmp6_ = _tmp5_;
	_tmp7_ = g_utf8_strdown (_tmp6_, (gssize) -1);
	_tmp8_ = _tmp7_;
	_tmp9_ = _tmp0_ (_tmp4_, _tmp8_);
	_g_free0 (_tmp8_);
	_g_free0 (_tmp6_);
	_g_free0 (_tmp4_);
	_g_free0 (_tmp2_);
	result = _tmp9_;
	return result;
}

static gint
____lambda55__gcompare_func (gconstpointer a,
                             gconstpointer b)
{
	gint result;
	result = ___lambda55_ ((GFile*) a, (GFile*) b);
	return result;
}

static void
___lambda56_ (GFile* folder)
{
	g_return_if_fail (folder != NULL);
	files_abstract_directory_view_load_templates_from_folder (folder);
}

static void
____lambda56__gfunc (gconstpointer data,
                     gpointer self)
{
	___lambda56_ ((GFile*) data);
}

static void
files_abstract_directory_view_load_templates_from_folder (GFile* template_folder)
{
	GList* file_list = NULL;
	GList* folder_list = NULL;
	GFileEnumerator* enumerator = NULL;
	GFileQueryInfoFlags flags = 0U;
	GList* _tmp24_;
	GList* _tmp30_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (template_folder != NULL);
	file_list = NULL;
	folder_list = NULL;
	flags = G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS;
	{
		GFileEnumerator* _tmp0_ = NULL;
		GFileEnumerator* _tmp1_;
		GFileEnumerator* _tmp2_;
		guint count = 0U;
		GList* _tmp3_;
		GFile* location = NULL;
		GFileInfo* info = NULL;
		GFileEnumerator* _tmp4_;
		GFileInfo* _tmp5_;
		_tmp1_ = g_file_enumerate_children (template_folder, "standard::*", flags, NULL, &_inner_error0_);
		_tmp0_ = _tmp1_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		_tmp2_ = _tmp0_;
		_tmp0_ = NULL;
		_g_object_unref0 (enumerator);
		enumerator = _tmp2_;
		_tmp3_ = files_abstract_directory_view_templates;
		count = g_list_length (_tmp3_);
		_tmp4_ = enumerator;
		_tmp5_ = g_file_enumerator_next_file (_tmp4_, NULL, &_inner_error0_);
		info = _tmp5_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (location);
			_g_object_unref0 (_tmp0_);
			goto __catch0_g_error;
		}
		while (TRUE) {
			gboolean _tmp6_ = FALSE;
			gboolean _tmp8_ = FALSE;
			GFileInfo* _tmp9_;
			GFileInfo* _tmp20_ = NULL;
			GFileEnumerator* _tmp21_;
			GFileInfo* _tmp22_;
			GFileInfo* _tmp23_;
			if (count < ((guint) FILES_ABSTRACT_DIRECTORY_VIEW_MAX_TEMPLATES)) {
				GFileInfo* _tmp7_;
				_tmp7_ = info;
				_tmp6_ = _tmp7_ != NULL;
			} else {
				_tmp6_ = FALSE;
			}
			if (!_tmp6_) {
				break;
			}
			_tmp9_ = info;
			if (!g_file_info_get_is_hidden (_tmp9_)) {
				GFileInfo* _tmp10_;
				_tmp10_ = info;
				_tmp8_ = !g_file_info_get_is_backup (_tmp10_);
			} else {
				_tmp8_ = FALSE;
			}
			if (_tmp8_) {
				GFileInfo* _tmp11_;
				const gchar* _tmp12_;
				GFile* _tmp13_;
				GFileInfo* _tmp14_;
				_tmp11_ = info;
				_tmp12_ = g_file_info_get_name (_tmp11_);
				_tmp13_ = g_file_get_child (template_folder, _tmp12_);
				_g_object_unref0 (location);
				location = _tmp13_;
				_tmp14_ = info;
				if (g_file_info_get_file_type (_tmp14_) == G_FILE_TYPE_DIRECTORY) {
					GFile* _tmp15_;
					GFile* _tmp16_;
					_tmp15_ = location;
					_tmp16_ = _g_object_ref0 (_tmp15_);
					folder_list = g_list_prepend (folder_list, _tmp16_);
				} else {
					GFile* _tmp17_;
					GFile* _tmp18_;
					guint _tmp19_;
					_tmp17_ = location;
					_tmp18_ = _g_object_ref0 (_tmp17_);
					file_list = g_list_prepend (file_list, _tmp18_);
					_tmp19_ = count;
					count = _tmp19_ + 1;
				}
			}
			_tmp21_ = enumerator;
			_tmp22_ = g_file_enumerator_next_file (_tmp21_, NULL, &_inner_error0_);
			_tmp20_ = _tmp22_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				_g_object_unref0 (info);
				_g_object_unref0 (location);
				_g_object_unref0 (_tmp0_);
				goto __catch0_g_error;
			}
			_tmp23_ = _tmp20_;
			_tmp20_ = NULL;
			_g_object_unref0 (info);
			info = _tmp23_;
			_g_object_unref0 (_tmp20_);
		}
		_g_object_unref0 (info);
		_g_object_unref0 (location);
		_g_object_unref0 (_tmp0_);
	}
	goto __finally0;
	__catch0_g_error:
	{
		g_clear_error (&_inner_error0_);
		_g_object_unref0 (enumerator);
		(folder_list == NULL) ? NULL : (folder_list = (_g_list_free__g_object_unref0_ (folder_list), NULL));
		(file_list == NULL) ? NULL : (file_list = (_g_list_free__g_object_unref0_ (file_list), NULL));
		return;
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_object_unref0 (enumerator);
		(folder_list == NULL) ? NULL : (folder_list = (_g_list_free__g_object_unref0_ (folder_list), NULL));
		(file_list == NULL) ? NULL : (file_list = (_g_list_free__g_object_unref0_ (file_list), NULL));
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_tmp24_ = file_list;
	if (g_list_length (_tmp24_) > ((guint) 0)) {
		GList* _tmp25_;
		GFile* _tmp29_;
		file_list = g_list_sort (file_list, ____lambda55__gcompare_func);
		_tmp25_ = file_list;
		{
			GList* file_collection = NULL;
			GList* file_it = NULL;
			file_collection = _tmp25_;
			for (file_it = file_collection; file_it != NULL; file_it = file_it->next) {
				GFile* _tmp26_;
				GFile* file = NULL;
				_tmp26_ = _g_object_ref0 ((GFile*) file_it->data);
				file = _tmp26_;
				{
					GFile* _tmp27_;
					GFile* _tmp28_;
					_tmp27_ = file;
					_tmp28_ = _g_object_ref0 (_tmp27_);
					files_abstract_directory_view_templates = g_list_append (files_abstract_directory_view_templates, _tmp28_);
					_g_object_unref0 (file);
				}
			}
		}
		_tmp29_ = _g_object_ref0 (template_folder);
		files_abstract_directory_view_templates = g_list_append (files_abstract_directory_view_templates, _tmp29_);
	}
	_tmp30_ = folder_list;
	if (g_list_length (_tmp30_) > ((guint) 0)) {
		GList* _tmp31_;
		_tmp31_ = folder_list;
		g_list_foreach (_tmp31_, ____lambda56__gfunc, NULL);
	}
	_g_object_unref0 (enumerator);
	(folder_list == NULL) ? NULL : (folder_list = (_g_list_free__g_object_unref0_ (folder_list), NULL));
	(file_list == NULL) ? NULL : (file_list = (_g_list_free__g_object_unref0_ (file_list), NULL));
}

static void
files_abstract_directory_view_filter_this_app_from_open_with_apps (FilesAbstractDirectoryView* self)
{
	GList* l = NULL;
	GList* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->open_with_apps;
	l = _tmp0_;
	while (TRUE) {
		GList* _tmp1_;
		GList* _tmp2_;
		gconstpointer _tmp3_;
		GList* _tmp10_;
		GList* _tmp11_;
		_tmp1_ = l;
		if (!(_tmp1_ != NULL)) {
			break;
		}
		_tmp2_ = l;
		_tmp3_ = _tmp2_->data;
		if (G_TYPE_CHECK_INSTANCE_TYPE ((GAppInfo*) _tmp3_, g_app_info_get_type ())) {
			GList* _tmp4_;
			gconstpointer _tmp5_;
			_tmp4_ = l;
			_tmp5_ = _tmp4_->data;
			if (files_abstract_directory_view_app_is_this_app (self, (GAppInfo*) _tmp5_)) {
				GList* _tmp6_;
				_tmp6_ = l;
				self->priv->open_with_apps = g_list_delete_link (self->priv->open_with_apps, _tmp6_);
				break;
			}
		} else {
			GList* _tmp7_;
			GList* _tmp8_;
			GList* _tmp9_;
			_tmp7_ = l;
			self->priv->open_with_apps = g_list_delete_link (self->priv->open_with_apps, _tmp7_);
			_tmp8_ = self->priv->open_with_apps;
			l = _tmp8_;
			_tmp9_ = l;
			if (_tmp9_ == NULL) {
				break;
			}
		}
		_tmp10_ = l;
		_tmp11_ = _tmp10_->next;
		l = _tmp11_;
	}
}

static gboolean
files_abstract_directory_view_app_is_this_app (FilesAbstractDirectoryView* self,
                                               GAppInfo* ai)
{
	gchar* exec_name = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (ai != NULL, FALSE);
	_tmp0_ = g_app_info_get_executable (ai);
	_tmp1_ = g_strdup (_tmp0_);
	exec_name = _tmp1_;
	result = g_strcmp0 (exec_name, APP_NAME) == 0;
	_g_free0 (exec_name);
	return result;
}

static void
files_abstract_directory_view_filter_default_app_from_open_with_apps (FilesAbstractDirectoryView* self)
{
	GAppInfo* _tmp0_;
	gchar* id1 = NULL;
	gchar* id2 = NULL;
	GAppInfo* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->default_app;
	if (_tmp0_ == NULL) {
		return;
	}
	_tmp1_ = self->priv->default_app;
	_tmp2_ = g_app_info_get_id (_tmp1_);
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (id2);
	id2 = _tmp3_;
	_tmp4_ = id2;
	if (_tmp4_ != NULL) {
		GList* l = NULL;
		GList* _tmp5_;
		_tmp5_ = self->priv->open_with_apps;
		l = _tmp5_;
		while (TRUE) {
			gboolean _tmp6_ = FALSE;
			GList* _tmp7_;
			GList* _tmp10_;
			gconstpointer _tmp11_;
			const gchar* _tmp12_;
			gchar* _tmp13_;
			gboolean _tmp14_ = FALSE;
			const gchar* _tmp15_;
			GList* _tmp19_;
			GList* _tmp20_;
			_tmp7_ = l;
			if (_tmp7_ != NULL) {
				GList* _tmp8_;
				gconstpointer _tmp9_;
				_tmp8_ = l;
				_tmp9_ = _tmp8_->data;
				_tmp6_ = G_TYPE_CHECK_INSTANCE_TYPE ((GAppInfo*) _tmp9_, g_app_info_get_type ());
			} else {
				_tmp6_ = FALSE;
			}
			if (!_tmp6_) {
				break;
			}
			_tmp10_ = l;
			_tmp11_ = _tmp10_->data;
			_tmp12_ = g_app_info_get_id ((GAppInfo*) _tmp11_);
			_tmp13_ = g_strdup (_tmp12_);
			_g_free0 (id1);
			id1 = _tmp13_;
			_tmp15_ = id1;
			if (_tmp15_ != NULL) {
				const gchar* _tmp16_;
				const gchar* _tmp17_;
				_tmp16_ = id1;
				_tmp17_ = id2;
				_tmp14_ = g_strcmp0 (_tmp16_, _tmp17_) == 0;
			} else {
				_tmp14_ = FALSE;
			}
			if (_tmp14_) {
				GList* _tmp18_;
				_tmp18_ = l;
				self->priv->open_with_apps = g_list_delete_link (self->priv->open_with_apps, _tmp18_);
				break;
			}
			_tmp19_ = l;
			_tmp20_ = _tmp19_->next;
			l = _tmp20_;
		}
	}
	_g_free0 (id2);
	_g_free0 (id1);
}

/** Menu action functions */
static void
__lambda110_ (FilesAbstractDirectoryView* self,
              GObject* obj,
              GAsyncResult* res)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (res != NULL);
	{
		GFile* file = NULL;
		GFile* _tmp0_;
		_tmp0_ = marlin_file_operations_new_file_from_template_finish (res, &_inner_error0_);
		file = _tmp0_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		files_abstract_directory_view_create_file_done (file, self);
		_g_object_unref0 (file);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp1_;
		const gchar* _tmp2_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp1_ = e;
		_tmp2_ = _tmp1_->message;
		g_critical ("AbstractDirectoryView.vala:2672: %s", _tmp2_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

static void
___lambda110__gasync_ready_callback (GObject* source_object,
                                     GAsyncResult* res,
                                     gpointer self)
{
	__lambda110_ ((FilesAbstractDirectoryView*) self, source_object, res);
	g_object_unref (self);
}

static void
files_abstract_directory_view_create_from_template (FilesAbstractDirectoryView* self,
                                                    GFile* template)
{
	FilesViewSlot* _tmp0_;
	FilesDirectory* _tmp1_;
	FilesDirectory* _tmp2_;
	gchar* new_name = NULL;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	FilesViewSlot* _tmp7_;
	GFile* _tmp8_;
	GFile* _tmp9_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (template != NULL);
	_tmp0_ = self->slot;
	_tmp1_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp0_);
	_tmp2_ = _tmp1_;
	files_directory_block_monitor (_tmp2_);
	_tmp3_ = g_file_get_basename (template);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strdup_printf (_ ("Untitled %s"), _tmp4_);
	_tmp6_ = _tmp5_;
	_g_free0 (_tmp4_);
	new_name = _tmp6_;
	_tmp7_ = self->slot;
	_tmp8_ = files_abstract_slot_get_location ((FilesAbstractSlot*) _tmp7_);
	_tmp9_ = _tmp8_;
	marlin_file_operations_new_file_from_template ((GtkWidget*) self, _tmp9_, new_name, template, NULL, ___lambda110__gasync_ready_callback, g_object_ref (self));
	_g_free0 (new_name);
}

static void
files_abstract_directory_view_open_files_with (FilesAbstractDirectoryView* self,
                                               GAppInfo* app,
                                               GList* files)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (app != NULL);
	files_mime_actions_open_multiple_gof_files_request (files, (GtkWidget*) self, app);
}

/** Thumbnail and color tag handling */
static gboolean
__lambda68_ (FilesAbstractDirectoryView* self)
{
	gboolean result;
	if (self->priv->thumbnail_source_id > ((guint) 0)) {
		result = G_SOURCE_CONTINUE;
		return result;
	}
	files_abstract_directory_view_thaw_child_notify (self);
	self->priv->freeze_source_id = (guint) 0;
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
___lambda68__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda68_ ((FilesAbstractDirectoryView*) self);
	return result;
}

static GtkTreePath*
_vala_GtkTreePath_copy (GtkTreePath* self)
{
	return g_boxed_copy (gtk_tree_path_get_type (), self);
}

static gpointer
__vala_GtkTreePath_copy0 (gpointer self)
{
	return self ? _vala_GtkTreePath_copy (self) : NULL;
}

static gboolean
__lambda69_ (FilesAbstractDirectoryView* self)
{
	GtkTreePath* start_path = NULL;
	GtkTreePath* end_path = NULL;
	GtkTreePath* path = NULL;
	GtkTreePath* sp = NULL;
	GtkTreePath* ep = NULL;
	GtkTreeIter iter = {0};
	gboolean valid_iter = FALSE;
	FilesFile* file = NULL;
	GList* visible_files = NULL;
	guint actually_visible = 0U;
	GtkTreePath* _tmp0_ = NULL;
	GtkTreePath* _tmp1_ = NULL;
	gboolean _tmp2_;
	gboolean _tmp57_ = FALSE;
	gboolean result;
	visible_files = NULL;
	actually_visible = (guint) 0;
	_tmp2_ = files_abstract_directory_view_get_visible_range (self, &_tmp0_, &_tmp1_);
	__vala_GtkTreePath_free0 (start_path);
	start_path = _tmp0_;
	__vala_GtkTreePath_free0 (end_path);
	end_path = _tmp1_;
	if (_tmp2_) {
		GtkTreePath* _tmp3_;
		GtkTreePath* _tmp4_;
		GtkTreePath* _tmp5_;
		GtkTreePath* _tmp6_;
		gint count = 0;
		FilesListModel* _tmp12_;
		GtkTreePath* _tmp13_;
		GtkTreeIter _tmp14_ = {0};
		gboolean _tmp15_;
		_tmp3_ = start_path;
		_tmp4_ = __vala_GtkTreePath_copy0 (_tmp3_);
		__vala_GtkTreePath_free0 (sp);
		sp = _tmp4_;
		_tmp5_ = end_path;
		_tmp6_ = __vala_GtkTreePath_copy0 (_tmp5_);
		__vala_GtkTreePath_free0 (ep);
		ep = _tmp6_;
		count = 50;
		while (TRUE) {
			gboolean _tmp7_ = FALSE;
			GtkTreePath* _tmp8_;
			gint _tmp9_;
			_tmp8_ = start_path;
			if (gtk_tree_path_prev (_tmp8_)) {
				_tmp7_ = count > 0;
			} else {
				_tmp7_ = FALSE;
			}
			if (!_tmp7_) {
				break;
			}
			_tmp9_ = count;
			count = _tmp9_ - 1;
		}
		count = 50;
		while (TRUE) {
			GtkTreePath* _tmp10_;
			gint _tmp11_;
			if (!(count > 0)) {
				break;
			}
			_tmp10_ = end_path;
			gtk_tree_path_next (_tmp10_);
			_tmp11_ = count;
			count = _tmp11_ - 1;
		}
		_tmp12_ = self->model;
		_tmp13_ = start_path;
		_tmp15_ = gtk_tree_model_get_iter ((GtkTreeModel*) _tmp12_, &_tmp14_, _tmp13_);
		iter = _tmp14_;
		valid_iter = _tmp15_;
		while (TRUE) {
			gboolean _tmp16_ = FALSE;
			FilesListModel* _tmp17_;
			GtkTreeIter _tmp18_;
			FilesFile* _tmp19_;
			FilesListModel* _tmp20_;
			GtkTreeIter _tmp21_;
			GtkTreePath* _tmp22_;
			gboolean _tmp23_ = FALSE;
			FilesFile* _tmp24_;
			GtkTreePath* _tmp54_;
			GtkTreePath* _tmp55_;
			if (valid_iter) {
				_tmp16_ = self->priv->thumbnail_source_id > ((guint) 0);
			} else {
				_tmp16_ = FALSE;
			}
			if (!_tmp16_) {
				break;
			}
			_tmp17_ = self->model;
			_tmp18_ = iter;
			_tmp19_ = files_list_model_file_for_iter (_tmp17_, &_tmp18_);
			_g_object_unref0 (file);
			file = _tmp19_;
			_tmp20_ = self->model;
			_tmp21_ = iter;
			_tmp22_ = gtk_tree_model_get_path ((GtkTreeModel*) _tmp20_, &_tmp21_);
			__vala_GtkTreePath_free0 (path);
			path = _tmp22_;
			_tmp24_ = file;
			if (_tmp24_ != NULL) {
				FilesFile* _tmp25_;
				_tmp25_ = file;
				_tmp23_ = !_tmp25_->is_gone;
			} else {
				_tmp23_ = FALSE;
			}
			if (_tmp23_) {
				gboolean _tmp26_ = FALSE;
				gboolean _tmp27_ = FALSE;
				FilesViewSlot* _tmp28_;
				FilesDirectory* _tmp29_;
				FilesDirectory* _tmp30_;
				gboolean _tmp31_;
				gboolean _tmp32_;
				FilesPluginManager* _tmp51_;
				_tmp28_ = self->slot;
				_tmp29_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp28_);
				_tmp30_ = _tmp29_;
				_tmp31_ = files_directory_get_is_network (_tmp30_);
				_tmp32_ = _tmp31_;
				if (_tmp32_) {
					gboolean _tmp33_;
					_tmp33_ = self->priv->_show_remote_thumbnails;
					_tmp27_ = _tmp33_;
				} else {
					_tmp27_ = FALSE;
				}
				if (_tmp27_) {
					_tmp26_ = TRUE;
				} else {
					gboolean _tmp34_ = FALSE;
					FilesViewSlot* _tmp35_;
					FilesDirectory* _tmp36_;
					FilesDirectory* _tmp37_;
					gboolean _tmp38_;
					gboolean _tmp39_;
					_tmp35_ = self->slot;
					_tmp36_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp35_);
					_tmp37_ = _tmp36_;
					_tmp38_ = files_directory_get_is_network (_tmp37_);
					_tmp39_ = _tmp38_;
					if (!_tmp39_) {
						gboolean _tmp40_;
						_tmp40_ = self->priv->_show_local_thumbnails;
						_tmp34_ = _tmp40_;
					} else {
						_tmp34_ = FALSE;
					}
					_tmp26_ = _tmp34_;
				}
				if (_tmp26_) {
					FilesFile* _tmp41_;
					FilesFile* _tmp42_;
					_tmp41_ = file;
					files_file_query_thumbnail_update (_tmp41_);
					_tmp42_ = file;
					if (_tmp42_->thumbstate == ((guint) FILES_FILE_THUMB_STATE_UNKNOWN)) {
						FilesFile* _tmp43_;
						FilesFile* _tmp44_;
						gboolean _tmp45_ = FALSE;
						GtkTreePath* _tmp46_;
						GtkTreePath* _tmp47_;
						_tmp43_ = file;
						_tmp44_ = _g_object_ref0 (_tmp43_);
						visible_files = g_list_prepend (visible_files, _tmp44_);
						_tmp46_ = path;
						_tmp47_ = sp;
						if (gtk_tree_path_compare (_tmp46_, _tmp47_) >= 0) {
							GtkTreePath* _tmp48_;
							GtkTreePath* _tmp49_;
							_tmp48_ = path;
							_tmp49_ = ep;
							_tmp45_ = gtk_tree_path_compare (_tmp48_, _tmp49_) <= 0;
						} else {
							_tmp45_ = FALSE;
						}
						if (_tmp45_) {
							guint _tmp50_;
							_tmp50_ = actually_visible;
							actually_visible = _tmp50_ + 1;
						}
					}
				}
				_tmp51_ = plugins;
				if (_tmp51_ != NULL) {
					FilesPluginManager* _tmp52_;
					FilesFile* _tmp53_;
					_tmp52_ = plugins;
					_tmp53_ = file;
					files_plugin_manager_update_file_info (_tmp52_, _tmp53_);
				}
			}
			_tmp54_ = path;
			_tmp55_ = end_path;
			if (gtk_tree_path_compare (_tmp54_, _tmp55_) != 0) {
				gboolean _tmp56_;
				_tmp56_ = files_abstract_directory_view_get_next_visible_iter (self, &iter, TRUE);
				valid_iter = _tmp56_;
			} else {
				valid_iter = FALSE;
			}
		}
	}
	if (actually_visible > ((guint) 0)) {
		_tmp57_ = self->priv->thumbnail_source_id > ((guint) 0);
	} else {
		_tmp57_ = FALSE;
	}
	if (_tmp57_) {
		FilesThumbnailer* _tmp58_;
		GList* _tmp59_;
		gint _tmp60_ = 0;
		_tmp58_ = self->priv->thumbnailer;
		_tmp59_ = visible_files;
		files_thumbnailer_queue_files (_tmp58_, _tmp59_, &_tmp60_, self->large_thumbnails);
		self->priv->thumbnail_request = _tmp60_;
	} else {
		files_abstract_directory_view_draw_when_idle (self);
	}
	self->priv->thumbnail_source_id = (guint) 0;
	result = G_SOURCE_REMOVE;
	(visible_files == NULL) ? NULL : (visible_files = (_g_list_free__g_object_unref0_ (visible_files), NULL));
	_g_object_unref0 (file);
	__vala_GtkTreePath_free0 (ep);
	__vala_GtkTreePath_free0 (sp);
	__vala_GtkTreePath_free0 (path);
	__vala_GtkTreePath_free0 (end_path);
	__vala_GtkTreePath_free0 (start_path);
	return result;
}

static gboolean
___lambda69__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda69_ ((FilesAbstractDirectoryView*) self);
	return result;
}

static void
files_abstract_directory_view_schedule_thumbnail_color_tag_timeout (FilesAbstractDirectoryView* self)
{
	gboolean _tmp0_ = FALSE;
	FilesViewSlot* _tmp1_;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	guint delay = 0U;
	FilesViewSlot* _tmp15_;
	gint _tmp16_;
	gint _tmp17_;
	guint _tmp18_;
	g_return_if_fail (self != NULL);
	_tmp1_ = self->slot;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, FILES_TYPE_ABSTRACT_SLOT)) {
		FilesViewSlot* _tmp2_;
		FilesDirectory* _tmp3_;
		FilesDirectory* _tmp4_;
		_tmp2_ = self->slot;
		_tmp3_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp2_);
		_tmp4_ = _tmp3_;
		_tmp0_ = _tmp4_ != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	_vala_assert (_tmp0_, "slot is Files.AbstractSlot && slot.directory != null");
	if (self->priv->thumbnail_source_id != ((guint) 0)) {
		_tmp6_ = TRUE;
	} else {
		FilesViewSlot* _tmp7_;
		FilesDirectory* _tmp8_;
		FilesDirectory* _tmp9_;
		gboolean _tmp10_;
		gboolean _tmp11_;
		_tmp7_ = self->slot;
		_tmp8_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp7_);
		_tmp9_ = _tmp8_;
		_tmp10_ = files_directory_get_can_open_files (_tmp9_);
		_tmp11_ = _tmp10_;
		_tmp6_ = !_tmp11_;
	}
	if (_tmp6_) {
		_tmp5_ = TRUE;
	} else {
		FilesViewSlot* _tmp12_;
		FilesDirectory* _tmp13_;
		FilesDirectory* _tmp14_;
		_tmp12_ = self->slot;
		_tmp13_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp12_);
		_tmp14_ = _tmp13_;
		_tmp5_ = files_directory_is_loading (_tmp14_);
	}
	if (_tmp5_) {
		return;
	}
	files_abstract_directory_view_cancel_timeout (self, &self->priv->thumbnail_source_id);
	files_abstract_directory_view_cancel_timeout (self, &self->priv->freeze_source_id);
	files_abstract_directory_view_freeze_child_notify (self);
	self->priv->freeze_source_id = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 100, ___lambda68__gsource_func, g_object_ref (self), g_object_unref);
	_tmp15_ = self->slot;
	_tmp16_ = files_view_slot_get_displayed_files_count (_tmp15_);
	_tmp17_ = _tmp16_;
	delay = MIN ((guint) (50 + (_tmp17_ / 10)), (guint) 500);
	_tmp18_ = delay;
	self->priv->thumbnail_source_id = g_timeout_add_full (G_PRIORITY_DEFAULT, _tmp18_, ___lambda69__gsource_func, g_object_ref (self), g_object_unref);
}

static gboolean
__lambda70_ (FilesAbstractDirectoryView* self)
{
	GtkWidget* _tmp0_;
	gboolean result;
	self->priv->draw_timeout_id = (guint) 0;
	_tmp0_ = self->priv->view;
	gtk_widget_queue_draw (_tmp0_);
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
___lambda70__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda70_ ((FilesAbstractDirectoryView*) self);
	return result;
}

static void
files_abstract_directory_view_draw_when_idle (FilesAbstractDirectoryView* self)
{
	g_return_if_fail (self != NULL);
	if (self->priv->draw_timeout_id > ((guint) 0)) {
		return;
	}
	self->priv->draw_timeout_id = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 100, ___lambda70__gsource_func, g_object_ref (self), g_object_unref);
}

void
files_abstract_directory_view_block_model (FilesAbstractDirectoryView* self)
{
	FilesListModel* _tmp0_;
	guint _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->model;
	g_signal_parse_name ("row-deleted", gtk_tree_model_get_type (), &_tmp1_, NULL, FALSE);
	g_signal_handlers_disconnect_matched ((GtkTreeModel*) _tmp0_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _files_abstract_directory_view_on_row_deleted_gtk_tree_model_row_deleted, self);
}

void
files_abstract_directory_view_unblock_model (FilesAbstractDirectoryView* self)
{
	FilesListModel* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->model;
	g_signal_connect_object ((GtkTreeModel*) _tmp0_, "row-deleted", (GCallback) _files_abstract_directory_view_on_row_deleted_gtk_tree_model_row_deleted, self, 0);
}

static gboolean
_files_abstract_directory_view_on_drag_timeout_button_release_gtk_widget_button_release_event (GtkWidget* _sender,
                                                                                               GdkEventButton* event,
                                                                                               gpointer self)
{
	gboolean result;
	result = files_abstract_directory_view_on_drag_timeout_button_release ((FilesAbstractDirectoryView*) self, event);
	return result;
}

static gboolean
_files_abstract_directory_view_on_drag_timeout_motion_notify_gtk_widget_motion_notify_event (GtkWidget* _sender,
                                                                                             GdkEventMotion* event,
                                                                                             gpointer self)
{
	gboolean result;
	result = files_abstract_directory_view_on_drag_timeout_motion_notify ((FilesAbstractDirectoryView*) self, event);
	return result;
}

static void
files_abstract_directory_view_connect_drag_timeout_motion_and_release_events (FilesAbstractDirectoryView* self)
{
	GtkWidget* real_view = NULL;
	GtkWidget* _tmp0_;
	GtkWidget* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_bin_get_child ((GtkBin*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	real_view = _tmp1_;
	g_signal_connect_object (real_view, "button-release-event", (GCallback) _files_abstract_directory_view_on_drag_timeout_button_release_gtk_widget_button_release_event, self, 0);
	g_signal_connect_object (real_view, "motion-notify-event", (GCallback) _files_abstract_directory_view_on_drag_timeout_motion_notify_gtk_widget_motion_notify_event, self, 0);
	_g_object_unref0 (real_view);
}

static void
files_abstract_directory_view_disconnect_drag_timeout_motion_and_release_events (FilesAbstractDirectoryView* self)
{
	GtkWidget* real_view = NULL;
	GtkWidget* _tmp0_;
	GtkWidget* _tmp1_;
	GtkWidget* _tmp2_;
	guint _tmp3_;
	GtkWidget* _tmp4_;
	guint _tmp5_;
	g_return_if_fail (self != NULL);
	if (self->priv->drag_timer_id == ((guint) 0)) {
		return;
	}
	_tmp0_ = gtk_bin_get_child ((GtkBin*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	real_view = _tmp1_;
	_tmp2_ = real_view;
	g_signal_parse_name ("button-release-event", gtk_widget_get_type (), &_tmp3_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp2_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp3_, 0, NULL, (GCallback) _files_abstract_directory_view_on_drag_timeout_button_release_gtk_widget_button_release_event, self);
	_tmp4_ = real_view;
	g_signal_parse_name ("motion-notify-event", gtk_widget_get_type (), &_tmp5_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp4_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp5_, 0, NULL, (GCallback) _files_abstract_directory_view_on_drag_timeout_motion_notify_gtk_widget_motion_notify_event, self);
	_g_object_unref0 (real_view);
}

static Block22Data*
block22_data_ref (Block22Data* _data22_)
{
	g_atomic_int_inc (&_data22_->_ref_count_);
	return _data22_;
}

static void
block22_data_unref (void * _userdata_)
{
	Block22Data* _data22_;
	_data22_ = (Block22Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data22_->_ref_count_)) {
		FilesAbstractDirectoryView* self;
		self = _data22_->self;
		_g_object_unref0 (_data22_->context);
		_g_object_unref0 (self);
		g_slice_free (Block22Data, _data22_);
	}
}

static gboolean
__lambda120_ (Block22Data* _data22_)
{
	FilesAbstractDirectoryView* self;
	GtkWidget* widget = NULL;
	GtkWidget* _tmp0_;
	GtkWidget* _tmp1_;
	GtkWidget* _tmp2_;
	gboolean result;
	self = _data22_->self;
	_tmp0_ = gtk_bin_get_child ((GtkBin*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	widget = _tmp1_;
	_tmp2_ = widget;
	if (_tmp2_ != NULL) {
		GdkDevice* pointer = NULL;
		GdkDevice* _tmp3_;
		GdkDevice* _tmp4_;
		GdkWindow* window = NULL;
		GtkWidget* _tmp5_;
		GdkWindow* _tmp6_;
		GdkWindow* _tmp7_;
		gint x = 0;
		gint y = 0;
		gint w = 0;
		gint h = 0;
		GdkWindow* _tmp8_;
		GdkDevice* _tmp9_;
		gint _tmp10_ = 0;
		gint _tmp11_ = 0;
		GdkWindow* _tmp12_;
		gint _tmp13_ = 0;
		gint _tmp14_ = 0;
		GtkAdjustment* _tmp15_;
		GtkAdjustment* _tmp16_;
		_tmp3_ = gdk_drag_context_get_device (_data22_->context);
		_tmp4_ = _g_object_ref0 (_tmp3_);
		pointer = _tmp4_;
		_tmp5_ = widget;
		_tmp6_ = gtk_widget_get_window (_tmp5_);
		_tmp7_ = _g_object_ref0 (_tmp6_);
		window = _tmp7_;
		_tmp8_ = window;
		_tmp9_ = pointer;
		gdk_window_get_device_position (_tmp8_, _tmp9_, &_tmp10_, &_tmp11_, NULL);
		x = _tmp10_;
		y = _tmp11_;
		_tmp12_ = window;
		gdk_window_get_geometry (_tmp12_, NULL, NULL, &_tmp13_, &_tmp14_);
		w = _tmp13_;
		h = _tmp14_;
		_tmp15_ = gtk_scrolled_window_get_vadjustment ((GtkScrolledWindow*) self);
		files_abstract_directory_view_scroll_if_near_edge (self, y, h, 20, _tmp15_);
		_tmp16_ = gtk_scrolled_window_get_hadjustment ((GtkScrolledWindow*) self);
		files_abstract_directory_view_scroll_if_near_edge (self, x, w, 20, _tmp16_);
		result = G_SOURCE_CONTINUE;
		_g_object_unref0 (window);
		_g_object_unref0 (pointer);
		_g_object_unref0 (widget);
		return result;
	} else {
		result = G_SOURCE_REMOVE;
		_g_object_unref0 (widget);
		return result;
	}
}

static gboolean
___lambda120__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda120_ (self);
	return result;
}

static void
files_abstract_directory_view_start_drag_scroll_timer (FilesAbstractDirectoryView* self,
                                                       GdkDragContext* context)
{
	Block22Data* _data22_;
	GdkDragContext* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	_data22_ = g_slice_new0 (Block22Data);
	_data22_->_ref_count_ = 1;
	_data22_->self = g_object_ref (self);
	_tmp0_ = _g_object_ref0 (context);
	_g_object_unref0 (_data22_->context);
	_data22_->context = _tmp0_;
	self->priv->drag_scroll_timer_id = g_timeout_add_full (G_PRIORITY_LOW, (guint) 50, ___lambda120__gsource_func, block22_data_ref (_data22_), block22_data_unref);
	block22_data_unref (_data22_);
	_data22_ = NULL;
}

static void
files_abstract_directory_view_scroll_if_near_edge (FilesAbstractDirectoryView* self,
                                                   gint pos,
                                                   gint dim,
                                                   gint threshold,
                                                   GtkAdjustment* adj)
{
	gint band = 0;
	gint offset = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (adj != NULL);
	band = 2 * threshold;
	offset = pos - band;
	if (offset > 0) {
		offset = MAX (band - (dim - pos), 0);
	}
	if (offset != 0) {
		gdouble val = 0.0;
		gdouble lower = 0.0;
		gdouble upper = 0.0;
		gdouble page = 0.0;
		val = gtk_adjustment_get_value (adj);
		lower = gtk_adjustment_get_lower (adj);
		upper = gtk_adjustment_get_upper (adj);
		page = gtk_adjustment_get_page_size (adj);
		val = CLAMP (val + (2 * offset), lower, upper - page);
		gtk_adjustment_set_value (adj, val);
	}
}

static void
files_abstract_directory_view_remove_marlin_icon_info_cache (FilesAbstractDirectoryView* self,
                                                             FilesFile* file)
{
	gchar* path = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	_tmp0_ = files_file_get_thumbnail_path (file);
	_tmp1_ = g_strdup (_tmp0_);
	path = _tmp1_;
	_tmp2_ = path;
	if (_tmp2_ != NULL) {
		FilesIconSize s = 0;
		{
			gint z = 0;
			z = (gint) FILES_ZOOM_LEVEL_SMALLEST;
			{
				gboolean _tmp3_ = FALSE;
				_tmp3_ = TRUE;
				while (TRUE) {
					const gchar* _tmp5_;
					if (!_tmp3_) {
						gint _tmp4_;
						_tmp4_ = z;
						z = _tmp4_ + 1;
					}
					_tmp3_ = FALSE;
					if (!(z <= ((gint) FILES_ZOOM_LEVEL_LARGEST))) {
						break;
					}
					s = files_zoom_level_to_icon_size ((FilesZoomLevel) z);
					_tmp5_ = path;
					files_icon_info_remove_cache (_tmp5_, (gint) s, gtk_widget_get_scale_factor ((GtkWidget*) self));
				}
			}
		}
	}
	_g_free0 (path);
}

static Block23Data*
block23_data_ref (Block23Data* _data23_)
{
	g_atomic_int_inc (&_data23_->_ref_count_);
	return _data23_;
}

static void
block23_data_unref (void * _userdata_)
{
	Block23Data* _data23_;
	_data23_ = (Block23Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data23_->_ref_count_)) {
		FilesAbstractDirectoryView* self;
		self = _data23_->self;
		(_data23_->action_files == NULL) ? NULL : (_data23_->action_files = (_g_list_free__g_object_unref0_ (_data23_->action_files), NULL));
		_g_object_unref0 (self);
		g_slice_free (Block23Data, _data23_);
	}
}

static void
____lambda53_ (Block23Data* _data23_,
               FilesFile* file)
{
	FilesAbstractDirectoryView* self;
	FilesFile* goffile = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	FilesFile* _tmp2_;
	FilesFile* _tmp3_;
	FilesFile* _tmp4_;
	self = _data23_->self;
	g_return_if_fail (file != NULL);
	_tmp0_ = files_file_get_display_target_uri (file);
	_tmp1_ = _tmp0_;
	_tmp2_ = files_file_get_by_uri (_tmp1_);
	_tmp3_ = _tmp2_;
	_g_free0 (_tmp1_);
	goffile = _tmp3_;
	files_file_query_update (goffile);
	_tmp4_ = _g_object_ref0 (goffile);
	_data23_->action_files = g_list_append (_data23_->action_files, _tmp4_);
	_g_object_unref0 (goffile);
}

static void
_____lambda53__gfunc (gconstpointer data,
                      gpointer self)
{
	____lambda53_ (self, (FilesFile*) data);
}

static GList*
files_abstract_directory_view_get_files_for_action (FilesAbstractDirectoryView* self)
{
	Block23Data* _data23_;
	GList* _tmp0_;
	GList* _tmp11_;
	GList* result;
	g_return_val_if_fail (self != NULL, NULL);
	_data23_ = g_slice_new0 (Block23Data);
	_data23_->_ref_count_ = 1;
	_data23_->self = g_object_ref (self);
	_data23_->action_files = NULL;
	files_abstract_directory_view_update_selected_files_and_menu (self);
	_tmp0_ = self->selected_files;
	if (_tmp0_ == NULL) {
		FilesViewSlot* _tmp1_;
		FilesDirectory* _tmp2_;
		FilesDirectory* _tmp3_;
		FilesFile* _tmp4_;
		FilesFile* _tmp5_;
		FilesFile* _tmp6_;
		_tmp1_ = self->slot;
		_tmp2_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp1_);
		_tmp3_ = _tmp2_;
		_tmp4_ = files_directory_get_file (_tmp3_);
		_tmp5_ = _tmp4_;
		_tmp6_ = _g_object_ref0 (_tmp5_);
		_data23_->action_files = g_list_prepend (_data23_->action_files, _tmp6_);
	} else {
		gboolean _tmp7_;
		_tmp7_ = self->priv->_in_recent;
		if (_tmp7_) {
			GList* _tmp8_;
			_tmp8_ = self->selected_files;
			g_list_foreach (_tmp8_, _____lambda53__gfunc, _data23_);
		} else {
			GList* _tmp9_;
			GList* _tmp10_;
			_tmp9_ = self->selected_files;
			_tmp10_ = g_list_copy_deep (_tmp9_, (GCopyFunc) g_object_ref, NULL);
			(_data23_->action_files == NULL) ? NULL : (_data23_->action_files = (_g_list_free__g_object_unref0_ (_data23_->action_files), NULL));
			_data23_->action_files = _tmp10_;
		}
	}
	_tmp11_ = _data23_->action_files;
	_data23_->action_files = NULL;
	result = _tmp11_;
	block23_data_unref (_data23_);
	_data23_ = NULL;
	return result;
}

void
files_abstract_directory_view_on_view_items_activated (FilesAbstractDirectoryView* self)
{
	GList* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = files_abstract_directory_view_get_selected_files (self);
	files_abstract_directory_view_activate_selected_items (self, FILES_OPEN_FLAG_DEFAULT, _tmp0_);
}

void
files_abstract_directory_view_on_view_selection_changed (FilesAbstractDirectoryView* self)
{
	gboolean _tmp0_ = FALSE;
	GList* _tmp1_;
	g_return_if_fail (self != NULL);
	self->priv->selected_files_invalid = TRUE;
	_tmp1_ = self->selected_files;
	if (_tmp1_ == NULL) {
		_tmp0_ = TRUE;
	} else {
		GList* _tmp2_;
		GList* _tmp3_;
		_tmp2_ = self->selected_files;
		_tmp3_ = _tmp2_->next;
		_tmp0_ = _tmp3_ == NULL;
	}
	self->one_or_less = _tmp0_;
}

/** Keyboard event handling **/
static gboolean
__lambda67_ (FilesAbstractDirectoryView* self)
{
	gboolean result;
	files_abstract_directory_view_update_selected_files_and_menu (self);
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
___lambda67__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda67_ ((FilesAbstractDirectoryView*) self);
	return result;
}

static gboolean
files_abstract_directory_view_real_on_view_key_press_event (FilesAbstractDirectoryView* self,
                                                            GdkEventKey* event)
{
	gboolean _tmp0_;
	gboolean _tmp1_;
	GdkModifierType consumed_mods = 0U;
	GdkModifierType state = 0U;
	guint keyval = 0U;
	GdkModifierType _tmp2_ = 0U;
	guint _tmp3_;
	GdkModifierType _tmp4_ = 0U;
	GdkModifierType mods = 0U;
	gboolean no_mods = FALSE;
	gboolean shift_pressed = FALSE;
	gboolean _tmp5_ = FALSE;
	gboolean only_shift_pressed = FALSE;
	gboolean control_pressed = FALSE;
	gboolean alt_pressed = FALSE;
	gboolean other_mod_pressed = FALSE;
	gboolean _tmp6_ = FALSE;
	gboolean only_control_pressed = FALSE;
	gboolean _tmp7_ = FALSE;
	gboolean only_alt_pressed = FALSE;
	gboolean in_trash = FALSE;
	FilesViewSlot* _tmp8_;
	GFile* _tmp9_;
	GFile* _tmp10_;
	gboolean in_recent = FALSE;
	FilesViewSlot* _tmp11_;
	GFile* _tmp12_;
	GFile* _tmp13_;
	gboolean res = FALSE;
	gboolean result;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = files_abstract_directory_view_get_is_frozen (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_) {
		result = TRUE;
		return result;
	}
	if (event->is_modifier == ((guint) 1)) {
		result = TRUE;
		return result;
	}
	files_abstract_directory_view_cancel_hover (self);
	_tmp3_ = key_utils_map_key (event, &_tmp2_);
	consumed_mods = _tmp2_;
	keyval = _tmp3_;
	gdk_event_get_state ((GdkEvent*) event, &_tmp4_);
	state = _tmp4_;
	mods = (state & (~consumed_mods)) & gtk_accelerator_get_default_mod_mask ();
	no_mods = mods == 0;
	shift_pressed = (mods & GDK_SHIFT_MASK) != 0;
	if (shift_pressed) {
		_tmp5_ = (mods & (~GDK_SHIFT_MASK)) == 0;
	} else {
		_tmp5_ = FALSE;
	}
	only_shift_pressed = _tmp5_;
	control_pressed = (mods & GDK_CONTROL_MASK) != 0;
	alt_pressed = (mods & GDK_MOD1_MASK) != 0;
	other_mod_pressed = ((mods & (~GDK_SHIFT_MASK)) & (~GDK_CONTROL_MASK)) != 0;
	if (control_pressed) {
		_tmp6_ = !other_mod_pressed;
	} else {
		_tmp6_ = FALSE;
	}
	only_control_pressed = _tmp6_;
	if (alt_pressed) {
		_tmp7_ = (mods & (~GDK_MOD1_MASK)) == 0;
	} else {
		_tmp7_ = FALSE;
	}
	only_alt_pressed = _tmp7_;
	_tmp8_ = self->slot;
	_tmp9_ = files_abstract_slot_get_location ((FilesAbstractSlot*) _tmp8_);
	_tmp10_ = _tmp9_;
	in_trash = g_file_has_uri_scheme (_tmp10_, "trash");
	_tmp11_ = self->slot;
	_tmp12_ = files_abstract_slot_get_location ((FilesAbstractSlot*) _tmp11_);
	_tmp13_ = _tmp12_;
	in_recent = g_file_has_uri_scheme (_tmp13_, "recent");
	res = FALSE;
	switch (keyval) {
		case GDK_KEY_F10:
		{
			if (only_control_pressed) {
				files_abstract_directory_view_show_context_menu (self, (GdkEvent*) event);
				res = TRUE;
			}
			break;
		}
		case GDK_KEY_F2:
		{
			gboolean _tmp14_ = FALSE;
			if (no_mods) {
				GSimpleActionGroup* _tmp15_;
				_tmp15_ = self->priv->selection_actions;
				_tmp14_ = g_action_group_get_action_enabled ((GActionGroup*) _tmp15_, "rename");
			} else {
				_tmp14_ = FALSE;
			}
			if (_tmp14_) {
				files_abstract_directory_view_rename_selected_file (self);
				res = TRUE;
			}
			break;
		}
		case GDK_KEY_Delete:
		case GDK_KEY_KP_Delete:
		{
			if (!self->is_writable) {
				FilesViewWindow* _tmp16_;
				GraniteMessageDialog* _tmp17_;
				GraniteMessageDialog* _tmp18_;
				_tmp16_ = self->window;
				_tmp17_ = pf_dialogs_show_warning_dialog (_ ("Cannot remove files from here"), _ ("You do not have permission to change this location"), G_TYPE_CHECK_INSTANCE_TYPE (_tmp16_, gtk_window_get_type ()) ? ((GtkWindow*) _tmp16_) : NULL);
				_tmp18_ = _tmp17_;
				_g_object_unref0 (_tmp18_);
			} else {
				gboolean _tmp19_;
				_tmp19_ = self->priv->_renaming;
				if (!_tmp19_) {
					gboolean _tmp20_ = FALSE;
					gboolean _tmp21_ = FALSE;
					if (in_trash) {
						_tmp21_ = TRUE;
					} else {
						_tmp21_ = files_is_admin ();
					}
					if (_tmp21_) {
						_tmp20_ = TRUE;
					} else {
						_tmp20_ = only_shift_pressed;
					}
					files_abstract_directory_view_trash_or_delete_selected_files (self, _tmp20_);
					res = TRUE;
				}
			}
			break;
		}
		case GDK_KEY_space:
		{
			gboolean _tmp22_ = FALSE;
			if (files_abstract_directory_view_view_has_focus (self)) {
				_tmp22_ = !in_trash;
			} else {
				_tmp22_ = FALSE;
			}
			if (_tmp22_) {
				GList* _tmp23_;
				_tmp23_ = files_abstract_directory_view_get_selected_files (self);
				files_abstract_directory_view_activate_selected_items (self, FILES_OPEN_FLAG_NEW_TAB, _tmp23_);
				res = TRUE;
			}
			break;
		}
		case GDK_KEY_Return:
		case GDK_KEY_KP_Enter:
		{
			if (in_trash) {
				break;
			} else {
				if (in_recent) {
					GList* _tmp24_;
					_tmp24_ = files_abstract_directory_view_get_selected_files (self);
					files_abstract_directory_view_activate_selected_items (self, FILES_OPEN_FLAG_DEFAULT, _tmp24_);
				} else {
					if (only_shift_pressed) {
						GList* _tmp25_;
						_tmp25_ = files_abstract_directory_view_get_selected_files (self);
						files_abstract_directory_view_activate_selected_items (self, FILES_OPEN_FLAG_NEW_TAB, _tmp25_);
					} else {
						gboolean _tmp26_ = FALSE;
						gboolean _tmp27_ = FALSE;
						if (shift_pressed) {
							_tmp27_ = control_pressed;
						} else {
							_tmp27_ = FALSE;
						}
						if (_tmp27_) {
							_tmp26_ = !alt_pressed;
						} else {
							_tmp26_ = FALSE;
						}
						if (_tmp26_) {
							GList* _tmp28_;
							_tmp28_ = files_abstract_directory_view_get_selected_files (self);
							files_abstract_directory_view_activate_selected_items (self, FILES_OPEN_FLAG_NEW_WINDOW, _tmp28_);
						} else {
							if (only_alt_pressed) {
								GSimpleActionGroup* _tmp29_;
								_tmp29_ = self->priv->common_actions;
								g_action_group_activate_action ((GActionGroup*) _tmp29_, "properties", NULL);
							} else {
								if (no_mods) {
									GList* _tmp30_;
									_tmp30_ = files_abstract_directory_view_get_selected_files (self);
									files_abstract_directory_view_activate_selected_items (self, FILES_OPEN_FLAG_DEFAULT, _tmp30_);
								} else {
									break;
								}
							}
						}
					}
				}
			}
			res = TRUE;
			break;
		}
		case GDK_KEY_minus:
		{
			gboolean _tmp31_ = FALSE;
			if (alt_pressed) {
				_tmp31_ = control_pressed;
			} else {
				_tmp31_ = FALSE;
			}
			if (_tmp31_) {
				GtkTreePath* path = NULL;
				GtkTreePath* _tmp32_;
				gboolean _tmp33_ = FALSE;
				GtkTreePath* _tmp34_;
				_tmp32_ = files_abstract_directory_view_get_path_at_cursor (self);
				path = _tmp32_;
				_tmp34_ = path;
				if (_tmp34_ != NULL) {
					GtkTreePath* _tmp35_;
					_tmp35_ = path;
					_tmp33_ = files_abstract_directory_view_path_is_selected (self, _tmp35_);
				} else {
					_tmp33_ = FALSE;
				}
				if (_tmp33_) {
					GtkTreePath* _tmp36_;
					_tmp36_ = path;
					files_abstract_directory_view_unselect_path (self, _tmp36_);
				}
				res = TRUE;
				__vala_GtkTreePath_free0 (path);
			}
			break;
		}
		case GDK_KEY_plus:
		case GDK_KEY_equal:
		{
			gboolean _tmp37_ = FALSE;
			if (alt_pressed) {
				_tmp37_ = control_pressed;
			} else {
				_tmp37_ = FALSE;
			}
			if (_tmp37_) {
				GtkTreePath* path = NULL;
				GtkTreePath* _tmp38_;
				gboolean _tmp39_ = FALSE;
				GtkTreePath* _tmp40_;
				_tmp38_ = files_abstract_directory_view_get_path_at_cursor (self);
				path = _tmp38_;
				_tmp40_ = path;
				if (_tmp40_ != NULL) {
					GtkTreePath* _tmp41_;
					_tmp41_ = path;
					_tmp39_ = !files_abstract_directory_view_path_is_selected (self, _tmp41_);
				} else {
					_tmp39_ = FALSE;
				}
				if (_tmp39_) {
					GtkTreePath* _tmp42_;
					_tmp42_ = path;
					files_abstract_directory_view_select_path (self, _tmp42_, FALSE);
				}
				res = TRUE;
				__vala_GtkTreePath_free0 (path);
			}
			break;
		}
		case GDK_KEY_Escape:
		{
			if (no_mods) {
				files_abstract_directory_view_unselect_all (self);
			}
			break;
		}
		case GDK_KEY_Menu:
		case GDK_KEY_MenuKB:
		{
			if (no_mods) {
				files_abstract_directory_view_show_context_menu (self, (GdkEvent*) event);
				res = TRUE;
			}
			break;
		}
		case GDK_KEY_N:
		{
			if (control_pressed) {
				files_abstract_directory_view_new_empty_folder (self);
				res = TRUE;
			}
			break;
		}
		case GDK_KEY_Up:
		case GDK_KEY_Down:
		case GDK_KEY_Left:
		case GDK_KEY_Right:
		{
			GList* selection = NULL;
			GList* _tmp43_;
			gboolean _tmp44_ = FALSE;
			_tmp43_ = files_abstract_directory_view_get_selected_files (self);
			selection = _tmp43_;
			if (only_alt_pressed) {
				_tmp44_ = keyval == GDK_KEY_Down;
			} else {
				_tmp44_ = FALSE;
			}
			if (_tmp44_) {
				gboolean _tmp45_ = FALSE;
				gboolean _tmp46_ = FALSE;
				GList* _tmp47_;
				_tmp47_ = selection;
				if (_tmp47_ != NULL) {
					GList* _tmp48_;
					GList* _tmp49_;
					GList* _tmp50_;
					_tmp48_ = selection;
					_tmp49_ = g_list_first (_tmp48_);
					_tmp50_ = _tmp49_->next;
					_tmp46_ = _tmp50_ == NULL;
				} else {
					_tmp46_ = FALSE;
				}
				if (_tmp46_) {
					GList* _tmp51_;
					gconstpointer _tmp52_;
					_tmp51_ = selection;
					_tmp52_ = _tmp51_->data;
					_tmp45_ = files_file_is_folder ((FilesFile*) _tmp52_);
				} else {
					_tmp45_ = FALSE;
				}
				if (_tmp45_) {
					GList* _tmp53_;
					gconstpointer _tmp54_;
					GFile* _tmp55_;
					GFile* _tmp56_;
					_tmp53_ = selection;
					_tmp54_ = _tmp53_->data;
					_tmp55_ = files_file_get_location ((FilesFile*) _tmp54_);
					_tmp56_ = _tmp55_;
					files_abstract_directory_view_load_location (self, _tmp56_);
					res = TRUE;
				}
				break;
			}
			res = files_abstract_directory_view_move_cursor (self, keyval, only_shift_pressed, control_pressed);
			break;
		}
		case GDK_KEY_Home:
		{
			gboolean _tmp57_ = FALSE;
			if (only_shift_pressed) {
				GtkTreePath* _tmp58_;
				GtkTreePath* _tmp59_;
				_tmp58_ = gtk_tree_path_new_from_indices (0, -1);
				_tmp59_ = _tmp58_;
				_tmp57_ = files_abstract_directory_view_handle_multi_select (self, _tmp59_);
				__vala_GtkTreePath_free0 (_tmp59_);
			} else {
				_tmp57_ = FALSE;
			}
			res = _tmp57_;
			break;
		}
		case GDK_KEY_End:
		{
			gboolean _tmp60_ = FALSE;
			if (only_shift_pressed) {
				FilesListModel* _tmp61_;
				GtkTreePath* _tmp62_;
				GtkTreePath* _tmp63_;
				_tmp61_ = self->model;
				_tmp62_ = gtk_tree_path_new_from_indices (files_list_model_get_length (_tmp61_), -1);
				_tmp63_ = _tmp62_;
				_tmp60_ = files_abstract_directory_view_handle_multi_select (self, _tmp63_);
				__vala_GtkTreePath_free0 (_tmp63_);
			} else {
				_tmp60_ = FALSE;
			}
			res = _tmp60_;
			break;
		}
		case GDK_KEY_c:
		case GDK_KEY_C:
		{
			if (only_control_pressed) {
				gboolean caps_on = FALSE;
				GdkDisplay* _tmp64_;
				GdkKeymap* _tmp65_;
				gboolean cap_c = FALSE;
				_tmp64_ = gtk_widget_get_display ((GtkWidget*) self);
				_tmp65_ = gdk_keymap_get_for_display (_tmp64_);
				caps_on = gdk_keymap_get_caps_lock_state (_tmp65_);
				cap_c = keyval == GDK_KEY_C;
				if (caps_on != cap_c) {
					GSimpleActionGroup* _tmp66_;
					_tmp66_ = self->priv->common_actions;
					g_action_group_activate_action ((GActionGroup*) _tmp66_, "copy-link", NULL);
				} else {
					if (in_trash) {
						FilesViewWindow* _tmp67_;
						GraniteMessageDialog* _tmp68_;
						GraniteMessageDialog* _tmp69_;
						GSimpleActionGroup* _tmp70_;
						_tmp67_ = self->window;
						_tmp68_ = pf_dialogs_show_warning_dialog (_ ("Cannot copy files that are in the trash"), _ ("Cutting the selection instead"), G_TYPE_CHECK_INSTANCE_TYPE (_tmp67_, gtk_window_get_type ()) ? ((GtkWindow*) _tmp67_) : NULL);
						_tmp69_ = _tmp68_;
						_g_object_unref0 (_tmp69_);
						_tmp70_ = self->priv->selection_actions;
						g_action_group_activate_action ((GActionGroup*) _tmp70_, "cut", NULL);
					} else {
						GSimpleActionGroup* _tmp71_;
						_tmp71_ = self->priv->common_actions;
						g_action_group_activate_action ((GActionGroup*) _tmp71_, "copy", NULL);
					}
				}
				res = TRUE;
			}
			break;
		}
		case GDK_KEY_v:
		case GDK_KEY_V:
		{
			if (only_control_pressed) {
				if (shift_pressed) {
					gboolean _tmp72_ = FALSE;
					files_abstract_directory_view_update_selected_files_and_menu (self);
					if (!in_recent) {
						_tmp72_ = self->is_writable;
					} else {
						_tmp72_ = FALSE;
					}
					if (_tmp72_) {
						gboolean _tmp73_ = FALSE;
						GList* _tmp74_;
						GList* _tmp75_;
						_tmp74_ = self->selected_files;
						_tmp75_ = g_list_first (_tmp74_);
						if (_tmp75_ != NULL) {
							GList* _tmp76_;
							GList* _tmp77_;
							GList* _tmp78_;
							_tmp76_ = self->selected_files;
							_tmp77_ = g_list_first (_tmp76_);
							_tmp78_ = _tmp77_->next;
							_tmp73_ = _tmp78_ != NULL;
						} else {
							_tmp73_ = FALSE;
						}
						if (_tmp73_) {
							gdk_beep ();
							g_warning ("AbstractDirectoryView.vala:3136: Cannot paste into a multiple selectio" \
"n");
						} else {
							GSimpleActionGroup* _tmp79_;
							GSimpleActionGroup* _tmp80_;
							_tmp79_ = self->priv->common_actions;
							files_abstract_directory_view_action_set_enabled (self, _tmp79_, "paste-into", TRUE);
							_tmp80_ = self->priv->common_actions;
							g_action_group_activate_action ((GActionGroup*) _tmp80_, "paste-into", NULL);
						}
					} else {
						FilesViewWindow* _tmp81_;
						GraniteMessageDialog* _tmp82_;
						GraniteMessageDialog* _tmp83_;
						_tmp81_ = self->window;
						_tmp82_ = pf_dialogs_show_warning_dialog (_ ("Cannot paste files here"), _ ("You do not have permission to change this location"), G_TYPE_CHECK_INSTANCE_TYPE (_tmp81_, gtk_window_get_type ()) ? ((GtkWindow*) _tmp81_) : NULL);
						_tmp83_ = _tmp82_;
						_g_object_unref0 (_tmp83_);
					}
					res = TRUE;
				} else {
					gboolean _tmp84_ = FALSE;
					if (!in_recent) {
						_tmp84_ = self->is_writable;
					} else {
						_tmp84_ = FALSE;
					}
					if (_tmp84_) {
						GSimpleActionGroup* _tmp85_;
						GSimpleActionGroup* _tmp86_;
						_tmp85_ = self->priv->common_actions;
						files_abstract_directory_view_action_set_enabled (self, _tmp85_, "paste", TRUE);
						_tmp86_ = self->priv->common_actions;
						g_action_group_activate_action ((GActionGroup*) _tmp86_, "paste", NULL);
					} else {
						FilesViewWindow* _tmp87_;
						GraniteMessageDialog* _tmp88_;
						GraniteMessageDialog* _tmp89_;
						_tmp87_ = self->window;
						_tmp88_ = pf_dialogs_show_warning_dialog (_ ("Cannot paste files here"), _ ("You do not have permission to change this location"), G_TYPE_CHECK_INSTANCE_TYPE (_tmp87_, gtk_window_get_type ()) ? ((GtkWindow*) _tmp87_) : NULL);
						_tmp89_ = _tmp88_;
						_g_object_unref0 (_tmp89_);
					}
					res = TRUE;
				}
			}
			break;
		}
		case GDK_KEY_x:
		case GDK_KEY_X:
		{
			if (only_control_pressed) {
				if (self->is_writable) {
					GSimpleActionGroup* _tmp90_;
					_tmp90_ = self->priv->selection_actions;
					g_action_group_activate_action ((GActionGroup*) _tmp90_, "cut", NULL);
				} else {
					FilesViewWindow* _tmp91_;
					GraniteMessageDialog* _tmp92_;
					GraniteMessageDialog* _tmp93_;
					_tmp91_ = self->window;
					_tmp92_ = pf_dialogs_show_warning_dialog (_ ("Cannot remove files from here"), _ ("You do not have permission to change this location"), G_TYPE_CHECK_INSTANCE_TYPE (_tmp91_, gtk_window_get_type ()) ? ((GtkWindow*) _tmp91_) : NULL);
					_tmp93_ = _tmp92_;
					_g_object_unref0 (_tmp93_);
				}
				res = TRUE;
			}
			break;
		}
		default:
		{
			break;
		}
	}
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ___lambda67__gsource_func, g_object_ref (self), g_object_unref);
	result = res;
	return result;
}

gboolean
files_abstract_directory_view_on_view_key_press_event (FilesAbstractDirectoryView* self,
                                                       GdkEventKey* event)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->on_view_key_press_event) {
		return _klass_->on_view_key_press_event (self, event);
	}
	return FALSE;
}

gboolean
files_abstract_directory_view_on_motion_notify_event (FilesAbstractDirectoryView* self,
                                                      GdkEventMotion* event)
{
	GtkTreePath* path = NULL;
	FilesFile* file = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	GtkTreePath* _tmp4_ = NULL;
	guint _tmp5_;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	gboolean _tmp8_ = FALSE;
	GtkTreePath* _tmp9_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	path = NULL;
	file = NULL;
	_tmp1_ = self->priv->_renaming;
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp2_;
		gboolean _tmp3_;
		_tmp2_ = files_abstract_directory_view_get_is_frozen (self);
		_tmp3_ = _tmp2_;
		_tmp0_ = _tmp3_;
	}
	if (_tmp0_) {
		result = TRUE;
		_g_object_unref0 (file);
		__vala_GtkTreePath_free0 (path);
		return result;
	}
	_tmp5_ = files_abstract_directory_view_get_event_position_info (self, (GdkEventButton*) event, &_tmp4_, FALSE);
	__vala_GtkTreePath_free0 (path);
	path = _tmp4_;
	self->click_zone = _tmp5_;
	_tmp9_ = path;
	if (_tmp9_ != NULL) {
		GtkTreePath* _tmp10_;
		_tmp10_ = self->priv->hover_path;
		_tmp8_ = _tmp10_ == NULL;
	} else {
		_tmp8_ = FALSE;
	}
	if (_tmp8_) {
		_tmp7_ = TRUE;
	} else {
		gboolean _tmp11_ = FALSE;
		GtkTreePath* _tmp12_;
		_tmp12_ = path;
		if (_tmp12_ == NULL) {
			GtkTreePath* _tmp13_;
			_tmp13_ = self->priv->hover_path;
			_tmp11_ = _tmp13_ != NULL;
		} else {
			_tmp11_ = FALSE;
		}
		_tmp7_ = _tmp11_;
	}
	if (_tmp7_) {
		_tmp6_ = TRUE;
	} else {
		gboolean _tmp14_ = FALSE;
		gboolean _tmp15_ = FALSE;
		GtkTreePath* _tmp16_;
		_tmp16_ = path;
		if (_tmp16_ != NULL) {
			GtkTreePath* _tmp17_;
			_tmp17_ = self->priv->hover_path;
			_tmp15_ = _tmp17_ != NULL;
		} else {
			_tmp15_ = FALSE;
		}
		if (_tmp15_) {
			GtkTreePath* _tmp18_;
			GtkTreePath* _tmp19_;
			_tmp18_ = path;
			_tmp19_ = self->priv->hover_path;
			_tmp14_ = gtk_tree_path_compare (_tmp18_, _tmp19_) != 0;
		} else {
			_tmp14_ = FALSE;
		}
		_tmp6_ = _tmp14_;
	}
	if (_tmp6_) {
		gboolean _tmp20_ = FALSE;
		FilesViewSlot* _tmp21_;
		FilesDirectory* _tmp22_;
		FilesDirectory* _tmp23_;
		gboolean _tmp24_;
		gboolean _tmp25_;
		self->on_directory = FALSE;
		_tmp21_ = self->slot;
		_tmp22_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp21_);
		_tmp23_ = _tmp22_;
		_tmp24_ = files_directory_get_is_local (_tmp23_);
		_tmp25_ = _tmp24_;
		if (_tmp25_) {
			_tmp20_ = TRUE;
		} else {
			GNetworkMonitor* _tmp26_;
			_tmp26_ = g_network_monitor_get_default ();
			_tmp20_ = g_network_monitor_get_network_available (_tmp26_);
		}
		if (_tmp20_) {
			FilesFile* target_file = NULL;
			FilesFile* _tmp27_ = NULL;
			GtkTreePath* _tmp28_;
			FilesFile* _tmp32_;
			gboolean _tmp33_ = FALSE;
			FilesFile* _tmp34_;
			FilesFile* _tmp47_;
			GtkTreePath* _tmp49_;
			GtkTreePath* _tmp50_;
			_tmp28_ = path;
			if (_tmp28_ != NULL) {
				FilesListModel* _tmp29_;
				GtkTreePath* _tmp30_;
				FilesFile* _tmp31_;
				_tmp29_ = self->model;
				_tmp30_ = path;
				_tmp31_ = files_list_model_file_for_path (_tmp29_, _tmp30_);
				_g_object_unref0 (_tmp27_);
				_tmp27_ = _tmp31_;
			} else {
				_g_object_unref0 (_tmp27_);
				_tmp27_ = NULL;
			}
			_tmp32_ = _g_object_ref0 (_tmp27_);
			_g_object_unref0 (file);
			file = _tmp32_;
			_tmp34_ = file;
			if (_tmp34_ != NULL) {
				FilesViewSlot* _tmp35_;
				FilesDirectory* _tmp36_;
				FilesDirectory* _tmp37_;
				gboolean _tmp38_;
				gboolean _tmp39_;
				_tmp35_ = self->slot;
				_tmp36_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp35_);
				_tmp37_ = _tmp36_;
				_tmp38_ = files_directory_get_is_recent (_tmp37_);
				_tmp39_ = _tmp38_;
				_tmp33_ = _tmp39_;
			} else {
				_tmp33_ = FALSE;
			}
			if (_tmp33_) {
				FilesFile* _tmp40_;
				gchar* _tmp41_;
				gchar* _tmp42_;
				FilesFile* _tmp43_;
				FilesFile* _tmp44_;
				_tmp40_ = file;
				_tmp41_ = files_file_get_display_target_uri (_tmp40_);
				_tmp42_ = _tmp41_;
				_tmp43_ = files_file_get_by_uri (_tmp42_);
				_g_object_unref0 (target_file);
				target_file = _tmp43_;
				_g_free0 (_tmp42_);
				_tmp44_ = target_file;
				files_file_ensure_query_info (_tmp44_);
			} else {
				FilesFile* _tmp45_;
				FilesFile* _tmp46_;
				_tmp45_ = file;
				_tmp46_ = _g_object_ref0 (_tmp45_);
				_g_object_unref0 (target_file);
				target_file = _tmp46_;
			}
			_tmp47_ = target_file;
			if (_tmp47_ != NULL) {
				FilesFile* _tmp48_;
				_tmp48_ = target_file;
				self->on_directory = _tmp48_->is_directory;
			}
			_tmp49_ = path;
			_tmp50_ = __vala_GtkTreePath_copy0 (_tmp49_);
			__vala_GtkTreePath_free0 (self->priv->hover_path);
			self->priv->hover_path = _tmp50_;
			_g_object_unref0 (_tmp27_);
			_g_object_unref0 (target_file);
		}
	}
	if (self->click_zone != self->previous_click_zone) {
		GdkWindow* win = NULL;
		GtkWidget* _tmp51_;
		GdkWindow* _tmp52_;
		GdkWindow* _tmp53_;
		GdkWindow* _tmp54_;
		GdkCursor* _tmp55_;
		_tmp51_ = self->priv->view;
		_tmp52_ = gtk_widget_get_window (_tmp51_);
		_tmp53_ = _g_object_ref0 (_tmp52_);
		win = _tmp53_;
		_tmp54_ = win;
		_tmp55_ = self->priv->selectable_cursor;
		gdk_window_set_cursor (_tmp54_, _tmp55_);
		switch (self->click_zone) {
			case FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_ICON:
			case FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_NAME:
			{
				gboolean _tmp56_ = FALSE;
				gboolean _tmp57_ = FALSE;
				if (self->on_directory) {
					_tmp57_ = self->one_or_less;
				} else {
					_tmp57_ = FALSE;
				}
				if (_tmp57_) {
					gboolean _tmp58_;
					_tmp58_ = self->priv->_singleclick_select;
					_tmp56_ = !_tmp58_;
				} else {
					_tmp56_ = FALSE;
				}
				if (_tmp56_) {
					GdkWindow* _tmp59_;
					GdkCursor* _tmp60_;
					_tmp59_ = win;
					_tmp60_ = self->priv->activatable_cursor;
					gdk_window_set_cursor (_tmp59_, _tmp60_);
				}
				break;
			}
			default:
			{
				break;
			}
		}
		self->previous_click_zone = self->click_zone;
		_g_object_unref0 (win);
	}
	result = FALSE;
	_g_object_unref0 (file);
	__vala_GtkTreePath_free0 (path);
	return result;
}

gboolean
files_abstract_directory_view_on_leave_notify_event (FilesAbstractDirectoryView* self,
                                                     GdkEventCrossing* event)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	__vala_GtkTreePath_free0 (self->priv->hover_path);
	self->priv->hover_path = NULL;
	result = FALSE;
	return result;
}

static gboolean
files_abstract_directory_view_real_on_scroll_event (FilesAbstractDirectoryView* self,
                                                    GdkEventScroll* event)
{
	GdkScrollDirection direction = 0;
	GdkScrollDirection _tmp0_ = 0;
	GdkModifierType state = 0U;
	GdkModifierType _tmp1_ = 0U;
	gboolean result;
	g_return_val_if_fail (event != NULL, FALSE);
	gdk_event_get_scroll_direction ((GdkEvent*) event, &_tmp0_);
	direction = _tmp0_;
	gdk_event_get_state ((GdkEvent*) event, &_tmp1_);
	state = _tmp1_;
	if ((state & GDK_CONTROL_MASK) == 0) {
		gdouble increment = 0.0;
		increment = 0.0;
		switch (direction) {
			case GDK_SCROLL_LEFT:
			{
				increment = 5.0;
				break;
			}
			case GDK_SCROLL_RIGHT:
			{
				increment = -5.0;
				break;
			}
			case GDK_SCROLL_SMOOTH:
			{
				gdouble delta_x = 0.0;
				gdouble _tmp2_ = 0.0;
				gdk_event_get_scroll_deltas ((GdkEvent*) event, &_tmp2_, NULL);
				delta_x = _tmp2_;
				increment = delta_x * 10.0;
				break;
			}
			default:
			{
				break;
			}
		}
	}
	result = files_abstract_directory_view_handle_scroll_event (self, event);
	return result;
}

gboolean
files_abstract_directory_view_on_scroll_event (FilesAbstractDirectoryView* self,
                                               GdkEventScroll* event)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->on_scroll_event) {
		return _klass_->on_scroll_event (self, event);
	}
	return FALSE;
}

/** name renderer signals */
static GtkTreeIter*
_vala_GtkTreeIter_copy (GtkTreeIter* self)
{
	return g_boxed_copy (gtk_tree_iter_get_type (), self);
}

static gpointer
__vala_GtkTreeIter_copy0 (gpointer self)
{
	return self ? _vala_GtkTreeIter_copy (self) : NULL;
}

void
files_abstract_directory_view_on_name_editing_started (FilesAbstractDirectoryView* self,
                                                       GtkCellEditable* editable,
                                                       const gchar* path_string)
{
	FilesAbstractEditableLabel* editable_widget = NULL;
	FilesAbstractEditableLabel* _tmp0_;
	FilesAbstractEditableLabel* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path_string != NULL);
	_tmp0_ = _g_object_ref0 (FILES_IS_ABSTRACT_EDITABLE_LABEL (editable) ? ((FilesAbstractEditableLabel*) editable) : NULL);
	editable_widget = _tmp0_;
	_tmp1_ = editable_widget;
	if (_tmp1_ != NULL) {
		FilesAbstractEditableLabel* _tmp2_;
		gchar* _tmp3_;
		GtkTreePath* path = NULL;
		GtkTreePath* _tmp4_;
		GtkTreeIter* iter = NULL;
		FilesListModel* _tmp5_;
		GtkTreePath* _tmp6_;
		GtkTreeIter _tmp7_ = {0};
		GtkTreeIter _tmp8_;
		GtkTreeIter* _tmp9_;
		FilesFile* file = NULL;
		FilesListModel* _tmp10_;
		GtkTreeIter* _tmp11_;
		GtkTreeIter _tmp12_;
		FilesFile* _tmp13_ = NULL;
		gint start_offset = 0;
		gint end_offset = 0;
		FilesFile* _tmp14_;
		FilesAbstractEditableLabel* _tmp18_;
		_tmp2_ = editable_widget;
		_tmp3_ = files_abstract_editable_label_get_chars (_tmp2_, 0, -1);
		_g_free0 (self->original_name);
		self->original_name = _tmp3_;
		_tmp4_ = gtk_tree_path_new_from_string (path_string);
		path = _tmp4_;
		iter = NULL;
		_tmp5_ = self->model;
		_tmp6_ = path;
		gtk_tree_model_get_iter ((GtkTreeModel*) _tmp5_, &_tmp7_, _tmp6_);
		__vala_GtkTreeIter_free0 (iter);
		_tmp8_ = _tmp7_;
		_tmp9_ = __vala_GtkTreeIter_copy0 (&_tmp8_);
		iter = _tmp9_;
		file = NULL;
		_tmp10_ = self->model;
		_tmp11_ = iter;
		_tmp12_ = *_tmp11_;
		gtk_tree_model_get ((GtkTreeModel*) _tmp10_, &_tmp12_, FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN, &_tmp13_, -1);
		_g_object_unref0 (file);
		file = _tmp13_;
		start_offset = 0;
		end_offset = -1;
		_tmp14_ = file;
		if (!files_file_is_folder (_tmp14_)) {
			const gchar* _tmp15_;
			gint _tmp16_ = 0;
			gint _tmp17_ = 0;
			_tmp15_ = self->original_name;
			files_file_utils_get_rename_region (_tmp15_, &_tmp16_, &_tmp17_, FALSE);
			start_offset = _tmp16_;
			end_offset = _tmp17_;
		}
		_tmp18_ = editable_widget;
		files_abstract_editable_label_select_region (_tmp18_, start_offset, end_offset);
		_g_object_unref0 (file);
		__vala_GtkTreeIter_free0 (iter);
		__vala_GtkTreePath_free0 (path);
	} else {
		g_warning ("AbstractDirectoryView.vala:3306: Editable widget is null");
		files_abstract_directory_view_on_name_editing_canceled (self);
	}
	_g_object_unref0 (editable_widget);
}

void
files_abstract_directory_view_on_name_editing_canceled (FilesAbstractDirectoryView* self)
{
	FilesTextRenderer* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	files_abstract_directory_view_set_is_frozen (self, FALSE);
	files_abstract_directory_view_set_renaming (self, FALSE);
	_tmp0_ = self->name_renderer;
	g_object_set ((GtkCellRendererText*) _tmp0_, "editable", FALSE, NULL);
	_tmp1_ = g_strdup ("");
	_g_free0 (self->proposed_name);
	self->proposed_name = _tmp1_;
	files_abstract_directory_view_update_menu_actions (self);
	files_abstract_directory_view_grab_focus (self);
}

static gchar*
string_strip (const gchar* self)
{
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	g_strstrip (_result_);
	result = _result_;
	return result;
}

static void
____lambda72_ (FilesAbstractDirectoryView* self,
               GObject* obj,
               GAsyncResult* res)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (res != NULL);
	{
		GFile* _tmp0_;
		GFile* _tmp1_;
		_tmp0_ = files_abstract_directory_view_set_file_display_name_finish (self, res, &_inner_error0_);
		_tmp1_ = _tmp0_;
		_g_object_unref0 (_tmp1_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		g_clear_error (&_inner_error0_);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	files_abstract_directory_view_on_name_editing_canceled (self);
}

static void
_____lambda72__gasync_ready_callback (GObject* source_object,
                                      GAsyncResult* res,
                                      gpointer self)
{
	____lambda72_ ((FilesAbstractDirectoryView*) self, source_object, res);
	g_object_unref (self);
}

void
files_abstract_directory_view_on_name_edited (FilesAbstractDirectoryView* self,
                                              const gchar* path_string,
                                              const gchar* _new_name)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	gchar* new_name = NULL;
	gchar* _tmp2_;
	gboolean _tmp3_ = FALSE;
	const gchar* _tmp4_;
	gchar* _tmp7_;
	const gchar* _tmp8_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path_string != NULL);
	_tmp1_ = self->priv->_renaming;
	if (!_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = _new_name == NULL;
	}
	if (_tmp0_) {
		files_abstract_directory_view_on_name_editing_canceled (self);
		return;
	}
	_tmp2_ = string_strip (_new_name);
	new_name = _tmp2_;
	_tmp4_ = new_name;
	if (g_strcmp0 (_tmp4_, "") == 0) {
		_tmp3_ = TRUE;
	} else {
		const gchar* _tmp5_;
		const gchar* _tmp6_;
		_tmp5_ = self->proposed_name;
		_tmp6_ = new_name;
		_tmp3_ = g_strcmp0 (_tmp5_, _tmp6_) == 0;
	}
	if (_tmp3_) {
		g_warning ("AbstractDirectoryView.vala:3330: Blank name or name unchanged");
		files_abstract_directory_view_on_name_editing_canceled (self);
		_g_free0 (new_name);
		return;
	}
	_tmp7_ = g_strdup ("");
	_g_free0 (self->proposed_name);
	self->proposed_name = _tmp7_;
	_tmp8_ = new_name;
	if (g_strcmp0 (_tmp8_, "") != 0) {
		GtkTreePath* path = NULL;
		GtkTreePath* _tmp9_;
		GtkTreeIter* iter = NULL;
		FilesListModel* _tmp10_;
		GtkTreePath* _tmp11_;
		GtkTreeIter _tmp12_ = {0};
		GtkTreeIter _tmp13_;
		GtkTreeIter* _tmp14_;
		FilesFile* file = NULL;
		FilesListModel* _tmp15_;
		GtkTreeIter* _tmp16_;
		GtkTreeIter _tmp17_;
		FilesFile* _tmp18_ = NULL;
		const gchar* _tmp19_;
		const gchar* _tmp20_;
		_tmp9_ = gtk_tree_path_new_from_string (path_string);
		path = _tmp9_;
		iter = NULL;
		_tmp10_ = self->model;
		_tmp11_ = path;
		gtk_tree_model_get_iter ((GtkTreeModel*) _tmp10_, &_tmp12_, _tmp11_);
		__vala_GtkTreeIter_free0 (iter);
		_tmp13_ = _tmp12_;
		_tmp14_ = __vala_GtkTreeIter_copy0 (&_tmp13_);
		iter = _tmp14_;
		file = NULL;
		_tmp15_ = self->model;
		_tmp16_ = iter;
		_tmp17_ = *_tmp16_;
		gtk_tree_model_get ((GtkTreeModel*) _tmp15_, &_tmp17_, FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN, &_tmp18_, -1);
		_g_object_unref0 (file);
		file = _tmp18_;
		_tmp19_ = new_name;
		_tmp20_ = self->original_name;
		if (g_strcmp0 (_tmp19_, _tmp20_) != 0) {
			const gchar* _tmp21_;
			gchar* _tmp22_;
			FilesFile* _tmp23_;
			GFile* _tmp24_;
			GFile* _tmp25_;
			const gchar* _tmp26_;
			_tmp21_ = new_name;
			_tmp22_ = g_strdup (_tmp21_);
			_g_free0 (self->proposed_name);
			self->proposed_name = _tmp22_;
			_tmp23_ = file;
			_tmp24_ = files_file_get_location (_tmp23_);
			_tmp25_ = _tmp24_;
			_tmp26_ = new_name;
			files_abstract_directory_view_set_file_display_name (self, _tmp25_, _tmp26_, NULL, _____lambda72__gasync_ready_callback, g_object_ref (self));
		} else {
			g_warning ("AbstractDirectoryView.vala:3357: Name unchanged");
			files_abstract_directory_view_on_name_editing_canceled (self);
		}
		_g_object_unref0 (file);
		__vala_GtkTreeIter_free0 (iter);
		__vala_GtkTreePath_free0 (path);
	} else {
		g_warning ("AbstractDirectoryView.vala:3361: No new name");
		files_abstract_directory_view_on_name_editing_canceled (self);
	}
	_g_free0 (new_name);
}

static void
files_abstract_directory_view_set_file_display_name_data_free (gpointer _data)
{
	FilesAbstractDirectoryViewSetFileDisplayNameData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->old_location);
	_g_free0 (_data_->new_name);
	_g_object_unref0 (_data_->cancellable);
	_g_object_unref0 (_data_->result);
	_g_object_unref0 (_data_->self);
	g_slice_free (FilesAbstractDirectoryViewSetFileDisplayNameData, _data_);
}

void
files_abstract_directory_view_set_file_display_name (FilesAbstractDirectoryView* self,
                                                     GFile* old_location,
                                                     const gchar* new_name,
                                                     GCancellable* cancellable,
                                                     GAsyncReadyCallback _callback_,
                                                     gpointer _user_data_)
{
	FilesAbstractDirectoryViewSetFileDisplayNameData* _data_;
	FilesAbstractDirectoryView* _tmp0_;
	GFile* _tmp1_;
	gchar* _tmp2_;
	GCancellable* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (old_location != NULL);
	g_return_if_fail (new_name != NULL);
	_data_ = g_slice_new0 (FilesAbstractDirectoryViewSetFileDisplayNameData);
	_data_->_async_result = g_task_new (G_OBJECT (self), cancellable, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, files_abstract_directory_view_set_file_display_name_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = _g_object_ref0 (old_location);
	_g_object_unref0 (_data_->old_location);
	_data_->old_location = _tmp1_;
	_tmp2_ = g_strdup (new_name);
	_g_free0 (_data_->new_name);
	_data_->new_name = _tmp2_;
	_tmp3_ = _g_object_ref0 (cancellable);
	_g_object_unref0 (_data_->cancellable);
	_data_->cancellable = _tmp3_;
	files_abstract_directory_view_set_file_display_name_co (_data_);
}

GFile*
files_abstract_directory_view_set_file_display_name_finish (FilesAbstractDirectoryView* self,
                                                            GAsyncResult* _res_,
                                                            GError** error)
{
	GFile* result;
	FilesAbstractDirectoryViewSetFileDisplayNameData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		return NULL;
	}
	result = _data_->result;
	_data_->result = NULL;
	return result;
}

static void
_files_abstract_directory_view_after_renamed_file_added_files_directory_file_added (FilesDirectory* _sender,
                                                                                    FilesFile* file,
                                                                                    gpointer self)
{
	files_abstract_directory_view_after_renamed_file_added ((FilesAbstractDirectoryView*) self, file);
}

static void
files_abstract_directory_view_set_file_display_name_ready (GObject* source_object,
                                                           GAsyncResult* _res_,
                                                           gpointer _user_data_)
{
	FilesAbstractDirectoryViewSetFileDisplayNameData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	files_abstract_directory_view_set_file_display_name_co (_data_);
}

static gpointer
_g_error_copy0 (gpointer self)
{
	return self ? g_error_copy (self) : NULL;
}

static gboolean
files_abstract_directory_view_set_file_display_name_co (FilesAbstractDirectoryViewSetFileDisplayNameData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->self->slot;
	_data_->_tmp1_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _data_->_tmp0_);
	_data_->_tmp2_ = _data_->_tmp1_;
	g_signal_connect_object (_data_->_tmp2_, "file-added", (GCallback) _files_abstract_directory_view_after_renamed_file_added_files_directory_file_added, _data_->self, G_CONNECT_AFTER);
	{
		_data_->_state_ = 1;
		files_file_utils_set_file_display_name (_data_->old_location, _data_->new_name, _data_->cancellable, files_abstract_directory_view_set_file_display_name_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp4_ = files_file_utils_set_file_display_name_finish (_data_->_res_, &_data_->_inner_error0_);
		_data_->_tmp3_ = _data_->_tmp4_;
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		_data_->_tmp5_ = _data_->_tmp3_;
		_data_->_tmp3_ = NULL;
		_data_->result = _data_->_tmp5_;
		_g_object_unref0 (_data_->_tmp3_);
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (!g_task_get_completed (_data_->_async_result)) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	goto __finally0;
	__catch0_g_error:
	{
		_data_->e = _data_->_inner_error0_;
		_data_->_inner_error0_ = NULL;
		_data_->_tmp6_ = _data_->e;
		_data_->_tmp7_ = _g_error_copy0 (_data_->_tmp6_);
		_data_->_inner_error0_ = _data_->_tmp7_;
		_g_error_free0 (_data_->e);
		goto __finally0;
	}
	__finally0:
	g_task_return_error (_data_->_async_result, _data_->_inner_error0_);
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static void
files_abstract_directory_view_after_renamed_file_added (FilesAbstractDirectoryView* self,
                                                        FilesFile* new_file)
{
	FilesViewSlot* _tmp0_;
	FilesDirectory* _tmp1_;
	FilesDirectory* _tmp2_;
	guint _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->slot;
	_tmp1_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp0_);
	_tmp2_ = _tmp1_;
	g_signal_parse_name ("file-added", FILES_TYPE_DIRECTORY, &_tmp3_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp2_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp3_, 0, NULL, (GCallback) _files_abstract_directory_view_after_renamed_file_added_files_directory_file_added, self);
	if (new_file != NULL) {
		files_abstract_directory_view_select_and_scroll_to_gof_file (self, new_file);
	}
}

static PangoRectangle*
_pango_rectangle_dup (PangoRectangle* self)
{
	PangoRectangle* dup;
	dup = g_new0 (PangoRectangle, 1);
	memcpy (dup, self, sizeof (PangoRectangle));
	return dup;
}

static gpointer
__pango_rectangle_dup0 (gpointer self)
{
	return self ? _pango_rectangle_dup (self) : NULL;
}

static gboolean
files_abstract_directory_view_real_on_view_draw (FilesAbstractDirectoryView* self,
                                                 cairo_t* cr)
{
	GtkStyleContext* style_context = NULL;
	GtkStyleContext* _tmp0_;
	GtkStyleContext* _tmp1_;
	FilesViewSlot* _tmp2_;
	FilesDirectory* _tmp3_;
	FilesDirectory* _tmp4_;
	gboolean result;
	g_return_val_if_fail (cr != NULL, FALSE);
	_tmp0_ = gtk_widget_get_style_context ((GtkWidget*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	style_context = _tmp1_;
	_tmp2_ = self->slot;
	_tmp3_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp2_);
	_tmp4_ = _tmp3_;
	if (files_directory_is_empty (_tmp4_)) {
		PangoLayout* layout = NULL;
		PangoLayout* _tmp5_;
		GtkStyleContext* _tmp6_;
		PangoLayout* _tmp9_;
		FilesViewSlot* _tmp10_;
		gchar* _tmp11_;
		gchar* _tmp12_;
		PangoRectangle* extents = NULL;
		PangoLayout* _tmp13_;
		PangoRectangle _tmp14_ = {0};
		PangoRectangle _tmp15_;
		PangoRectangle* _tmp16_;
		gdouble width = 0.0;
		PangoRectangle* _tmp17_;
		gdouble height = 0.0;
		PangoRectangle* _tmp18_;
		gdouble x = 0.0;
		gdouble y = 0.0;
		GtkStyleContext* _tmp19_;
		PangoLayout* _tmp20_;
		_tmp5_ = gtk_widget_create_pango_layout ((GtkWidget*) self, NULL);
		layout = _tmp5_;
		_tmp6_ = style_context;
		if (!gtk_style_context_has_class (_tmp6_, GRANITE_STYLE_CLASS_H2_LABEL)) {
			GtkStyleContext* _tmp7_;
			GtkStyleContext* _tmp8_;
			_tmp7_ = style_context;
			gtk_style_context_add_class (_tmp7_, GRANITE_STYLE_CLASS_H2_LABEL);
			_tmp8_ = style_context;
			gtk_style_context_add_class (_tmp8_, GTK_STYLE_CLASS_VIEW);
		}
		_tmp9_ = layout;
		_tmp10_ = self->slot;
		_tmp11_ = files_view_slot_get_empty_message (_tmp10_);
		_tmp12_ = _tmp11_;
		pango_layout_set_markup (_tmp9_, _tmp12_, -1);
		_g_free0 (_tmp12_);
		extents = NULL;
		_tmp13_ = layout;
		pango_layout_get_extents (_tmp13_, NULL, &_tmp14_);
		_g_free0 (extents);
		_tmp15_ = _tmp14_;
		_tmp16_ = __pango_rectangle_dup0 (&_tmp15_);
		extents = _tmp16_;
		_tmp17_ = extents;
		width = pango_units_to_double ((*_tmp17_).width);
		_tmp18_ = extents;
		height = pango_units_to_double ((*_tmp18_).height);
		x = (((gdouble) gtk_widget_get_allocated_width ((GtkWidget*) self)) / 2) - (width / 2);
		y = (((gdouble) gtk_widget_get_allocated_height ((GtkWidget*) self)) / 2) - (height / 2);
		_tmp19_ = gtk_widget_get_style_context ((GtkWidget*) self);
		_tmp20_ = layout;
		gtk_render_layout (_tmp19_, cr, x, y, _tmp20_);
		result = TRUE;
		_g_free0 (extents);
		_g_object_unref0 (layout);
		_g_object_unref0 (style_context);
		return result;
	} else {
		GtkStyleContext* _tmp21_;
		_tmp21_ = style_context;
		if (gtk_style_context_has_class (_tmp21_, GRANITE_STYLE_CLASS_H2_LABEL)) {
			GtkStyleContext* _tmp22_;
			GtkStyleContext* _tmp23_;
			_tmp22_ = style_context;
			gtk_style_context_remove_class (_tmp22_, GRANITE_STYLE_CLASS_H2_LABEL);
			_tmp23_ = style_context;
			gtk_style_context_remove_class (_tmp23_, GTK_STYLE_CLASS_VIEW);
		}
	}
	result = FALSE;
	_g_object_unref0 (style_context);
	return result;
}

gboolean
files_abstract_directory_view_on_view_draw (FilesAbstractDirectoryView* self,
                                            cairo_t* cr)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->on_view_draw) {
		return _klass_->on_view_draw (self, cr);
	}
	return FALSE;
}

static gboolean
files_abstract_directory_view_real_handle_primary_button_click (FilesAbstractDirectoryView* self,
                                                                GdkEventButton* event,
                                                                GtkTreePath* path)
{
	gboolean result;
	g_return_val_if_fail (event != NULL, FALSE);
	result = TRUE;
	return result;
}

gboolean
files_abstract_directory_view_handle_primary_button_click (FilesAbstractDirectoryView* self,
                                                           GdkEventButton* event,
                                                           GtkTreePath* path)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->handle_primary_button_click) {
		return _klass_->handle_primary_button_click (self, event, path);
	}
	return FALSE;
}

static gboolean
files_abstract_directory_view_real_handle_secondary_button_click (FilesAbstractDirectoryView* self,
                                                                  GdkEventButton* event)
{
	gboolean result;
	g_return_val_if_fail (event != NULL, FALSE);
	self->should_scroll = FALSE;
	result = TRUE;
	return result;
}

gboolean
files_abstract_directory_view_handle_secondary_button_click (FilesAbstractDirectoryView* self,
                                                             GdkEventButton* event)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->handle_secondary_button_click) {
		return _klass_->handle_secondary_button_click (self, event);
	}
	return FALSE;
}

void
files_abstract_directory_view_block_drag_and_drop (FilesAbstractDirectoryView* self)
{
	g_return_if_fail (self != NULL);
	if (!self->dnd_disabled) {
		GtkWidget* _tmp0_;
		gconstpointer _tmp1_;
		GtkWidget* _tmp2_;
		void* _tmp3_;
		_tmp0_ = self->priv->view;
		_tmp1_ = g_object_get_data ((GObject*) _tmp0_, "gtk-site-data");
		self->priv->drag_data = _tmp1_;
		_tmp2_ = self->priv->view;
		_tmp3_ = self->priv->drag_data;
		g_signal_handlers_block_matched (_tmp2_, G_SIGNAL_MATCH_DATA, (guint) 0, (GQuark) 0, NULL, NULL, _tmp3_);
		self->dnd_disabled = TRUE;
	}
}

void
files_abstract_directory_view_unblock_drag_and_drop (FilesAbstractDirectoryView* self)
{
	g_return_if_fail (self != NULL);
	if (self->dnd_disabled) {
		GtkWidget* _tmp0_;
		void* _tmp1_;
		_tmp0_ = self->priv->view;
		_tmp1_ = self->priv->drag_data;
		g_signal_handlers_unblock_matched (_tmp0_, G_SIGNAL_MATCH_DATA, (guint) 0, (GQuark) 0, NULL, NULL, _tmp1_);
		self->dnd_disabled = FALSE;
	}
}

static gboolean
files_abstract_directory_view_real_on_view_button_press_event (FilesAbstractDirectoryView* self,
                                                               GdkEventButton* event)
{
	gboolean _tmp0_;
	GdkEventType type = 0;
	gboolean _tmp2_ = FALSE;
	GtkTreePath* path = NULL;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	guint button = 0U;
	guint _tmp5_ = 0U;
	GtkTreePath* _tmp6_ = NULL;
	guint _tmp7_;
	GtkTreePath* _tmp8_;
	GtkTreePath* _tmp9_;
	GdkModifierType state = 0U;
	GdkModifierType _tmp10_ = 0U;
	GdkModifierType mods = 0U;
	gboolean no_mods = FALSE;
	gboolean control_pressed = FALSE;
	gboolean shift_pressed = FALSE;
	gboolean other_mod_pressed = FALSE;
	gboolean _tmp11_ = FALSE;
	gboolean only_control_pressed = FALSE;
	gboolean _tmp12_ = FALSE;
	gboolean _tmp13_ = FALSE;
	gboolean only_shift_pressed = FALSE;
	gboolean _tmp14_ = FALSE;
	GtkTreePath* _tmp15_;
	gboolean path_selected = FALSE;
	gboolean _tmp17_ = FALSE;
	gboolean on_blank = FALSE;
	gboolean double_click_event = FALSE;
	gboolean _result_ = FALSE;
	gboolean result;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->_renaming;
	if (_tmp0_) {
		FilesTextRenderer* _tmp1_;
		_tmp1_ = self->name_renderer;
		files_text_renderer_end_editing (_tmp1_, FALSE);
	}
	files_abstract_directory_view_cancel_hover (self);
	type = gdk_event_get_event_type ((GdkEvent*) event);
	if (self->dnd_disabled) {
		_tmp2_ = type == GDK_BUTTON_PRESS;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		result = TRUE;
		return result;
	}
	files_abstract_directory_view_grab_focus (self);
	path = NULL;
	gdk_event_get_coords ((GdkEvent*) event, &_tmp3_, &_tmp4_);
	self->priv->drag_x = _tmp3_;
	self->priv->drag_y = _tmp4_;
	gdk_event_get_button ((GdkEvent*) event, &_tmp5_);
	button = _tmp5_;
	_tmp7_ = files_abstract_directory_view_get_event_position_info (self, event, &_tmp6_, button == ((guint) GDK_BUTTON_PRIMARY));
	__vala_GtkTreePath_free0 (path);
	path = _tmp6_;
	self->click_zone = _tmp7_;
	_tmp8_ = path;
	_tmp9_ = __vala_GtkTreePath_copy0 (_tmp8_);
	__vala_GtkTreePath_free0 (self->click_path);
	self->click_path = _tmp9_;
	gdk_event_get_state ((GdkEvent*) event, &_tmp10_);
	state = _tmp10_;
	mods = state & gtk_accelerator_get_default_mod_mask ();
	no_mods = mods == 0;
	control_pressed = (mods & GDK_CONTROL_MASK) != 0;
	shift_pressed = (mods & GDK_SHIFT_MASK) != 0;
	other_mod_pressed = ((mods & (~GDK_SHIFT_MASK)) & (~GDK_CONTROL_MASK)) != 0;
	if (control_pressed) {
		_tmp11_ = !other_mod_pressed;
	} else {
		_tmp11_ = FALSE;
	}
	only_control_pressed = _tmp11_;
	if (shift_pressed) {
		_tmp13_ = !control_pressed;
	} else {
		_tmp13_ = FALSE;
	}
	if (_tmp13_) {
		_tmp12_ = !other_mod_pressed;
	} else {
		_tmp12_ = FALSE;
	}
	only_shift_pressed = _tmp12_;
	_tmp15_ = path;
	if (_tmp15_ != NULL) {
		GtkTreePath* _tmp16_;
		_tmp16_ = path;
		_tmp14_ = files_abstract_directory_view_path_is_selected (self, _tmp16_);
	} else {
		_tmp14_ = FALSE;
	}
	path_selected = _tmp14_;
	if (self->click_zone == ((guint) FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_BLANK_NO_PATH)) {
		_tmp17_ = TRUE;
	} else {
		_tmp17_ = self->click_zone == ((guint) FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_BLANK_PATH);
	}
	on_blank = _tmp17_;
	double_click_event = type == GDK_2BUTTON_PRESS;
	files_abstract_directory_view_block_drag_and_drop (self);
	if (!files_abstract_directory_view_will_handle_button_press (self, no_mods, only_control_pressed, only_shift_pressed)) {
		result = FALSE;
		__vala_GtkTreePath_free0 (path);
		return result;
	}
	_result_ = FALSE;
	self->should_activate = FALSE;
	self->should_deselect = FALSE;
	self->should_select = FALSE;
	self->should_scroll = TRUE;
	switch (button) {
		case GDK_BUTTON_PRIMARY:
		{
			switch (self->click_zone) {
				case FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_BLANK_NO_PATH:
				case FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_INVALID:
				{
					if (no_mods) {
						files_abstract_directory_view_unselect_all (self);
					}
					break;
				}
				case FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_BLANK_PATH:
				case FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_ICON:
				case FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_NAME:
				{
					gboolean _tmp18_ = FALSE;
					gboolean _tmp19_ = FALSE;
					gboolean _tmp24_ = FALSE;
					if (only_control_pressed) {
						_tmp18_ = path_selected;
					} else {
						_tmp18_ = FALSE;
					}
					self->should_deselect = _tmp18_;
					if (no_mods) {
						_tmp19_ = self->one_or_less;
					} else {
						_tmp19_ = FALSE;
					}
					if (_tmp19_) {
						gboolean _tmp20_ = FALSE;
						gboolean _tmp21_ = FALSE;
						gboolean _tmp22_ = FALSE;
						if (self->on_directory) {
							_tmp22_ = !on_blank;
						} else {
							_tmp22_ = FALSE;
						}
						if (_tmp22_) {
							gboolean _tmp23_;
							_tmp23_ = self->priv->_singleclick_select;
							_tmp21_ = !_tmp23_;
						} else {
							_tmp21_ = FALSE;
						}
						if (_tmp21_) {
							_tmp20_ = TRUE;
						} else {
							_tmp20_ = double_click_event;
						}
						self->should_activate = _tmp20_;
					}
					if (!no_mods) {
						_tmp24_ = TRUE;
					} else {
						gboolean _tmp25_ = FALSE;
						if (on_blank) {
							_tmp25_ = !path_selected;
						} else {
							_tmp25_ = FALSE;
						}
						_tmp24_ = _tmp25_;
					}
					if (_tmp24_) {
						gboolean _tmp26_ = FALSE;
						if (only_shift_pressed) {
							GtkTreePath* _tmp27_;
							_tmp27_ = path;
							_tmp26_ = files_abstract_directory_view_handle_multi_select (self, _tmp27_);
						} else {
							_tmp26_ = FALSE;
						}
						_result_ = _tmp26_;
						self->should_select = TRUE;
					} else {
						gboolean _tmp28_ = FALSE;
						GtkTreePath* _tmp29_;
						GtkTreePath* _tmp30_;
						if (no_mods) {
							_tmp28_ = !path_selected;
						} else {
							_tmp28_ = FALSE;
						}
						if (_tmp28_) {
							files_abstract_directory_view_unselect_all (self);
						}
						_tmp29_ = path;
						files_abstract_directory_view_select_path (self, _tmp29_, TRUE);
						files_abstract_directory_view_unblock_drag_and_drop (self);
						_tmp30_ = path;
						_result_ = files_abstract_directory_view_handle_primary_button_click (self, event, _tmp30_);
					}
					files_abstract_directory_view_update_selected_files_and_menu (self);
					break;
				}
				case FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_HELPER:
				{
					gboolean _tmp31_ = FALSE;
					if (only_control_pressed) {
						_tmp31_ = TRUE;
					} else {
						_tmp31_ = only_shift_pressed;
					}
					if (_tmp31_) {
						gboolean _tmp32_ = FALSE;
						if (only_shift_pressed) {
							GtkTreePath* _tmp33_;
							_tmp33_ = path;
							_tmp32_ = files_abstract_directory_view_handle_multi_select (self, _tmp33_);
						} else {
							_tmp32_ = FALSE;
						}
						_result_ = _tmp32_;
					} else {
						if (path_selected) {
							self->should_deselect = TRUE;
						} else {
							GtkTreePath* _tmp34_;
							_tmp34_ = path;
							files_abstract_directory_view_select_path (self, _tmp34_, TRUE);
						}
						files_abstract_directory_view_unblock_drag_and_drop (self);
						_result_ = TRUE;
					}
					break;
				}
				case FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_EXPANDER:
				{
					GtkTreePath* _tmp35_;
					_tmp35_ = path;
					_result_ = files_abstract_directory_view_expand_collapse (self, _tmp35_);
					break;
				}
				default:
				{
					break;
				}
			}
			break;
		}
		case GDK_BUTTON_MIDDLE:
		{
			GtkTreePath* _tmp36_;
			_tmp36_ = path;
			if (!files_abstract_directory_view_path_is_selected (self, _tmp36_)) {
				GtkTreePath* _tmp37_;
				_tmp37_ = path;
				files_abstract_directory_view_select_path (self, _tmp37_, TRUE);
			}
			self->should_activate = TRUE;
			files_abstract_directory_view_unblock_drag_and_drop (self);
			_result_ = TRUE;
			break;
		}
		case GDK_BUTTON_SECONDARY:
		{
			switch (self->click_zone) {
				case FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_BLANK_NO_PATH:
				case FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_INVALID:
				{
					files_abstract_directory_view_unselect_all (self);
					break;
				}
				case FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_BLANK_PATH:
				{
					gboolean _tmp38_ = FALSE;
					if (!path_selected) {
						_tmp38_ = no_mods;
					} else {
						_tmp38_ = FALSE;
					}
					if (_tmp38_) {
						files_abstract_directory_view_unselect_all (self);
					}
					break;
				}
				case FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_NAME:
				case FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_ICON:
				case FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_HELPER:
				{
					gboolean _tmp39_ = FALSE;
					GtkTreePath* _tmp40_;
					if (!path_selected) {
						_tmp39_ = no_mods;
					} else {
						_tmp39_ = FALSE;
					}
					if (_tmp39_) {
						files_abstract_directory_view_unselect_all (self);
					}
					_tmp40_ = path;
					files_abstract_directory_view_select_path (self, _tmp40_, FALSE);
					break;
				}
				default:
				{
					break;
				}
			}
			files_abstract_directory_view_update_selected_files_and_menu (self);
			files_abstract_directory_view_unblock_drag_and_drop (self);
			files_abstract_directory_view_start_drag_timer (self, (GdkEvent*) event);
			_result_ = files_abstract_directory_view_handle_secondary_button_click (self, event);
			break;
		}
		default:
		{
			_result_ = files_abstract_directory_view_handle_default_button_click (self, event);
			break;
		}
	}
	result = _result_;
	__vala_GtkTreePath_free0 (path);
	return result;
}

gboolean
files_abstract_directory_view_on_view_button_press_event (FilesAbstractDirectoryView* self,
                                                          GdkEventButton* event)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->on_view_button_press_event) {
		return _klass_->on_view_button_press_event (self, event);
	}
	return FALSE;
}

static Block24Data*
block24_data_ref (Block24Data* _data24_)
{
	g_atomic_int_inc (&_data24_->_ref_count_);
	return _data24_;
}

static void
block24_data_unref (void * _userdata_)
{
	Block24Data* _data24_;
	_data24_ = (Block24Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data24_->_ref_count_)) {
		FilesAbstractDirectoryView* self;
		self = _data24_->self;
		_g_object_unref0 (self);
		g_slice_free (Block24Data, _data24_);
	}
}

static gboolean
____lambda122_ (Block24Data* _data24_)
{
	FilesAbstractDirectoryView* self;
	FilesOpenFlag _tmp0_ = 0;
	FilesOpenFlag flag = 0;
	GList* _tmp1_;
	gboolean result;
	self = _data24_->self;
	if (_data24_->button == ((guint) GDK_BUTTON_MIDDLE)) {
		_tmp0_ = FILES_OPEN_FLAG_NEW_TAB;
	} else {
		_tmp0_ = FILES_OPEN_FLAG_DEFAULT;
	}
	flag = _tmp0_;
	_tmp1_ = files_abstract_directory_view_get_selected_files (self);
	files_abstract_directory_view_activate_selected_items (self, flag, _tmp1_);
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
_____lambda122__gsource_func (gpointer self)
{
	gboolean result;
	result = ____lambda122_ (self);
	return result;
}

static gboolean
_____lambda123_ (FilesAbstractDirectoryView* self)
{
	gboolean result;
	files_abstract_directory_view_update_selected_files_and_menu (self);
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
______lambda123__gsource_func (gpointer self)
{
	gboolean result;
	result = _____lambda123_ ((FilesAbstractDirectoryView*) self);
	return result;
}

static gboolean
______lambda124_ (FilesAbstractDirectoryView* self)
{
	gboolean result;
	files_abstract_directory_view_update_selected_files_and_menu (self);
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
_______lambda124__gsource_func (gpointer self)
{
	gboolean result;
	result = ______lambda124_ ((FilesAbstractDirectoryView*) self);
	return result;
}

static gboolean
files_abstract_directory_view_real_on_view_button_release_event (FilesAbstractDirectoryView* self,
                                                                 GdkEventButton* event)
{
	Block24Data* _data24_;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	FilesViewSlot* _tmp2_;
	gdouble x = 0.0;
	gdouble y = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	guint _tmp5_ = 0U;
	GtkWidget* _tmp6_;
	gboolean result;
	g_return_val_if_fail (event != NULL, FALSE);
	_data24_ = g_slice_new0 (Block24Data);
	_data24_->_ref_count_ = 1;
	_data24_->self = g_object_ref (self);
	files_abstract_directory_view_unblock_drag_and_drop (self);
	_tmp1_ = self->priv->_renaming;
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = !files_abstract_directory_view_view_has_focus (self);
	}
	if (_tmp0_) {
		result = TRUE;
		block24_data_unref (_data24_);
		_data24_ = NULL;
		return result;
	}
	_tmp2_ = self->slot;
	g_signal_emit_by_name ((FilesAbstractSlot*) _tmp2_, "active", self->should_scroll, TRUE);
	gdk_event_get_coords ((GdkEvent*) event, &_tmp3_, &_tmp4_);
	x = _tmp3_;
	y = _tmp4_;
	gdk_event_get_button ((GdkEvent*) event, &_tmp5_);
	_data24_->button = _tmp5_;
	files_abstract_directory_view_update_selected_files_and_menu (self);
	_tmp6_ = gtk_bin_get_child ((GtkBin*) self);
	if (!gtk_drag_check_threshold (_tmp6_, (gint) self->priv->drag_x, (gint) self->priv->drag_y, (gint) x, (gint) y)) {
		if (self->should_activate) {
			g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _____lambda122__gsource_func, block24_data_ref (_data24_), block24_data_unref);
		} else {
			gboolean _tmp7_ = FALSE;
			if (self->should_deselect) {
				GtkTreePath* _tmp8_;
				_tmp8_ = self->click_path;
				_tmp7_ = _tmp8_ != NULL;
			} else {
				_tmp7_ = FALSE;
			}
			if (_tmp7_) {
				GtkTreePath* _tmp9_;
				_tmp9_ = self->click_path;
				files_abstract_directory_view_unselect_path (self, _tmp9_);
				g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ______lambda123__gsource_func, g_object_ref (self), g_object_unref);
			} else {
				gboolean _tmp10_ = FALSE;
				if (self->should_select) {
					GtkTreePath* _tmp11_;
					_tmp11_ = self->click_path;
					_tmp10_ = _tmp11_ != NULL;
				} else {
					_tmp10_ = FALSE;
				}
				if (_tmp10_) {
					GtkTreePath* _tmp12_;
					_tmp12_ = self->click_path;
					files_abstract_directory_view_select_path (self, _tmp12_, FALSE);
					g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _______lambda124__gsource_func, g_object_ref (self), g_object_unref);
				} else {
					if (_data24_->button == ((guint) GDK_BUTTON_SECONDARY)) {
						files_abstract_directory_view_show_context_menu (self, (GdkEvent*) event);
					}
				}
			}
		}
	}
	self->should_activate = FALSE;
	self->should_deselect = FALSE;
	self->should_select = FALSE;
	__vala_GtkTreePath_free0 (self->click_path);
	self->click_path = NULL;
	result = FALSE;
	block24_data_unref (_data24_);
	_data24_ = NULL;
	return result;
}

gboolean
files_abstract_directory_view_on_view_button_release_event (FilesAbstractDirectoryView* self,
                                                            GdkEventButton* event)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->on_view_button_release_event) {
		return _klass_->on_view_button_release_event (self, event);
	}
	return FALSE;
}

static void
files_abstract_directory_view_real_change_zoom_level (FilesAbstractDirectoryView* self)
{
	FilesIconRenderer* _tmp0_;
	FilesZoomLevel _tmp1_;
	FilesZoomLevel _tmp2_;
	FilesTextRenderer* _tmp3_;
	FilesZoomLevel _tmp4_;
	FilesZoomLevel _tmp5_;
	GtkWidget* _tmp6_;
	_tmp0_ = self->icon_renderer;
	_tmp1_ = files_abstract_directory_view_get_zoom_level (self);
	_tmp2_ = _tmp1_;
	files_icon_renderer_set_zoom_level (_tmp0_, _tmp2_);
	_tmp3_ = self->name_renderer;
	_tmp4_ = files_abstract_directory_view_get_zoom_level (self);
	_tmp5_ = _tmp4_;
	files_text_renderer_set_zoom_level (_tmp3_, _tmp5_);
	_tmp6_ = self->priv->view;
	g_signal_emit_by_name (_tmp6_, "style-updated");
}

void
files_abstract_directory_view_change_zoom_level (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->change_zoom_level) {
		_klass_->change_zoom_level (self);
	}
}

static Block25Data*
block25_data_ref (Block25Data* _data25_)
{
	g_atomic_int_inc (&_data25_->_ref_count_);
	return _data25_;
}

static void
block25_data_unref (void * _userdata_)
{
	Block25Data* _data25_;
	_data25_ = (Block25Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data25_->_ref_count_)) {
		FilesAbstractDirectoryView* self;
		self = _data25_->self;
		__vala_GtkTreePath_free0 (_data25_->start_path);
		__vala_GtkTreePath_free0 (_data25_->path);
		_g_object_unref0 (self);
		g_slice_free (Block25Data, _data25_);
	}
}

static gboolean
__lambda57_ (Block25Data* _data25_)
{
	FilesAbstractDirectoryView* self;
	GtkTreePath* start = NULL;
	GtkTreePath* end = NULL;
	GtkTreePath* _tmp0_ = NULL;
	GtkTreePath* _tmp1_ = NULL;
	guint _tmp2_;
	gboolean _tmp3_ = FALSE;
	GtkTreePath* _tmp4_;
	FilesTextRenderer* _tmp10_;
	GtkTreePath* _tmp11_;
	FilesTextRenderer* _tmp12_;
	gboolean result;
	self = _data25_->self;
	start = NULL;
	end = NULL;
	files_abstract_directory_view_get_visible_range (self, &_tmp0_, &_tmp1_);
	__vala_GtkTreePath_free0 (start);
	start = _tmp0_;
	__vala_GtkTreePath_free0 (end);
	end = _tmp1_;
	_tmp2_ = _data25_->count;
	_data25_->count = _tmp2_ + 1;
	_tmp4_ = _data25_->start_path;
	if (_tmp4_ == NULL) {
		_tmp3_ = TRUE;
	} else {
		gboolean _tmp5_ = FALSE;
		if (_data25_->count < ((guint) 20)) {
			GtkTreePath* _tmp6_;
			GtkTreePath* _tmp7_;
			_tmp6_ = start;
			_tmp7_ = _data25_->start_path;
			_tmp5_ = gtk_tree_path_compare (_tmp6_, _tmp7_) != 0;
		} else {
			_tmp5_ = FALSE;
		}
		_tmp3_ = _tmp5_;
	}
	if (_tmp3_) {
		GtkTreePath* _tmp8_;
		GtkTreePath* _tmp9_;
		_tmp8_ = start;
		_tmp9_ = __vala_GtkTreePath_copy0 (_tmp8_);
		__vala_GtkTreePath_free0 (_data25_->start_path);
		_data25_->start_path = _tmp9_;
		_data25_->ok_next_time = FALSE;
		result = G_SOURCE_CONTINUE;
		__vala_GtkTreePath_free0 (end);
		__vala_GtkTreePath_free0 (start);
		return result;
	} else {
		if (!_data25_->ok_next_time) {
			_data25_->ok_next_time = TRUE;
			result = G_SOURCE_CONTINUE;
			__vala_GtkTreePath_free0 (end);
			__vala_GtkTreePath_free0 (start);
			return result;
		}
	}
	_tmp10_ = self->name_renderer;
	g_object_set ((GtkCellRendererText*) _tmp10_, "editable", TRUE, NULL);
	_tmp11_ = _data25_->path;
	_tmp12_ = self->name_renderer;
	files_abstract_directory_view_set_cursor_on_cell (self, _tmp11_, G_TYPE_CHECK_INSTANCE_TYPE (_tmp12_, gtk_cell_renderer_get_type ()) ? ((GtkCellRenderer*) _tmp12_) : NULL, TRUE, FALSE);
	result = G_SOURCE_REMOVE;
	__vala_GtkTreePath_free0 (end);
	__vala_GtkTreePath_free0 (start);
	return result;
}

static gboolean
___lambda57__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda57_ (self);
	return result;
}

static void
files_abstract_directory_view_start_renaming_file (FilesAbstractDirectoryView* self,
                                                   FilesFile* file)
{
	Block25Data* _data25_;
	gboolean _tmp0_;
	gboolean _tmp1_;
	GtkTreeIter* iter = NULL;
	FilesListModel* _tmp2_;
	GtkTreeIter* _tmp3_ = NULL;
	gboolean _tmp4_;
	FilesListModel* _tmp5_;
	GtkTreeIter* _tmp6_;
	GtkTreeIter _tmp7_;
	GtkTreePath* _tmp8_;
	GtkTreePath* _tmp9_;
	FilesTextRenderer* _tmp10_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	_data25_ = g_slice_new0 (Block25Data);
	_data25_->_ref_count_ = 1;
	_data25_->self = g_object_ref (self);
	_tmp0_ = files_abstract_directory_view_get_is_frozen (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_) {
		g_warning ("AbstractDirectoryView.vala:3691: Trying to rename when frozen");
		block25_data_unref (_data25_);
		_data25_ = NULL;
		return;
	}
	iter = NULL;
	_tmp2_ = self->model;
	_tmp4_ = files_list_model_get_first_iter_for_file (_tmp2_, file, &_tmp3_);
	__vala_GtkTreeIter_free0 (iter);
	iter = _tmp3_;
	if (!_tmp4_) {
		g_critical ("AbstractDirectoryView.vala:3696: Failed to find rename file in model");
		__vala_GtkTreeIter_free0 (iter);
		block25_data_unref (_data25_);
		_data25_ = NULL;
		return;
	}
	files_abstract_directory_view_set_renaming (self, TRUE);
	files_abstract_directory_view_update_menu_actions (self);
	files_abstract_directory_view_set_is_frozen (self, TRUE);
	_tmp5_ = self->model;
	_tmp6_ = iter;
	_tmp7_ = *_tmp6_;
	_tmp8_ = gtk_tree_model_get_path ((GtkTreeModel*) _tmp5_, &_tmp7_);
	_data25_->path = _tmp8_;
	_data25_->count = (guint) 0;
	_data25_->ok_next_time = FALSE;
	_data25_->start_path = NULL;
	_tmp9_ = _data25_->path;
	_tmp10_ = self->name_renderer;
	files_abstract_directory_view_set_cursor_on_cell (self, _tmp9_, G_TYPE_CHECK_INSTANCE_TYPE (_tmp10_, gtk_cell_renderer_get_type ()) ? ((GtkCellRenderer*) _tmp10_) : NULL, FALSE, FALSE);
	g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 50, ___lambda57__gsource_func, block25_data_ref (_data25_), block25_data_unref);
	__vala_GtkTreeIter_free0 (iter);
	block25_data_unref (_data25_);
	_data25_ = NULL;
}

static Block26Data*
block26_data_ref (Block26Data* _data26_)
{
	g_atomic_int_inc (&_data26_->_ref_count_);
	return _data26_;
}

static void
block26_data_unref (void * _userdata_)
{
	Block26Data* _data26_;
	_data26_ = (Block26Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data26_->_ref_count_)) {
		FilesAbstractDirectoryView* self;
		self = _data26_->self;
		_g_object_unref0 (_data26_->dir);
		_g_object_unref0 (self);
		g_slice_free (Block26Data, _data26_);
	}
}

static void
___lambda118_ (Block26Data* _data26_,
               GObject* obj,
               GAsyncResult* res)
{
	FilesAbstractDirectoryView* self;
	GError* _inner_error0_ = NULL;
	self = _data26_->self;
	g_return_if_fail (res != NULL);
	{
		GFileInfo* inf = NULL;
		FilesDirectory* _tmp0_;
		GFile* _tmp1_;
		GFile* _tmp2_;
		GFileInfo* _tmp3_ = NULL;
		_tmp0_ = _data26_->dir;
		_tmp1_ = files_directory_get_location (_tmp0_);
		_tmp2_ = _tmp1_;
		g_file_set_attributes_finish (_tmp2_, res, &_tmp3_, &_inner_error0_);
		_g_object_unref0 (inf);
		inf = _tmp3_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (inf);
			goto __catch0_g_error;
		}
		_g_object_unref0 (inf);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp4_;
		const gchar* _tmp5_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		g_warning ("AbstractDirectoryView.vala:3780: Could not set file attributes: %s", _tmp5_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

static void
____lambda118__gasync_ready_callback (GObject* source_object,
                                      GAsyncResult* res,
                                      gpointer self)
{
	___lambda118_ (self, source_object, res);
	block26_data_unref (self);
}

void
files_abstract_directory_view_on_sort_column_changed (FilesAbstractDirectoryView* self)
{
	Block26Data* _data26_;
	gint sort_column_id = 0;
	GtkSortType sort_order = 0;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	GFileInfo* info = NULL;
	GFileInfo* _tmp6_;
	FilesViewSlot* _tmp7_;
	FilesDirectory* _tmp8_;
	FilesDirectory* _tmp9_;
	FilesDirectory* _tmp10_;
	const gchar* sort_col_s = NULL;
	const gchar* _tmp11_;
	const gchar* _tmp12_ = NULL;
	const gchar* sort_order_s = NULL;
	GFileInfo* _tmp13_;
	const gchar* _tmp14_;
	GFileInfo* _tmp15_;
	const gchar* _tmp16_;
	FilesDirectory* _tmp17_;
	FilesFile* _tmp18_;
	FilesFile* _tmp19_;
	GFileInfo* _tmp20_;
	const gchar* _tmp21_;
	FilesDirectory* _tmp22_;
	FilesFile* _tmp23_;
	FilesFile* _tmp24_;
	GFileInfo* _tmp25_;
	const gchar* _tmp26_;
	FilesDirectory* _tmp27_;
	FilesFile* _tmp28_;
	FilesFile* _tmp29_;
	FilesDirectory* _tmp30_;
	FilesFile* _tmp31_;
	FilesFile* _tmp32_;
	g_return_if_fail (self != NULL);
	_data26_ = g_slice_new0 (Block26Data);
	_data26_->_ref_count_ = 1;
	_data26_->self = g_object_ref (self);
	sort_column_id = 0;
	sort_order = 0;
	if (files_is_admin ()) {
		block26_data_unref (_data26_);
		_data26_ = NULL;
		return;
	}
	_tmp1_ = self->priv->_tree_frozen;
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		FilesListModel* _tmp2_;
		gint _tmp3_ = 0;
		GtkSortType _tmp4_ = 0;
		gboolean _tmp5_;
		_tmp2_ = self->model;
		_tmp5_ = gtk_tree_sortable_get_sort_column_id ((GtkTreeSortable*) _tmp2_, &_tmp3_, &_tmp4_);
		sort_column_id = _tmp3_;
		sort_order = _tmp4_;
		_tmp0_ = !_tmp5_;
	}
	if (_tmp0_) {
		block26_data_unref (_data26_);
		_data26_ = NULL;
		return;
	}
	_tmp6_ = g_file_info_new ();
	info = _tmp6_;
	_tmp7_ = self->slot;
	_tmp8_ = files_abstract_slot_get_directory ((FilesAbstractSlot*) _tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = _g_object_ref0 (_tmp9_);
	_data26_->dir = _tmp10_;
	_tmp11_ = files_list_model_column_id_to_string ((FilesListModelColumnID) sort_column_id);
	sort_col_s = _tmp11_;
	if (sort_order == GTK_SORT_DESCENDING) {
		_tmp12_ = "true";
	} else {
		_tmp12_ = "false";
	}
	sort_order_s = _tmp12_;
	_tmp13_ = info;
	_tmp14_ = sort_col_s;
	g_file_info_set_attribute_string (_tmp13_, "metadata::marlin-sort-column-id", _tmp14_);
	_tmp15_ = info;
	_tmp16_ = sort_order_s;
	g_file_info_set_attribute_string (_tmp15_, "metadata::marlin-sort-reversed", _tmp16_);
	_tmp17_ = _data26_->dir;
	_tmp18_ = files_directory_get_file (_tmp17_);
	_tmp19_ = _tmp18_;
	_tmp20_ = _tmp19_->info;
	_tmp21_ = sort_col_s;
	g_file_info_set_attribute_string (_tmp20_, "metadata::marlin-sort-column-id", _tmp21_);
	_tmp22_ = _data26_->dir;
	_tmp23_ = files_directory_get_file (_tmp22_);
	_tmp24_ = _tmp23_;
	_tmp25_ = _tmp24_->info;
	_tmp26_ = sort_order_s;
	g_file_info_set_attribute_string (_tmp25_, "metadata::marlin-sort-reversed", _tmp26_);
	_tmp27_ = _data26_->dir;
	_tmp28_ = files_directory_get_file (_tmp27_);
	_tmp29_ = _tmp28_;
	_tmp29_->sort_column_id = sort_column_id;
	_tmp30_ = _data26_->dir;
	_tmp31_ = files_directory_get_file (_tmp30_);
	_tmp32_ = _tmp31_;
	_tmp32_->sort_order = sort_order;
	if (!files_is_admin ()) {
		FilesDirectory* _tmp33_;
		GFile* _tmp34_;
		GFile* _tmp35_;
		GFileInfo* _tmp36_;
		_tmp33_ = _data26_->dir;
		_tmp34_ = files_directory_get_location (_tmp33_);
		_tmp35_ = _tmp34_;
		_tmp36_ = info;
		g_file_set_attributes_async (_tmp35_, _tmp36_, G_FILE_QUERY_INFO_NONE, G_PRIORITY_DEFAULT, NULL, ____lambda118__gasync_ready_callback, block26_data_ref (_data26_));
	}
	_g_object_unref0 (info);
	block26_data_unref (_data26_);
	_data26_ = NULL;
}

void
files_abstract_directory_view_cancel_timeout (FilesAbstractDirectoryView* self,
                                              guint* id)
{
	g_return_if_fail (self != NULL);
	if ((*id) > ((guint) 0)) {
		g_source_remove (*id);
		*id = (guint) 0;
	}
}

void
files_abstract_directory_view_update_selected_files_and_menu (FilesAbstractDirectoryView* self)
{
	gboolean _tmp6_ = FALSE;
	GList* _tmp7_;
	g_return_if_fail (self != NULL);
	if (self->priv->selected_files_invalid) {
		guint selected_count = 0U;
		GList* _tmp0_ = NULL;
		guint _tmp1_;
		FilesViewSlot* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		GList* _tmp5_;
		(self->selected_files == NULL) ? NULL : (self->selected_files = (_g_list_free__g_object_unref0_ (self->selected_files), NULL));
		self->selected_files = NULL;
		_tmp1_ = files_abstract_directory_view_get_selected_files_from_model (self, &_tmp0_);
		(self->selected_files == NULL) ? NULL : (self->selected_files = (_g_list_free__g_object_unref0_ (self->selected_files), NULL));
		self->selected_files = _tmp0_;
		selected_count = _tmp1_;
		_tmp2_ = self->slot;
		_tmp3_ = files_view_slot_get_displayed_files_count (_tmp2_);
		_tmp4_ = _tmp3_;
		self->priv->all_selected = selected_count == ((guint) _tmp4_);
		self->selected_files = g_list_reverse (self->selected_files);
		self->priv->selected_files_invalid = FALSE;
		files_abstract_directory_view_update_menu_actions (self);
		_tmp5_ = self->selected_files;
		g_signal_emit (self, files_abstract_directory_view_signals[FILES_ABSTRACT_DIRECTORY_VIEW_SELECTION_CHANGED_SIGNAL], 0, _tmp5_);
	}
	_tmp7_ = self->selected_files;
	if (_tmp7_ == NULL) {
		_tmp6_ = TRUE;
	} else {
		GList* _tmp8_;
		GList* _tmp9_;
		_tmp8_ = self->selected_files;
		_tmp9_ = _tmp8_->next;
		_tmp6_ = _tmp9_ == NULL;
	}
	self->one_or_less = _tmp6_;
}

static gboolean
files_abstract_directory_view_real_expand_collapse (FilesAbstractDirectoryView* self,
                                                    GtkTreePath* path)
{
	gboolean result;
	result = TRUE;
	return result;
}

gboolean
files_abstract_directory_view_expand_collapse (FilesAbstractDirectoryView* self,
                                               GtkTreePath* path)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->expand_collapse) {
		return _klass_->expand_collapse (self, path);
	}
	return FALSE;
}

static gboolean
files_abstract_directory_view_real_handle_default_button_click (FilesAbstractDirectoryView* self,
                                                                GdkEventButton* event)
{
	gboolean result;
	g_return_val_if_fail (event != NULL, FALSE);
	result = FALSE;
	return result;
}

gboolean
files_abstract_directory_view_handle_default_button_click (FilesAbstractDirectoryView* self,
                                                           GdkEventButton* event)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->handle_default_button_click) {
		return _klass_->handle_default_button_click (self, event);
	}
	return FALSE;
}

static gboolean
files_abstract_directory_view_real_get_next_visible_iter (FilesAbstractDirectoryView* self,
                                                          GtkTreeIter* iter,
                                                          gboolean recurse)
{
	FilesListModel* _tmp0_;
	gboolean _tmp1_;
	gboolean result;
	g_return_val_if_fail (iter != NULL, FALSE);
	_tmp0_ = self->model;
	_tmp1_ = gtk_tree_model_iter_next ((GtkTreeModel*) _tmp0_, iter);
	result = _tmp1_;
	return result;
}

gboolean
files_abstract_directory_view_get_next_visible_iter (FilesAbstractDirectoryView* self,
                                                     GtkTreeIter* iter,
                                                     gboolean recurse)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->get_next_visible_iter) {
		return _klass_->get_next_visible_iter (self, iter, recurse);
	}
	return FALSE;
}

static void
files_abstract_directory_view_real_cancel (FilesAbstractDirectoryView* self)
{
	files_abstract_directory_view_grab_focus (self);
	files_abstract_directory_view_cancel_hover (self);
	files_abstract_directory_view_cancel_thumbnailing (self);
	files_abstract_directory_view_cancel_drag_timer (self);
	files_abstract_directory_view_cancel_timeout (self, &self->priv->drag_scroll_timer_id);
	files_abstract_directory_view_cancel_timeout (self, &self->priv->add_remove_file_timeout_id);
	files_abstract_directory_view_cancel_timeout (self, &self->priv->set_cursor_timeout_id);
	files_abstract_directory_view_cancel_timeout (self, &self->priv->draw_timeout_id);
}

void
files_abstract_directory_view_cancel (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->cancel) {
		_klass_->cancel (self);
	}
}

static void
files_abstract_directory_view_cancel_hover (FilesAbstractDirectoryView* self)
{
	g_return_if_fail (self != NULL);
	__vala_GtkTreePath_free0 (self->priv->hover_path);
	self->priv->hover_path = NULL;
}

void
files_abstract_directory_view_close (FilesAbstractDirectoryView* self)
{
	g_return_if_fail (self != NULL);
	files_abstract_directory_view_set_is_frozen (self, TRUE);
	files_abstract_directory_view_cancel (self);
	files_abstract_directory_view_unselect_all (self);
}

static void
__vala_GtkTreePath_free0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (_vala_GtkTreePath_free (var), NULL));
}

static inline void
_g_list_free___vala_GtkTreePath_free0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) __vala_GtkTreePath_free0_);
}

static GtkTreeRowReference*
_vala_GtkTreeRowReference_copy (GtkTreeRowReference* self)
{
	return g_boxed_copy (gtk_tree_row_reference_get_type (), self);
}

static gpointer
__vala_GtkTreeRowReference_copy0 (gpointer self)
{
	return self ? _vala_GtkTreeRowReference_copy (self) : NULL;
}

static void
_vala_GtkTreeRowReference_free (GtkTreeRowReference* self)
{
	g_boxed_free (gtk_tree_row_reference_get_type (), self);
}

static void
__vala_GtkTreeRowReference_free0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (_vala_GtkTreeRowReference_free (var), NULL));
}

static inline void
_g_list_free___vala_GtkTreeRowReference_free0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) __vala_GtkTreeRowReference_free0_);
}

void
files_abstract_directory_view_invert_selection (FilesAbstractDirectoryView* self)
{
	GList* selected_row_refs = NULL;
	GList* _tmp0_;
	GList* _tmp5_;
	g_return_if_fail (self != NULL);
	selected_row_refs = NULL;
	_tmp0_ = files_abstract_directory_view_get_selected_paths (self);
	{
		GList* p_collection = NULL;
		GList* p_it = NULL;
		p_collection = _tmp0_;
		for (p_it = p_collection; p_it != NULL; p_it = p_it->next) {
			GtkTreePath* _tmp1_;
			GtkTreePath* p = NULL;
			_tmp1_ = __vala_GtkTreePath_copy0 ((GtkTreePath*) p_it->data);
			p = _tmp1_;
			{
				FilesListModel* _tmp2_;
				GtkTreePath* _tmp3_;
				GtkTreeRowReference* _tmp4_;
				_tmp2_ = self->model;
				_tmp3_ = p;
				_tmp4_ = gtk_tree_row_reference_new ((GtkTreeModel*) _tmp2_, _tmp3_);
				selected_row_refs = g_list_prepend (selected_row_refs, _tmp4_);
				__vala_GtkTreePath_free0 (p);
			}
		}
		(p_collection == NULL) ? NULL : (p_collection = (_g_list_free___vala_GtkTreePath_free0_ (p_collection), NULL));
	}
	files_abstract_directory_view_select_all (self);
	_tmp5_ = selected_row_refs;
	if (_tmp5_ != NULL) {
		GList* _tmp6_;
		_tmp6_ = selected_row_refs;
		{
			GList* r_collection = NULL;
			GList* r_it = NULL;
			r_collection = _tmp6_;
			for (r_it = r_collection; r_it != NULL; r_it = r_it->next) {
				GtkTreeRowReference* _tmp7_;
				GtkTreeRowReference* r = NULL;
				_tmp7_ = __vala_GtkTreeRowReference_copy0 ((GtkTreeRowReference*) r_it->data);
				r = _tmp7_;
				{
					GtkTreePath* p = NULL;
					GtkTreeRowReference* _tmp8_;
					GtkTreePath* _tmp9_;
					GtkTreePath* _tmp10_;
					_tmp8_ = r;
					_tmp9_ = gtk_tree_row_reference_get_path (_tmp8_);
					p = _tmp9_;
					_tmp10_ = p;
					if (_tmp10_ != NULL) {
						GtkTreePath* _tmp11_;
						_tmp11_ = p;
						files_abstract_directory_view_unselect_path (self, _tmp11_);
					}
					__vala_GtkTreePath_free0 (p);
					__vala_GtkTreeRowReference_free0 (r);
				}
			}
		}
	}
	(selected_row_refs == NULL) ? NULL : (selected_row_refs = (_g_list_free___vala_GtkTreeRowReference_free0_ (selected_row_refs), NULL));
}

void
files_abstract_directory_view_select_all (FilesAbstractDirectoryView* self)
{
	g_return_if_fail (self != NULL);
	files_abstract_directory_view_tree_select_all (self);
	files_abstract_directory_view_update_selected_files_and_menu (self);
}

void
files_abstract_directory_view_unselect_all (FilesAbstractDirectoryView* self)
{
	g_return_if_fail (self != NULL);
	files_abstract_directory_view_tree_unselect_all (self);
	files_abstract_directory_view_update_selected_files_and_menu (self);
}

void
files_abstract_directory_view_unselect_others (FilesAbstractDirectoryView* self)
{
	g_return_if_fail (self != NULL);
	files_abstract_directory_view_tree_unselect_others (self);
	files_abstract_directory_view_update_selected_files_and_menu (self);
}

static void
files_abstract_directory_view_real_highlight_path (FilesAbstractDirectoryView* self,
                                                   GtkTreePath* path)
{
}

void
files_abstract_directory_view_highlight_path (FilesAbstractDirectoryView* self,
                                              GtkTreePath* path)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->highlight_path) {
		_klass_->highlight_path (self, path);
	}
}

static GtkTreePath*
files_abstract_directory_view_real_up (FilesAbstractDirectoryView* self,
                                       GtkTreePath* path)
{
	GtkTreePath* _tmp0_;
	GtkTreePath* result;
	g_return_val_if_fail (path != NULL, NULL);
	gtk_tree_path_up (path);
	_tmp0_ = __vala_GtkTreePath_copy0 (path);
	result = _tmp0_;
	return result;
}

GtkTreePath*
files_abstract_directory_view_up (FilesAbstractDirectoryView* self,
                                  GtkTreePath* path)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->up) {
		return _klass_->up (self, path);
	}
	return NULL;
}

static GtkTreePath*
files_abstract_directory_view_real_down (FilesAbstractDirectoryView* self,
                                         GtkTreePath* path)
{
	GtkTreePath* _tmp0_;
	GtkTreePath* result;
	g_return_val_if_fail (path != NULL, NULL);
	gtk_tree_path_down (path);
	_tmp0_ = __vala_GtkTreePath_copy0 (path);
	result = _tmp0_;
	return result;
}

GtkTreePath*
files_abstract_directory_view_down (FilesAbstractDirectoryView* self,
                                    GtkTreePath* path)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->down) {
		return _klass_->down (self, path);
	}
	return NULL;
}

/** Abstract methods - must be overridden*/
static GList*
files_abstract_directory_view_real_get_selected_paths (FilesAbstractDirectoryView* self)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_get_selected_paths'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}

GList*
files_abstract_directory_view_get_selected_paths (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->get_selected_paths) {
		return _klass_->get_selected_paths (self);
	}
	return NULL;
}

static GtkTreePath*
files_abstract_directory_view_real_get_path_at_pos (FilesAbstractDirectoryView* self,
                                                    gint x,
                                                    gint win)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_get_path_at_pos'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}

GtkTreePath*
files_abstract_directory_view_get_path_at_pos (FilesAbstractDirectoryView* self,
                                               gint x,
                                               gint win)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->get_path_at_pos) {
		return _klass_->get_path_at_pos (self, x, win);
	}
	return NULL;
}

static GtkTreePath*
files_abstract_directory_view_real_get_path_at_cursor (FilesAbstractDirectoryView* self)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_get_path_at_cursor'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}

GtkTreePath*
files_abstract_directory_view_get_path_at_cursor (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->get_path_at_cursor) {
		return _klass_->get_path_at_cursor (self);
	}
	return NULL;
}

static void
files_abstract_directory_view_real_tree_select_all (FilesAbstractDirectoryView* self)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_tree_select_all'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_directory_view_tree_select_all (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->tree_select_all) {
		_klass_->tree_select_all (self);
	}
}

static void
files_abstract_directory_view_real_tree_unselect_all (FilesAbstractDirectoryView* self)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_tree_unselect_all'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_directory_view_tree_unselect_all (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->tree_unselect_all) {
		_klass_->tree_unselect_all (self);
	}
}

static void
files_abstract_directory_view_real_tree_unselect_others (FilesAbstractDirectoryView* self)
{
}

void
files_abstract_directory_view_tree_unselect_others (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->tree_unselect_others) {
		_klass_->tree_unselect_others (self);
	}
}

static void
files_abstract_directory_view_real_select_path (FilesAbstractDirectoryView* self,
                                                GtkTreePath* path,
                                                gboolean cursor_follows)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_select_path'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_directory_view_select_path (FilesAbstractDirectoryView* self,
                                           GtkTreePath* path,
                                           gboolean cursor_follows)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->select_path) {
		_klass_->select_path (self, path, cursor_follows);
	}
}

static void
files_abstract_directory_view_real_unselect_path (FilesAbstractDirectoryView* self,
                                                  GtkTreePath* path)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_unselect_path'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_directory_view_unselect_path (FilesAbstractDirectoryView* self,
                                             GtkTreePath* path)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->unselect_path) {
		_klass_->unselect_path (self, path);
	}
}

static gboolean
files_abstract_directory_view_real_path_is_selected (FilesAbstractDirectoryView* self,
                                                     GtkTreePath* path)
{
	gboolean _tmp0_ = FALSE;
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_path_is_selected'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return _tmp0_;
}

gboolean
files_abstract_directory_view_path_is_selected (FilesAbstractDirectoryView* self,
                                                GtkTreePath* path)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->path_is_selected) {
		return _klass_->path_is_selected (self, path);
	}
	return FALSE;
}

static gboolean
files_abstract_directory_view_real_get_visible_range (FilesAbstractDirectoryView* self,
                                                      GtkTreePath** start_path,
                                                      GtkTreePath** end_path)
{
	gboolean _tmp0_ = FALSE;
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_get_visible_range'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return _tmp0_;
}

gboolean
files_abstract_directory_view_get_visible_range (FilesAbstractDirectoryView* self,
                                                 GtkTreePath** start_path,
                                                 GtkTreePath** end_path)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->get_visible_range) {
		return _klass_->get_visible_range (self, start_path, end_path);
	}
	return FALSE;
}

static void
files_abstract_directory_view_real_set_cursor (FilesAbstractDirectoryView* self,
                                               GtkTreePath* path,
                                               gboolean start_editing,
                                               gboolean select,
                                               gboolean scroll_to_top)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_set_cursor'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_directory_view_set_cursor (FilesAbstractDirectoryView* self,
                                          GtkTreePath* path,
                                          gboolean start_editing,
                                          gboolean select,
                                          gboolean scroll_to_top)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->set_cursor) {
		_klass_->set_cursor (self, path, start_editing, select, scroll_to_top);
	}
}

static gboolean
files_abstract_directory_view_real_move_cursor (FilesAbstractDirectoryView* self,
                                                guint keyval,
                                                gboolean only_shift_pressed,
                                                gboolean control_pressed)
{
	gboolean result;
	result = FALSE;
	return result;
}

gboolean
files_abstract_directory_view_move_cursor (FilesAbstractDirectoryView* self,
                                           guint keyval,
                                           gboolean only_shift_pressed,
                                           gboolean control_pressed)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->move_cursor) {
		return _klass_->move_cursor (self, keyval, only_shift_pressed, control_pressed);
	}
	return FALSE;
}

static gboolean
files_abstract_directory_view_real_will_handle_button_press (FilesAbstractDirectoryView* self,
                                                             gboolean no_mods,
                                                             gboolean only_control_pressed,
                                                             gboolean only_shift_pressed)
{
	gboolean _tmp0_ = FALSE;
	gboolean result;
	if (!no_mods) {
		_tmp0_ = !only_control_pressed;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		result = FALSE;
		return result;
	} else {
		result = TRUE;
		return result;
	}
}

gboolean
files_abstract_directory_view_will_handle_button_press (FilesAbstractDirectoryView* self,
                                                        gboolean no_mods,
                                                        gboolean only_control_pressed,
                                                        gboolean only_shift_pressed)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->will_handle_button_press) {
		return _klass_->will_handle_button_press (self, no_mods, only_control_pressed, only_shift_pressed);
	}
	return FALSE;
}

gboolean
files_abstract_directory_view_is_on_icon (FilesAbstractDirectoryView* self,
                                          gint x,
                                          gint y,
                                          gboolean* on_helper)
{
	GdkRectangle pointer_rect = {0};
	GdkRectangle _tmp0_ = {0};
	gboolean on_icon = FALSE;
	FilesIconRenderer* _tmp1_;
	GdkRectangle _tmp2_;
	FilesIconRenderer* _tmp3_;
	GdkRectangle _tmp4_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_.x = x - 2;
	_tmp0_.y = y - 2;
	_tmp0_.width = 4;
	_tmp0_.height = 4;
	pointer_rect = _tmp0_;
	_tmp1_ = self->icon_renderer;
	_tmp2_ = _tmp1_->hover_rect;
	on_icon = gdk_rectangle_intersect (&pointer_rect, &_tmp2_, NULL);
	_tmp3_ = self->icon_renderer;
	_tmp4_ = _tmp3_->hover_helper_rect;
	*on_helper = gdk_rectangle_intersect (&pointer_rect, &_tmp4_, NULL);
	result = on_icon;
	return result;
}

static gboolean
files_abstract_directory_view_real_handle_multi_select (FilesAbstractDirectoryView* self,
                                                        GtkTreePath* path)
{
	gboolean result;
	g_return_val_if_fail (path != NULL, FALSE);
	result = FALSE;
	return result;
}

gboolean
files_abstract_directory_view_handle_multi_select (FilesAbstractDirectoryView* self,
                                                   GtkTreePath* path)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->handle_multi_select) {
		return _klass_->handle_multi_select (self, path);
	}
	return FALSE;
}

static GtkWidget*
files_abstract_directory_view_real_create_view (FilesAbstractDirectoryView* self)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_create_view'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}

GtkWidget*
files_abstract_directory_view_create_view (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->create_view) {
		return _klass_->create_view (self);
	}
	return NULL;
}

static void
files_abstract_directory_view_real_set_up_zoom_level (FilesAbstractDirectoryView* self)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_set_up_zoom_level'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_directory_view_set_up_zoom_level (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->set_up_zoom_level) {
		_klass_->set_up_zoom_level (self);
	}
}

static FilesZoomLevel
files_abstract_directory_view_real_get_normal_zoom_level (FilesAbstractDirectoryView* self)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_get_normal_zoom_level'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return 0;
}

FilesZoomLevel
files_abstract_directory_view_get_normal_zoom_level (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, 0);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->get_normal_zoom_level) {
		return _klass_->get_normal_zoom_level (self);
	}
	return 0;
}

static gboolean
files_abstract_directory_view_real_view_has_focus (FilesAbstractDirectoryView* self)
{
	gboolean _tmp0_ = FALSE;
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_view_has_focus'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return _tmp0_;
}

gboolean
files_abstract_directory_view_view_has_focus (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, FALSE);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->view_has_focus) {
		return _klass_->view_has_focus (self);
	}
	return FALSE;
}

static guint
files_abstract_directory_view_real_get_selected_files_from_model (FilesAbstractDirectoryView* self,
                                                                  GList** selected_files)
{
	guint _tmp0_ = 0U;
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_get_selected_files_from_model'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return _tmp0_;
}

guint
files_abstract_directory_view_get_selected_files_from_model (FilesAbstractDirectoryView* self,
                                                             GList** selected_files)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, 0U);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->get_selected_files_from_model) {
		return _klass_->get_selected_files_from_model (self, selected_files);
	}
	return 0U;
}

static guint
files_abstract_directory_view_real_get_event_position_info (FilesAbstractDirectoryView* self,
                                                            GdkEventButton* event,
                                                            GtkTreePath** path,
                                                            gboolean rubberband)
{
	guint _tmp0_ = 0U;
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_get_event_position_info'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return _tmp0_;
}

guint
files_abstract_directory_view_get_event_position_info (FilesAbstractDirectoryView* self,
                                                       GdkEventButton* event,
                                                       GtkTreePath** path,
                                                       gboolean rubberband)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_val_if_fail (self != NULL, 0U);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->get_event_position_info) {
		return _klass_->get_event_position_info (self, event, path, rubberband);
	}
	return 0U;
}

static void
files_abstract_directory_view_real_scroll_to_cell (FilesAbstractDirectoryView* self,
                                                   GtkTreePath* path,
                                                   gboolean scroll_to_top)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_scroll_to_cell'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_directory_view_scroll_to_cell (FilesAbstractDirectoryView* self,
                                              GtkTreePath* path,
                                              gboolean scroll_to_top)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->scroll_to_cell) {
		_klass_->scroll_to_cell (self, path, scroll_to_top);
	}
}

static void
files_abstract_directory_view_real_set_cursor_on_cell (FilesAbstractDirectoryView* self,
                                                       GtkTreePath* path,
                                                       GtkCellRenderer* renderer,
                                                       gboolean start_editing,
                                                       gboolean scroll_to_top)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_set_cursor_on_cell'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_directory_view_set_cursor_on_cell (FilesAbstractDirectoryView* self,
                                                  GtkTreePath* path,
                                                  GtkCellRenderer* renderer,
                                                  gboolean start_editing,
                                                  gboolean scroll_to_top)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->set_cursor_on_cell) {
		_klass_->set_cursor_on_cell (self, path, renderer, start_editing, scroll_to_top);
	}
}

static void
files_abstract_directory_view_real_freeze_tree (FilesAbstractDirectoryView* self)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_freeze_tree'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_directory_view_freeze_tree (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->freeze_tree) {
		_klass_->freeze_tree (self);
	}
}

static void
files_abstract_directory_view_real_thaw_tree (FilesAbstractDirectoryView* self)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_thaw_tree'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_directory_view_thaw_tree (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->thaw_tree) {
		_klass_->thaw_tree (self);
	}
}

static void
files_abstract_directory_view_real_freeze_child_notify (FilesAbstractDirectoryView* self)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_freeze_child_notify'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_directory_view_freeze_child_notify (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->freeze_child_notify) {
		_klass_->freeze_child_notify (self);
	}
}

static void
files_abstract_directory_view_real_thaw_child_notify (FilesAbstractDirectoryView* self)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_thaw_child_notify'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_directory_view_thaw_child_notify (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->thaw_child_notify) {
		_klass_->thaw_child_notify (self);
	}
}

static void
files_abstract_directory_view_real_connect_tree_signals (FilesAbstractDirectoryView* self)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_connect_tree_signals'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_directory_view_connect_tree_signals (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->connect_tree_signals) {
		_klass_->connect_tree_signals (self);
	}
}

static void
files_abstract_directory_view_real_disconnect_tree_signals (FilesAbstractDirectoryView* self)
{
	g_critical ("Type `%s' does not implement abstract method `files_abstract_directory_view_disconnect_tree_signals'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
files_abstract_directory_view_disconnect_tree_signals (FilesAbstractDirectoryView* self)
{
	FilesAbstractDirectoryViewClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = FILES_ABSTRACT_DIRECTORY_VIEW_GET_CLASS (self);
	if (_klass_->disconnect_tree_signals) {
		_klass_->disconnect_tree_signals (self);
	}
}

FilesZoomLevel
files_abstract_directory_view_get_zoom_level (FilesAbstractDirectoryView* self)
{
	FilesZoomLevel result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_zoom_level;
	return result;
}

void
files_abstract_directory_view_set_zoom_level (FilesAbstractDirectoryView* self,
                                              FilesZoomLevel value)
{
	g_return_if_fail (self != NULL);
	if (value > self->maximum_zoom) {
		self->priv->_zoom_level = self->maximum_zoom;
	} else {
		if (value < self->minimum_zoom) {
			self->priv->_zoom_level = self->minimum_zoom;
		} else {
			self->priv->_zoom_level = value;
		}
	}
	files_abstract_directory_view_on_zoom_level_changed (self, value);
	g_object_notify_by_pspec ((GObject *) self, files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_ZOOM_LEVEL_PROPERTY]);
}

gint
files_abstract_directory_view_get_icon_size (FilesAbstractDirectoryView* self)
{
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = (gint) files_zoom_level_to_icon_size (self->priv->_zoom_level);
	return result;
}

static gboolean
files_abstract_directory_view_get_drop_highlight (FilesAbstractDirectoryView* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_drop_highlight;
	return result;
}

static void
files_abstract_directory_view_set_drop_highlight (FilesAbstractDirectoryView* self,
                                                  gboolean value)
{
	g_return_if_fail (self != NULL);
	if (value != self->priv->_drop_highlight) {
		if (value) {
			gtk_drag_highlight ((GtkWidget*) self);
		} else {
			gtk_drag_unhighlight ((GtkWidget*) self);
		}
	}
	self->priv->_drop_highlight = value;
}

gboolean
files_abstract_directory_view_get_singleclick_select (FilesAbstractDirectoryView* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_singleclick_select;
	return result;
}

void
files_abstract_directory_view_set_singleclick_select (FilesAbstractDirectoryView* self,
                                                      gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = files_abstract_directory_view_get_singleclick_select (self);
	if (old_value != value) {
		self->priv->_singleclick_select = value;
		g_object_notify_by_pspec ((GObject *) self, files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_SINGLECLICK_SELECT_PROPERTY]);
	}
}

gboolean
files_abstract_directory_view_get_renaming (FilesAbstractDirectoryView* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_renaming;
	return result;
}

void
files_abstract_directory_view_set_renaming (FilesAbstractDirectoryView* self,
                                            gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = files_abstract_directory_view_get_renaming (self);
	if (old_value != value) {
		self->priv->_renaming = value;
		g_object_notify_by_pspec ((GObject *) self, files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_RENAMING_PROPERTY]);
	}
}

gboolean
files_abstract_directory_view_get_is_frozen (FilesAbstractDirectoryView* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_frozen;
	return result;
}

void
files_abstract_directory_view_set_is_frozen (FilesAbstractDirectoryView* self,
                                             gboolean value)
{
	gboolean _tmp0_;
	gboolean _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = files_abstract_directory_view_get_is_frozen (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_ != value) {
		self->priv->_is_frozen = value;
		if (value) {
			GSimpleActionGroup* _tmp2_;
			GSimpleActionGroup* _tmp3_;
			GSimpleActionGroup* _tmp4_;
			GSimpleActionGroup* _tmp5_;
			FilesClipboardManager* _tmp6_;
			guint _tmp7_;
			GtkWidget* _tmp8_;
			guint _tmp9_;
			_tmp2_ = self->priv->selection_actions;
			files_abstract_directory_view_action_set_enabled (self, _tmp2_, "cut", FALSE);
			_tmp3_ = self->priv->common_actions;
			files_abstract_directory_view_action_set_enabled (self, _tmp3_, "copy", FALSE);
			_tmp4_ = self->priv->common_actions;
			files_abstract_directory_view_action_set_enabled (self, _tmp4_, "paste-into", FALSE);
			_tmp5_ = self->priv->common_actions;
			files_abstract_directory_view_action_set_enabled (self, _tmp5_, "paste", FALSE);
			files_abstract_directory_view_disconnect_tree_signals (self);
			_tmp6_ = self->priv->clipboard;
			g_signal_parse_name ("changed", FILES_TYPE_CLIPBOARD_MANAGER, &_tmp7_, NULL, FALSE);
			g_signal_handlers_disconnect_matched (_tmp6_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp7_, 0, NULL, (GCallback) _files_abstract_directory_view_on_clipboard_changed_files_clipboard_manager_changed, self);
			_tmp8_ = self->priv->view;
			g_signal_parse_name ("key-press-event", gtk_widget_get_type (), &_tmp9_, NULL, FALSE);
			g_signal_handlers_disconnect_matched (_tmp8_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp9_, 0, NULL, (GCallback) _files_abstract_directory_view_on_view_key_press_event_gtk_widget_key_press_event, self);
		} else {
			GtkWidget* _tmp10_;
			FilesClipboardManager* _tmp11_;
			_tmp10_ = self->priv->view;
			g_signal_connect_object (_tmp10_, "key-press-event", (GCallback) _files_abstract_directory_view_on_view_key_press_event_gtk_widget_key_press_event, self, 0);
			_tmp11_ = self->priv->clipboard;
			g_signal_connect_object (_tmp11_, "changed", (GCallback) _files_abstract_directory_view_on_clipboard_changed_files_clipboard_manager_changed, self, 0);
			files_abstract_directory_view_connect_tree_signals (self);
			files_abstract_directory_view_update_menu_actions (self);
		}
	}
	g_object_notify_by_pspec ((GObject *) self, files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_IS_FROZEN_PROPERTY]);
}

gboolean
files_abstract_directory_view_get_in_recent (FilesAbstractDirectoryView* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_in_recent;
	return result;
}

static void
files_abstract_directory_view_set_in_recent (FilesAbstractDirectoryView* self,
                                             gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = files_abstract_directory_view_get_in_recent (self);
	if (old_value != value) {
		self->priv->_in_recent = value;
		g_object_notify_by_pspec ((GObject *) self, files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_IN_RECENT_PROPERTY]);
	}
}

gboolean
files_abstract_directory_view_get_tree_frozen (FilesAbstractDirectoryView* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_tree_frozen;
	return result;
}

void
files_abstract_directory_view_set_tree_frozen (FilesAbstractDirectoryView* self,
                                               gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = files_abstract_directory_view_get_tree_frozen (self);
	if (old_value != value) {
		self->priv->_tree_frozen = value;
		g_object_notify_by_pspec ((GObject *) self, files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_TREE_FROZEN_PROPERTY]);
	}
}

gboolean
files_abstract_directory_view_get_show_remote_thumbnails (FilesAbstractDirectoryView* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_show_remote_thumbnails;
	return result;
}

void
files_abstract_directory_view_set_show_remote_thumbnails (FilesAbstractDirectoryView* self,
                                                          gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = files_abstract_directory_view_get_show_remote_thumbnails (self);
	if (old_value != value) {
		self->priv->_show_remote_thumbnails = value;
		g_object_notify_by_pspec ((GObject *) self, files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_SHOW_REMOTE_THUMBNAILS_PROPERTY]);
	}
}

gboolean
files_abstract_directory_view_get_show_local_thumbnails (FilesAbstractDirectoryView* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_show_local_thumbnails;
	return result;
}

void
files_abstract_directory_view_set_show_local_thumbnails (FilesAbstractDirectoryView* self,
                                                         gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = files_abstract_directory_view_get_show_local_thumbnails (self);
	if (old_value != value) {
		self->priv->_show_local_thumbnails = value;
		g_object_notify_by_pspec ((GObject *) self, files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_SHOW_LOCAL_THUMBNAILS_PROPERTY]);
	}
}

static void
g_cclosure_user_marshal_VOID__OBJECT_ENUM_BOOLEAN (GClosure * closure,
                                                   GValue * return_value,
                                                   guint n_param_values,
                                                   const GValue * param_values,
                                                   gpointer invocation_hint,
                                                   gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__OBJECT_ENUM_BOOLEAN) (gpointer data1, gpointer arg_1, gint arg_2, gboolean arg_3, gpointer data2);
	register GMarshalFunc_VOID__OBJECT_ENUM_BOOLEAN callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__OBJECT_ENUM_BOOLEAN) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_object (param_values + 1), g_value_get_enum (param_values + 2), g_value_get_boolean (param_values + 3), data2);
}

static FilesAbstractDirectoryViewSortSubMenuItem*
files_abstract_directory_view_sort_sub_menu_item_construct (GType object_type)
{
	FilesAbstractDirectoryViewSortSubMenuItem * self = NULL;
	self = (FilesAbstractDirectoryViewSortSubMenuItem*) g_object_new (object_type, NULL);
	return self;
}

static FilesAbstractDirectoryViewSortSubMenuItem*
files_abstract_directory_view_sort_sub_menu_item_new (void)
{
	return files_abstract_directory_view_sort_sub_menu_item_construct (FILES_ABSTRACT_DIRECTORY_VIEW_TYPE_SORT_SUB_MENU_ITEM);
}

static GVariant*
_variant_new9 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}

static GVariant*
_variant_new10 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}

static GVariant*
_variant_new11 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}

static GVariant*
_variant_new12 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}

static GObject *
files_abstract_directory_view_sort_sub_menu_item_constructor (GType type,
                                                              guint n_construct_properties,
                                                              GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	FilesAbstractDirectoryViewSortSubMenuItem * self;
	GtkCheckMenuItem* name_radioitem = NULL;
	GtkCheckMenuItem* _tmp0_;
	GtkCheckMenuItem* _tmp1_;
	GtkCheckMenuItem* _tmp2_;
	GVariant* _tmp3_;
	GtkCheckMenuItem* _tmp4_;
	GtkCheckMenuItem* size_radioitem = NULL;
	GtkCheckMenuItem* _tmp5_;
	GtkCheckMenuItem* _tmp6_;
	GtkCheckMenuItem* _tmp7_;
	GVariant* _tmp8_;
	GtkCheckMenuItem* _tmp9_;
	GtkCheckMenuItem* type_radioitem = NULL;
	GtkCheckMenuItem* _tmp10_;
	GtkCheckMenuItem* _tmp11_;
	GtkCheckMenuItem* _tmp12_;
	GVariant* _tmp13_;
	GtkCheckMenuItem* _tmp14_;
	GtkCheckMenuItem* date_radioitem = NULL;
	GtkCheckMenuItem* _tmp15_;
	GtkCheckMenuItem* _tmp16_;
	GtkCheckMenuItem* _tmp17_;
	GVariant* _tmp18_;
	GtkCheckMenuItem* _tmp19_;
	GtkCheckMenuItem* reversed_checkitem = NULL;
	GtkCheckMenuItem* _tmp20_;
	GtkCheckMenuItem* _tmp21_;
	GtkCheckMenuItem* folders_first_checkitem = NULL;
	GtkCheckMenuItem* _tmp22_;
	GtkCheckMenuItem* _tmp23_;
	GtkMenu* _tmp24_;
	GtkMenu* _tmp25_;
	GtkMenu* _tmp26_;
	GtkMenu* _tmp27_;
	GtkCheckMenuItem* _tmp28_;
	GtkMenu* _tmp29_;
	GtkMenu* _tmp30_;
	GtkCheckMenuItem* _tmp31_;
	GtkMenu* _tmp32_;
	GtkMenu* _tmp33_;
	GtkCheckMenuItem* _tmp34_;
	GtkMenu* _tmp35_;
	GtkMenu* _tmp36_;
	GtkCheckMenuItem* _tmp37_;
	GtkMenu* _tmp38_;
	GtkMenu* _tmp39_;
	GtkSeparatorMenuItem* _tmp40_;
	GtkSeparatorMenuItem* _tmp41_;
	GtkMenu* _tmp42_;
	GtkMenu* _tmp43_;
	GtkCheckMenuItem* _tmp44_;
	GtkMenu* _tmp45_;
	GtkMenu* _tmp46_;
	GtkCheckMenuItem* _tmp47_;
	parent_class = G_OBJECT_CLASS (files_abstract_directory_view_sort_sub_menu_item_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_ABSTRACT_DIRECTORY_VIEW_TYPE_SORT_SUB_MENU_ITEM, FilesAbstractDirectoryViewSortSubMenuItem);
	_tmp0_ = (GtkCheckMenuItem*) gtk_check_menu_item_new_with_label (_ ("Name"));
	g_object_ref_sink (_tmp0_);
	name_radioitem = _tmp0_;
	_tmp1_ = name_radioitem;
	gtk_actionable_set_action_name ((GtkActionable*) _tmp1_, "background.sort-by");
	_tmp2_ = name_radioitem;
	_tmp3_ = _variant_new9 ("name");
	g_object_set ((GtkActionable*) _tmp2_, "action-target", _tmp3_, NULL);
	_g_variant_unref0 (_tmp3_);
	_tmp4_ = name_radioitem;
	gtk_check_menu_item_set_draw_as_radio (_tmp4_, TRUE);
	_tmp5_ = (GtkCheckMenuItem*) gtk_check_menu_item_new_with_label (_ ("Size"));
	g_object_ref_sink (_tmp5_);
	size_radioitem = _tmp5_;
	_tmp6_ = size_radioitem;
	gtk_actionable_set_action_name ((GtkActionable*) _tmp6_, "background.sort-by");
	_tmp7_ = size_radioitem;
	_tmp8_ = _variant_new10 ("size");
	g_object_set ((GtkActionable*) _tmp7_, "action-target", _tmp8_, NULL);
	_g_variant_unref0 (_tmp8_);
	_tmp9_ = size_radioitem;
	gtk_check_menu_item_set_draw_as_radio (_tmp9_, TRUE);
	_tmp10_ = (GtkCheckMenuItem*) gtk_check_menu_item_new_with_label (_ ("Type"));
	g_object_ref_sink (_tmp10_);
	type_radioitem = _tmp10_;
	_tmp11_ = type_radioitem;
	gtk_actionable_set_action_name ((GtkActionable*) _tmp11_, "background.sort-by");
	_tmp12_ = type_radioitem;
	_tmp13_ = _variant_new11 ("type");
	g_object_set ((GtkActionable*) _tmp12_, "action-target", _tmp13_, NULL);
	_g_variant_unref0 (_tmp13_);
	_tmp14_ = type_radioitem;
	gtk_check_menu_item_set_draw_as_radio (_tmp14_, TRUE);
	_tmp15_ = (GtkCheckMenuItem*) gtk_check_menu_item_new_with_label (_ ("Date"));
	g_object_ref_sink (_tmp15_);
	date_radioitem = _tmp15_;
	_tmp16_ = date_radioitem;
	gtk_actionable_set_action_name ((GtkActionable*) _tmp16_, "background.sort-by");
	_tmp17_ = date_radioitem;
	_tmp18_ = _variant_new12 ("modified");
	g_object_set ((GtkActionable*) _tmp17_, "action-target", _tmp18_, NULL);
	_g_variant_unref0 (_tmp18_);
	_tmp19_ = date_radioitem;
	gtk_check_menu_item_set_draw_as_radio (_tmp19_, TRUE);
	_tmp20_ = (GtkCheckMenuItem*) gtk_check_menu_item_new_with_label (_ ("Reversed Order"));
	g_object_ref_sink (_tmp20_);
	reversed_checkitem = _tmp20_;
	_tmp21_ = reversed_checkitem;
	gtk_actionable_set_action_name ((GtkActionable*) _tmp21_, "background.reverse");
	_tmp22_ = (GtkCheckMenuItem*) gtk_check_menu_item_new_with_label (_ ("Folders Before Files"));
	g_object_ref_sink (_tmp22_);
	folders_first_checkitem = _tmp22_;
	_tmp23_ = folders_first_checkitem;
	gtk_actionable_set_action_name ((GtkActionable*) _tmp23_, "background.folders-first");
	_tmp24_ = (GtkMenu*) gtk_menu_new ();
	g_object_ref_sink (_tmp24_);
	_tmp25_ = _tmp24_;
	gtk_menu_item_set_submenu ((GtkMenuItem*) self, _tmp25_);
	_g_object_unref0 (_tmp25_);
	_tmp26_ = gtk_menu_item_get_submenu ((GtkMenuItem*) self);
	_tmp27_ = _tmp26_;
	_tmp28_ = name_radioitem;
	gtk_container_add ((GtkContainer*) _tmp27_, (GtkWidget*) _tmp28_);
	_tmp29_ = gtk_menu_item_get_submenu ((GtkMenuItem*) self);
	_tmp30_ = _tmp29_;
	_tmp31_ = size_radioitem;
	gtk_container_add ((GtkContainer*) _tmp30_, (GtkWidget*) _tmp31_);
	_tmp32_ = gtk_menu_item_get_submenu ((GtkMenuItem*) self);
	_tmp33_ = _tmp32_;
	_tmp34_ = type_radioitem;
	gtk_container_add ((GtkContainer*) _tmp33_, (GtkWidget*) _tmp34_);
	_tmp35_ = gtk_menu_item_get_submenu ((GtkMenuItem*) self);
	_tmp36_ = _tmp35_;
	_tmp37_ = date_radioitem;
	gtk_container_add ((GtkContainer*) _tmp36_, (GtkWidget*) _tmp37_);
	_tmp38_ = gtk_menu_item_get_submenu ((GtkMenuItem*) self);
	_tmp39_ = _tmp38_;
	_tmp40_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	g_object_ref_sink (_tmp40_);
	_tmp41_ = _tmp40_;
	gtk_container_add ((GtkContainer*) _tmp39_, (GtkWidget*) _tmp41_);
	_g_object_unref0 (_tmp41_);
	_tmp42_ = gtk_menu_item_get_submenu ((GtkMenuItem*) self);
	_tmp43_ = _tmp42_;
	_tmp44_ = reversed_checkitem;
	gtk_container_add ((GtkContainer*) _tmp43_, (GtkWidget*) _tmp44_);
	_tmp45_ = gtk_menu_item_get_submenu ((GtkMenuItem*) self);
	_tmp46_ = _tmp45_;
	_tmp47_ = folders_first_checkitem;
	gtk_container_add ((GtkContainer*) _tmp46_, (GtkWidget*) _tmp47_);
	gtk_menu_item_set_label ((GtkMenuItem*) self, _ ("Sort by"));
	_g_object_unref0 (folders_first_checkitem);
	_g_object_unref0 (reversed_checkitem);
	_g_object_unref0 (date_radioitem);
	_g_object_unref0 (type_radioitem);
	_g_object_unref0 (size_radioitem);
	_g_object_unref0 (name_radioitem);
	return obj;
}

static void
files_abstract_directory_view_sort_sub_menu_item_class_init (FilesAbstractDirectoryViewSortSubMenuItemClass * klass,
                                                             gpointer klass_data)
{
	files_abstract_directory_view_sort_sub_menu_item_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->constructor = files_abstract_directory_view_sort_sub_menu_item_constructor;
}

static void
files_abstract_directory_view_sort_sub_menu_item_instance_init (FilesAbstractDirectoryViewSortSubMenuItem * self,
                                                                gpointer klass)
{
}

static GType
files_abstract_directory_view_sort_sub_menu_item_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FilesAbstractDirectoryViewSortSubMenuItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) files_abstract_directory_view_sort_sub_menu_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FilesAbstractDirectoryViewSortSubMenuItem), 0, (GInstanceInitFunc) files_abstract_directory_view_sort_sub_menu_item_instance_init, NULL };
	GType files_abstract_directory_view_sort_sub_menu_item_type_id;
	files_abstract_directory_view_sort_sub_menu_item_type_id = g_type_register_static (gtk_menu_item_get_type (), "FilesAbstractDirectoryViewSortSubMenuItem", &g_define_type_info, 0);
	return files_abstract_directory_view_sort_sub_menu_item_type_id;
}

static GType
files_abstract_directory_view_sort_sub_menu_item_get_type (void)
{
	static volatile gsize files_abstract_directory_view_sort_sub_menu_item_type_id__once = 0;
	if (g_once_init_enter (&files_abstract_directory_view_sort_sub_menu_item_type_id__once)) {
		GType files_abstract_directory_view_sort_sub_menu_item_type_id;
		files_abstract_directory_view_sort_sub_menu_item_type_id = files_abstract_directory_view_sort_sub_menu_item_get_type_once ();
		g_once_init_leave (&files_abstract_directory_view_sort_sub_menu_item_type_id__once, files_abstract_directory_view_sort_sub_menu_item_type_id);
	}
	return files_abstract_directory_view_sort_sub_menu_item_type_id__once;
}

static FilesAbstractDirectoryViewNewSubMenuItem*
files_abstract_directory_view_new_sub_menu_item_construct (GType object_type)
{
	FilesAbstractDirectoryViewNewSubMenuItem * self = NULL;
	self = (FilesAbstractDirectoryViewNewSubMenuItem*) g_object_new (object_type, NULL);
	return self;
}

static FilesAbstractDirectoryViewNewSubMenuItem*
files_abstract_directory_view_new_sub_menu_item_new (void)
{
	return files_abstract_directory_view_new_sub_menu_item_construct (FILES_ABSTRACT_DIRECTORY_VIEW_TYPE_NEW_SUB_MENU_ITEM);
}

static GVariant*
_variant_new13 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}

static GVariant*
_variant_new14 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}

static GObject *
files_abstract_directory_view_new_sub_menu_item_constructor (GType type,
                                                             guint n_construct_properties,
                                                             GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	FilesAbstractDirectoryViewNewSubMenuItem * self;
	GtkMenuItem* folder_menuitem = NULL;
	GtkMenuItem* _tmp0_;
	GtkMenuItem* _tmp1_;
	GraniteAccelLabel* _tmp2_;
	GraniteAccelLabel* _tmp3_;
	GtkMenuItem* _tmp4_;
	GtkMenuItem* _tmp5_;
	GVariant* _tmp6_;
	GtkMenuItem* file_menuitem = NULL;
	GtkMenuItem* _tmp7_;
	GtkMenuItem* _tmp8_;
	GtkMenuItem* _tmp9_;
	GVariant* _tmp10_;
	GtkMenu* _tmp11_;
	GtkMenu* _tmp12_;
	GtkMenu* _tmp13_;
	GtkMenu* _tmp14_;
	GtkMenuItem* _tmp15_;
	GtkMenu* _tmp16_;
	GtkMenu* _tmp17_;
	GtkMenuItem* _tmp18_;
	const gchar* template_path = NULL;
	const gchar* _tmp19_;
	const gchar* _tmp20_;
	parent_class = G_OBJECT_CLASS (files_abstract_directory_view_new_sub_menu_item_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_ABSTRACT_DIRECTORY_VIEW_TYPE_NEW_SUB_MENU_ITEM, FilesAbstractDirectoryViewNewSubMenuItem);
	_tmp0_ = (GtkMenuItem*) gtk_menu_item_new ();
	g_object_ref_sink (_tmp0_);
	folder_menuitem = _tmp0_;
	_tmp1_ = folder_menuitem;
	_tmp2_ = granite_accel_label_new (_ ("Folder"), "<Ctrl><Shift>n");
	g_object_ref_sink (_tmp2_);
	_tmp3_ = _tmp2_;
	gtk_container_add ((GtkContainer*) _tmp1_, (GtkWidget*) _tmp3_);
	_g_object_unref0 (_tmp3_);
	_tmp4_ = folder_menuitem;
	gtk_actionable_set_action_name ((GtkActionable*) _tmp4_, "background.new");
	_tmp5_ = folder_menuitem;
	_tmp6_ = _variant_new13 ("FOLDER");
	g_object_set ((GtkActionable*) _tmp5_, "action-target", _tmp6_, NULL);
	_g_variant_unref0 (_tmp6_);
	_tmp7_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_ ("Empty File"));
	g_object_ref_sink (_tmp7_);
	file_menuitem = _tmp7_;
	_tmp8_ = file_menuitem;
	gtk_actionable_set_action_name ((GtkActionable*) _tmp8_, "background.new");
	_tmp9_ = file_menuitem;
	_tmp10_ = _variant_new14 ("FILE");
	g_object_set ((GtkActionable*) _tmp9_, "action-target", _tmp10_, NULL);
	_g_variant_unref0 (_tmp10_);
	_tmp11_ = (GtkMenu*) gtk_menu_new ();
	g_object_ref_sink (_tmp11_);
	_tmp12_ = _tmp11_;
	gtk_menu_item_set_submenu ((GtkMenuItem*) self, _tmp12_);
	_g_object_unref0 (_tmp12_);
	_tmp13_ = gtk_menu_item_get_submenu ((GtkMenuItem*) self);
	_tmp14_ = _tmp13_;
	_tmp15_ = folder_menuitem;
	gtk_container_add ((GtkContainer*) _tmp14_, (GtkWidget*) _tmp15_);
	_tmp16_ = gtk_menu_item_get_submenu ((GtkMenuItem*) self);
	_tmp17_ = _tmp16_;
	_tmp18_ = file_menuitem;
	gtk_container_add ((GtkContainer*) _tmp17_, (GtkWidget*) _tmp18_);
	(files_abstract_directory_view_templates == NULL) ? NULL : (files_abstract_directory_view_templates = (_g_list_free__g_object_unref0_ (files_abstract_directory_view_templates), NULL));
	files_abstract_directory_view_templates = NULL;
	_tmp19_ = g_get_user_special_dir (G_USER_DIRECTORY_TEMPLATES);
	template_path = _tmp19_;
	_tmp20_ = template_path;
	if (_tmp20_ != NULL) {
		GFile* template_folder = NULL;
		const gchar* _tmp21_;
		GFile* _tmp22_;
		GFile* _tmp23_;
		GList* _tmp24_;
		_tmp21_ = template_path;
		_tmp22_ = g_file_new_for_path (_tmp21_);
		template_folder = _tmp22_;
		_tmp23_ = template_folder;
		files_abstract_directory_view_load_templates_from_folder (_tmp23_);
		_tmp24_ = files_abstract_directory_view_templates;
		if (g_list_length (_tmp24_) > ((guint) 0)) {
			GtkMenu* _tmp25_;
			GtkMenu* _tmp26_;
			GtkSeparatorMenuItem* _tmp27_;
			GtkSeparatorMenuItem* _tmp28_;
			GtkMenu* active_submenu = NULL;
			GtkMenu* _tmp29_;
			GtkMenu* _tmp30_;
			GtkMenu* _tmp31_;
			gint index = 0;
			GList* _tmp32_;
			_tmp25_ = gtk_menu_item_get_submenu ((GtkMenuItem*) self);
			_tmp26_ = _tmp25_;
			_tmp27_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
			g_object_ref_sink (_tmp27_);
			_tmp28_ = _tmp27_;
			gtk_container_add ((GtkContainer*) _tmp26_, (GtkWidget*) _tmp28_);
			_g_object_unref0 (_tmp28_);
			files_abstract_directory_view_templates = g_list_reverse (files_abstract_directory_view_templates);
			_tmp29_ = gtk_menu_item_get_submenu ((GtkMenuItem*) self);
			_tmp30_ = _tmp29_;
			_tmp31_ = _g_object_ref0 (_tmp30_);
			active_submenu = _tmp31_;
			index = 0;
			_tmp32_ = files_abstract_directory_view_templates;
			{
				GList* template_collection = NULL;
				GList* template_it = NULL;
				template_collection = _tmp32_;
				for (template_it = template_collection; template_it != NULL; template_it = template_it->next) {
					GFile* template = NULL;
					template = (GFile*) template_it->data;
					{
						gchar* label = NULL;
						GFile* _tmp33_;
						gchar* _tmp34_;
						GFileType ftype = 0;
						GFile* _tmp35_;
						gint _tmp58_;
						_tmp33_ = template;
						_tmp34_ = g_file_get_basename (_tmp33_);
						label = _tmp34_;
						_tmp35_ = template;
						ftype = g_file_query_file_type (_tmp35_, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, NULL);
						if (ftype == G_FILE_TYPE_DIRECTORY) {
							GFile* _tmp36_;
							GFile* _tmp37_;
							_tmp36_ = template;
							_tmp37_ = template_folder;
							if (_tmp36_ == _tmp37_) {
								GtkMenu* _tmp38_;
								GtkMenu* _tmp39_;
								GtkMenu* _tmp40_;
								_tmp38_ = gtk_menu_item_get_submenu ((GtkMenuItem*) self);
								_tmp39_ = _tmp38_;
								_tmp40_ = _g_object_ref0 (_tmp39_);
								_g_object_unref0 (active_submenu);
								active_submenu = _tmp40_;
							} else {
								GtkMenu* _tmp41_;
								GtkMenuItem* submenu_item = NULL;
								const gchar* _tmp42_;
								GtkMenuItem* _tmp43_;
								GtkMenuItem* _tmp44_;
								GtkMenu* _tmp45_;
								GtkMenu* _tmp46_;
								GtkMenu* _tmp47_;
								GtkMenuItem* _tmp48_;
								_tmp41_ = (GtkMenu*) gtk_menu_new ();
								g_object_ref_sink (_tmp41_);
								_g_object_unref0 (active_submenu);
								active_submenu = _tmp41_;
								_tmp42_ = label;
								_tmp43_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_tmp42_);
								g_object_ref_sink (_tmp43_);
								submenu_item = _tmp43_;
								_tmp44_ = submenu_item;
								_tmp45_ = active_submenu;
								gtk_menu_item_set_submenu (_tmp44_, _tmp45_);
								_tmp46_ = gtk_menu_item_get_submenu ((GtkMenuItem*) self);
								_tmp47_ = _tmp46_;
								_tmp48_ = submenu_item;
								gtk_container_add ((GtkContainer*) _tmp47_, (GtkWidget*) _tmp48_);
								_g_object_unref0 (submenu_item);
							}
						} else {
							GtkMenuItem* template_menuitem = NULL;
							const gchar* _tmp49_;
							GtkMenuItem* _tmp50_;
							GtkMenuItem* _tmp51_;
							gchar* _tmp52_;
							gchar* _tmp53_;
							gchar* _tmp54_;
							gchar* _tmp55_;
							GtkMenu* _tmp56_;
							GtkMenuItem* _tmp57_;
							_tmp49_ = label;
							_tmp50_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_tmp49_);
							g_object_ref_sink (_tmp50_);
							template_menuitem = _tmp50_;
							_tmp51_ = template_menuitem;
							_tmp52_ = g_strdup_printf ("%i", index);
							_tmp53_ = _tmp52_;
							_tmp54_ = g_strconcat ("background.create-from::", _tmp53_, NULL);
							_tmp55_ = _tmp54_;
							gtk_actionable_set_detailed_action_name ((GtkActionable*) _tmp51_, _tmp55_);
							_g_free0 (_tmp55_);
							_g_free0 (_tmp53_);
							_tmp56_ = active_submenu;
							_tmp57_ = template_menuitem;
							gtk_container_add ((GtkContainer*) _tmp56_, (GtkWidget*) _tmp57_);
							_g_object_unref0 (template_menuitem);
						}
						_tmp58_ = index;
						index = _tmp58_ + 1;
						_g_free0 (label);
					}
				}
			}
			_g_object_unref0 (active_submenu);
		}
		_g_object_unref0 (template_folder);
	}
	gtk_menu_item_set_label ((GtkMenuItem*) self, _ ("New"));
	_g_object_unref0 (file_menuitem);
	_g_object_unref0 (folder_menuitem);
	return obj;
}

static void
files_abstract_directory_view_new_sub_menu_item_class_init (FilesAbstractDirectoryViewNewSubMenuItemClass * klass,
                                                            gpointer klass_data)
{
	files_abstract_directory_view_new_sub_menu_item_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->constructor = files_abstract_directory_view_new_sub_menu_item_constructor;
}

static void
files_abstract_directory_view_new_sub_menu_item_instance_init (FilesAbstractDirectoryViewNewSubMenuItem * self,
                                                               gpointer klass)
{
}

static GType
files_abstract_directory_view_new_sub_menu_item_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FilesAbstractDirectoryViewNewSubMenuItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) files_abstract_directory_view_new_sub_menu_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FilesAbstractDirectoryViewNewSubMenuItem), 0, (GInstanceInitFunc) files_abstract_directory_view_new_sub_menu_item_instance_init, NULL };
	GType files_abstract_directory_view_new_sub_menu_item_type_id;
	files_abstract_directory_view_new_sub_menu_item_type_id = g_type_register_static (gtk_menu_item_get_type (), "FilesAbstractDirectoryViewNewSubMenuItem", &g_define_type_info, 0);
	return files_abstract_directory_view_new_sub_menu_item_type_id;
}

static GType
files_abstract_directory_view_new_sub_menu_item_get_type (void)
{
	static volatile gsize files_abstract_directory_view_new_sub_menu_item_type_id__once = 0;
	if (g_once_init_enter (&files_abstract_directory_view_new_sub_menu_item_type_id__once)) {
		GType files_abstract_directory_view_new_sub_menu_item_type_id;
		files_abstract_directory_view_new_sub_menu_item_type_id = files_abstract_directory_view_new_sub_menu_item_get_type_once ();
		g_once_init_leave (&files_abstract_directory_view_new_sub_menu_item_type_id__once, files_abstract_directory_view_new_sub_menu_item_type_id);
	}
	return files_abstract_directory_view_new_sub_menu_item_type_id__once;
}

static void
files_abstract_directory_view_class_init (FilesAbstractDirectoryViewClass * klass,
                                          gpointer klass_data)
{
	FilesDndHandler* _tmp0_;
	files_abstract_directory_view_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &FilesAbstractDirectoryView_private_offset);
	((FilesAbstractDirectoryViewClass *) klass)->set_up_name_renderer = (void (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_set_up_name_renderer;
	((FilesAbstractDirectoryViewClass *) klass)->on_row_deleted = (void (*) (FilesAbstractDirectoryView*, GtkTreePath*)) files_abstract_directory_view_real_on_row_deleted;
	((FilesAbstractDirectoryViewClass *) klass)->on_view_key_press_event = (gboolean (*) (FilesAbstractDirectoryView*, GdkEventKey*)) files_abstract_directory_view_real_on_view_key_press_event;
	((FilesAbstractDirectoryViewClass *) klass)->on_scroll_event = (gboolean (*) (FilesAbstractDirectoryView*, GdkEventScroll*)) files_abstract_directory_view_real_on_scroll_event;
	((FilesAbstractDirectoryViewClass *) klass)->on_view_draw = (gboolean (*) (FilesAbstractDirectoryView*, cairo_t*)) files_abstract_directory_view_real_on_view_draw;
	((FilesAbstractDirectoryViewClass *) klass)->handle_primary_button_click = (gboolean (*) (FilesAbstractDirectoryView*, GdkEventButton*, GtkTreePath*)) files_abstract_directory_view_real_handle_primary_button_click;
	((FilesAbstractDirectoryViewClass *) klass)->handle_secondary_button_click = (gboolean (*) (FilesAbstractDirectoryView*, GdkEventButton*)) files_abstract_directory_view_real_handle_secondary_button_click;
	((FilesAbstractDirectoryViewClass *) klass)->on_view_button_press_event = (gboolean (*) (FilesAbstractDirectoryView*, GdkEventButton*)) files_abstract_directory_view_real_on_view_button_press_event;
	((FilesAbstractDirectoryViewClass *) klass)->on_view_button_release_event = (gboolean (*) (FilesAbstractDirectoryView*, GdkEventButton*)) files_abstract_directory_view_real_on_view_button_release_event;
	((FilesAbstractDirectoryViewClass *) klass)->change_zoom_level = (void (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_change_zoom_level;
	((FilesAbstractDirectoryViewClass *) klass)->expand_collapse = (gboolean (*) (FilesAbstractDirectoryView*, GtkTreePath*)) files_abstract_directory_view_real_expand_collapse;
	((FilesAbstractDirectoryViewClass *) klass)->handle_default_button_click = (gboolean (*) (FilesAbstractDirectoryView*, GdkEventButton*)) files_abstract_directory_view_real_handle_default_button_click;
	((FilesAbstractDirectoryViewClass *) klass)->get_next_visible_iter = (gboolean (*) (FilesAbstractDirectoryView*, GtkTreeIter*, gboolean)) files_abstract_directory_view_real_get_next_visible_iter;
	((FilesAbstractDirectoryViewClass *) klass)->cancel = (void (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_cancel;
	((FilesAbstractDirectoryViewClass *) klass)->highlight_path = (void (*) (FilesAbstractDirectoryView*, GtkTreePath*)) files_abstract_directory_view_real_highlight_path;
	((FilesAbstractDirectoryViewClass *) klass)->up = (GtkTreePath* (*) (FilesAbstractDirectoryView*, GtkTreePath*)) files_abstract_directory_view_real_up;
	((FilesAbstractDirectoryViewClass *) klass)->down = (GtkTreePath* (*) (FilesAbstractDirectoryView*, GtkTreePath*)) files_abstract_directory_view_real_down;
	((FilesAbstractDirectoryViewClass *) klass)->get_selected_paths = (GList* (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_get_selected_paths;
	((FilesAbstractDirectoryViewClass *) klass)->get_path_at_pos = (GtkTreePath* (*) (FilesAbstractDirectoryView*, gint, gint)) files_abstract_directory_view_real_get_path_at_pos;
	((FilesAbstractDirectoryViewClass *) klass)->get_path_at_cursor = (GtkTreePath* (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_get_path_at_cursor;
	((FilesAbstractDirectoryViewClass *) klass)->tree_select_all = (void (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_tree_select_all;
	((FilesAbstractDirectoryViewClass *) klass)->tree_unselect_all = (void (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_tree_unselect_all;
	((FilesAbstractDirectoryViewClass *) klass)->tree_unselect_others = (void (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_tree_unselect_others;
	((FilesAbstractDirectoryViewClass *) klass)->select_path = (void (*) (FilesAbstractDirectoryView*, GtkTreePath*, gboolean)) files_abstract_directory_view_real_select_path;
	((FilesAbstractDirectoryViewClass *) klass)->unselect_path = (void (*) (FilesAbstractDirectoryView*, GtkTreePath*)) files_abstract_directory_view_real_unselect_path;
	((FilesAbstractDirectoryViewClass *) klass)->path_is_selected = (gboolean (*) (FilesAbstractDirectoryView*, GtkTreePath*)) files_abstract_directory_view_real_path_is_selected;
	((FilesAbstractDirectoryViewClass *) klass)->get_visible_range = (gboolean (*) (FilesAbstractDirectoryView*, GtkTreePath**, GtkTreePath**)) files_abstract_directory_view_real_get_visible_range;
	((FilesAbstractDirectoryViewClass *) klass)->set_cursor = (void (*) (FilesAbstractDirectoryView*, GtkTreePath*, gboolean, gboolean, gboolean)) files_abstract_directory_view_real_set_cursor;
	((FilesAbstractDirectoryViewClass *) klass)->move_cursor = (gboolean (*) (FilesAbstractDirectoryView*, guint, gboolean, gboolean)) files_abstract_directory_view_real_move_cursor;
	((FilesAbstractDirectoryViewClass *) klass)->will_handle_button_press = (gboolean (*) (FilesAbstractDirectoryView*, gboolean, gboolean, gboolean)) files_abstract_directory_view_real_will_handle_button_press;
	((FilesAbstractDirectoryViewClass *) klass)->handle_multi_select = (gboolean (*) (FilesAbstractDirectoryView*, GtkTreePath*)) files_abstract_directory_view_real_handle_multi_select;
	((FilesAbstractDirectoryViewClass *) klass)->create_view = (GtkWidget* (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_create_view;
	((FilesAbstractDirectoryViewClass *) klass)->set_up_zoom_level = (void (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_set_up_zoom_level;
	((FilesAbstractDirectoryViewClass *) klass)->get_normal_zoom_level = (FilesZoomLevel (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_get_normal_zoom_level;
	((FilesAbstractDirectoryViewClass *) klass)->view_has_focus = (gboolean (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_view_has_focus;
	((FilesAbstractDirectoryViewClass *) klass)->get_selected_files_from_model = (guint (*) (FilesAbstractDirectoryView*, GList**)) files_abstract_directory_view_real_get_selected_files_from_model;
	((FilesAbstractDirectoryViewClass *) klass)->get_event_position_info = (guint (*) (FilesAbstractDirectoryView*, GdkEventButton*, GtkTreePath**, gboolean)) files_abstract_directory_view_real_get_event_position_info;
	((FilesAbstractDirectoryViewClass *) klass)->scroll_to_cell = (void (*) (FilesAbstractDirectoryView*, GtkTreePath*, gboolean)) files_abstract_directory_view_real_scroll_to_cell;
	((FilesAbstractDirectoryViewClass *) klass)->set_cursor_on_cell = (void (*) (FilesAbstractDirectoryView*, GtkTreePath*, GtkCellRenderer*, gboolean, gboolean)) files_abstract_directory_view_real_set_cursor_on_cell;
	((FilesAbstractDirectoryViewClass *) klass)->freeze_tree = (void (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_freeze_tree;
	((FilesAbstractDirectoryViewClass *) klass)->thaw_tree = (void (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_thaw_tree;
	((FilesAbstractDirectoryViewClass *) klass)->freeze_child_notify = (void (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_freeze_child_notify;
	((FilesAbstractDirectoryViewClass *) klass)->thaw_child_notify = (void (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_thaw_child_notify;
	((FilesAbstractDirectoryViewClass *) klass)->connect_tree_signals = (void (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_connect_tree_signals;
	((FilesAbstractDirectoryViewClass *) klass)->disconnect_tree_signals = (void (*) (FilesAbstractDirectoryView*)) files_abstract_directory_view_real_disconnect_tree_signals;
	G_OBJECT_CLASS (klass)->get_property = _vala_files_abstract_directory_view_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_files_abstract_directory_view_set_property;
	G_OBJECT_CLASS (klass)->finalize = files_abstract_directory_view_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_ABSTRACT_DIRECTORY_VIEW_ZOOM_LEVEL_PROPERTY, files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_ZOOM_LEVEL_PROPERTY] = g_param_spec_enum ("zoom-level", "zoom-level", "zoom-level", FILES_TYPE_ZOOM_LEVEL, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_ABSTRACT_DIRECTORY_VIEW_ICON_SIZE_PROPERTY, files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_ICON_SIZE_PROPERTY] = g_param_spec_int ("icon-size", "icon-size", "icon-size", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_ABSTRACT_DIRECTORY_VIEW_SINGLECLICK_SELECT_PROPERTY, files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_SINGLECLICK_SELECT_PROPERTY] = g_param_spec_boolean ("singleclick-select", "singleclick-select", "singleclick-select", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_ABSTRACT_DIRECTORY_VIEW_RENAMING_PROPERTY, files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_RENAMING_PROPERTY] = g_param_spec_boolean ("renaming", "renaming", "renaming", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_ABSTRACT_DIRECTORY_VIEW_IS_FROZEN_PROPERTY, files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_IS_FROZEN_PROPERTY] = g_param_spec_boolean ("is-frozen", "is-frozen", "is-frozen", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_ABSTRACT_DIRECTORY_VIEW_IN_RECENT_PROPERTY, files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_IN_RECENT_PROPERTY] = g_param_spec_boolean ("in-recent", "in-recent", "in-recent", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_ABSTRACT_DIRECTORY_VIEW_TREE_FROZEN_PROPERTY, files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_TREE_FROZEN_PROPERTY] = g_param_spec_boolean ("tree-frozen", "tree-frozen", "tree-frozen", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_ABSTRACT_DIRECTORY_VIEW_SHOW_REMOTE_THUMBNAILS_PROPERTY, files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_SHOW_REMOTE_THUMBNAILS_PROPERTY] = g_param_spec_boolean ("show-remote-thumbnails", "show-remote-thumbnails", "show-remote-thumbnails", TRUE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_ABSTRACT_DIRECTORY_VIEW_SHOW_LOCAL_THUMBNAILS_PROPERTY, files_abstract_directory_view_properties[FILES_ABSTRACT_DIRECTORY_VIEW_SHOW_LOCAL_THUMBNAILS_PROPERTY] = g_param_spec_boolean ("show-local-thumbnails", "show-local-thumbnails", "show-local-thumbnails", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	files_abstract_directory_view_signals[FILES_ABSTRACT_DIRECTORY_VIEW_PATH_CHANGE_REQUEST_SIGNAL] = g_signal_new ("path-change-request", FILES_TYPE_ABSTRACT_DIRECTORY_VIEW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__OBJECT_ENUM_BOOLEAN, G_TYPE_NONE, 3, g_file_get_type (), FILES_TYPE_OPEN_FLAG, G_TYPE_BOOLEAN);
	files_abstract_directory_view_signals[FILES_ABSTRACT_DIRECTORY_VIEW_SELECTION_CHANGED_SIGNAL] = g_signal_new ("selection-changed", FILES_TYPE_ABSTRACT_DIRECTORY_VIEW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__POINTER, G_TYPE_NONE, 1, G_TYPE_POINTER);
	_tmp0_ = files_dnd_handler_new ();
	files_abstract_directory_view_dnd_handler = _tmp0_;
}

static void
files_abstract_directory_view_instance_init (FilesAbstractDirectoryView * self,
                                             gpointer klass)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	self->priv = files_abstract_directory_view_get_instance_private (self);
	self->priv->_zoom_level = FILES_ZOOM_LEVEL_NORMAL;
	self->minimum_zoom = FILES_ZOOM_LEVEL_SMALLEST;
	self->maximum_zoom = FILES_ZOOM_LEVEL_LARGEST;
	self->large_thumbnails = FALSE;
	self->priv->drag_x = (gdouble) 0;
	self->priv->drag_y = (gdouble) 0;
	self->priv->drag_timer_id = (guint) 0;
	self->source_drag_file_list = NULL;
	self->current_target_type = GDK_NONE;
	self->priv->drag_scroll_timer_id = (guint) 0;
	self->priv->drag_enter_timer_id = (guint) 0;
	self->priv->destination_data_ready = FALSE;
	self->priv->drop_occurred = FALSE;
	self->priv->drop_target_file = NULL;
	self->priv->destination_drop_file_list = NULL;
	self->priv->current_suggested_action = GDK_ACTION_DEFAULT;
	self->priv->current_actions = GDK_ACTION_DEFAULT;
	self->dnd_disabled = FALSE;
	self->priv->thumbnail_request = -1;
	self->priv->thumbnail_source_id = (guint) 0;
	self->priv->freeze_source_id = (guint) 0;
	self->priv->thumbnailer = NULL;
	self->priv->add_remove_file_timeout_id = (guint) 0;
	self->priv->signal_free_space_change = FALSE;
	self->name_renderer = NULL;
	_tmp0_ = g_strdup ("");
	self->original_name = _tmp0_;
	_tmp1_ = g_strdup ("");
	self->proposed_name = _tmp1_;
	self->priv->total_delta_y = 0.0;
	self->right_margin_unselects_all = FALSE;
	self->on_directory = FALSE;
	self->one_or_less = TRUE;
	self->should_activate = FALSE;
	self->should_scroll = TRUE;
	self->should_deselect = FALSE;
	self->should_select = FALSE;
	self->click_path = NULL;
	self->click_zone = (guint) FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_ICON;
	self->previous_click_zone = (guint) FILES_ABSTRACT_DIRECTORY_VIEW_CLICK_ZONE_ICON;
	self->selected_files = NULL;
	self->priv->selected_files_invalid = TRUE;
	self->priv->hover_path = NULL;
	self->priv->_renaming = FALSE;
	self->priv->_is_frozen = FALSE;
	self->priv->_in_recent = FALSE;
	self->priv->_tree_frozen = FALSE;
	self->priv->in_trash = FALSE;
	self->priv->in_network_root = FALSE;
	self->is_writable = FALSE;
	self->priv->_show_remote_thumbnails = TRUE;
	self->priv->_show_local_thumbnails = FALSE;
	self->priv->all_selected = FALSE;
	self->priv->set_cursor_timeout_id = (guint) 0;
	self->priv->select_source_handler = (gulong) 0;
	self->priv->draw_timeout_id = (guint) 0;
}

static void
files_abstract_directory_view_finalize (GObject * obj)
{
	FilesAbstractDirectoryView * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_TYPE_ABSTRACT_DIRECTORY_VIEW, FilesAbstractDirectoryView);
	g_debug ("AbstractDirectoryView.vala:339: ADV destruct");
	_g_object_unref0 (self->priv->common_actions);
	_g_object_unref0 (self->priv->selection_actions);
	_g_object_unref0 (self->priv->background_actions);
	(self->source_drag_file_list == NULL) ? NULL : (self->source_drag_file_list = (_g_list_free__g_object_unref0_ (self->source_drag_file_list), NULL));
	_g_object_unref0 (self->priv->drop_target_file);
	(self->priv->destination_drop_file_list == NULL) ? NULL : (self->priv->destination_drop_file_list = (_g_list_free__g_object_unref0_ (self->priv->destination_drop_file_list), NULL));
	_g_object_unref0 (self->priv->thumbnailer);
	_g_object_unref0 (self->name_renderer);
	_g_free0 (self->original_name);
	_g_free0 (self->proposed_name);
	__vala_GtkTreePath_free0 (self->priv->deleted_path);
	__vala_GtkTreePath_free0 (self->click_path);
	_g_object_unref0 (self->priv->editable_cursor);
	_g_object_unref0 (self->priv->activatable_cursor);
	_g_object_unref0 (self->priv->selectable_cursor);
	(self->priv->open_with_apps == NULL) ? NULL : (self->priv->open_with_apps = (_g_list_free__g_object_unref0_ (self->priv->open_with_apps), NULL));
	(self->selected_files == NULL) ? NULL : (self->selected_files = (_g_list_free__g_object_unref0_ (self->selected_files), NULL));
	_g_object_unref0 (self->priv->default_app);
	__vala_GtkTreePath_free0 (self->priv->hover_path);
	_g_object_unref0 (self->priv->view);
	_g_object_unref0 (self->model);
	_g_object_unref0 (self->icon_renderer);
	G_OBJECT_CLASS (files_abstract_directory_view_parent_class)->finalize (obj);
}

static GType
files_abstract_directory_view_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FilesAbstractDirectoryViewClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) files_abstract_directory_view_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FilesAbstractDirectoryView), 0, (GInstanceInitFunc) files_abstract_directory_view_instance_init, NULL };
	GType files_abstract_directory_view_type_id;
	files_abstract_directory_view_type_id = g_type_register_static (gtk_scrolled_window_get_type (), "FilesAbstractDirectoryView", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
	FilesAbstractDirectoryView_private_offset = g_type_add_instance_private (files_abstract_directory_view_type_id, sizeof (FilesAbstractDirectoryViewPrivate));
	return files_abstract_directory_view_type_id;
}

GType
files_abstract_directory_view_get_type (void)
{
	static volatile gsize files_abstract_directory_view_type_id__once = 0;
	if (g_once_init_enter (&files_abstract_directory_view_type_id__once)) {
		GType files_abstract_directory_view_type_id;
		files_abstract_directory_view_type_id = files_abstract_directory_view_get_type_once ();
		g_once_init_leave (&files_abstract_directory_view_type_id__once, files_abstract_directory_view_type_id);
	}
	return files_abstract_directory_view_type_id__once;
}

static void
_vala_files_abstract_directory_view_get_property (GObject * object,
                                                  guint property_id,
                                                  GValue * value,
                                                  GParamSpec * pspec)
{
	FilesAbstractDirectoryView * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FILES_TYPE_ABSTRACT_DIRECTORY_VIEW, FilesAbstractDirectoryView);
	switch (property_id) {
		case FILES_ABSTRACT_DIRECTORY_VIEW_ZOOM_LEVEL_PROPERTY:
		g_value_set_enum (value, files_abstract_directory_view_get_zoom_level (self));
		break;
		case FILES_ABSTRACT_DIRECTORY_VIEW_ICON_SIZE_PROPERTY:
		g_value_set_int (value, files_abstract_directory_view_get_icon_size (self));
		break;
		case FILES_ABSTRACT_DIRECTORY_VIEW_SINGLECLICK_SELECT_PROPERTY:
		g_value_set_boolean (value, files_abstract_directory_view_get_singleclick_select (self));
		break;
		case FILES_ABSTRACT_DIRECTORY_VIEW_RENAMING_PROPERTY:
		g_value_set_boolean (value, files_abstract_directory_view_get_renaming (self));
		break;
		case FILES_ABSTRACT_DIRECTORY_VIEW_IS_FROZEN_PROPERTY:
		g_value_set_boolean (value, files_abstract_directory_view_get_is_frozen (self));
		break;
		case FILES_ABSTRACT_DIRECTORY_VIEW_IN_RECENT_PROPERTY:
		g_value_set_boolean (value, files_abstract_directory_view_get_in_recent (self));
		break;
		case FILES_ABSTRACT_DIRECTORY_VIEW_TREE_FROZEN_PROPERTY:
		g_value_set_boolean (value, files_abstract_directory_view_get_tree_frozen (self));
		break;
		case FILES_ABSTRACT_DIRECTORY_VIEW_SHOW_REMOTE_THUMBNAILS_PROPERTY:
		g_value_set_boolean (value, files_abstract_directory_view_get_show_remote_thumbnails (self));
		break;
		case FILES_ABSTRACT_DIRECTORY_VIEW_SHOW_LOCAL_THUMBNAILS_PROPERTY:
		g_value_set_boolean (value, files_abstract_directory_view_get_show_local_thumbnails (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_files_abstract_directory_view_set_property (GObject * object,
                                                  guint property_id,
                                                  const GValue * value,
                                                  GParamSpec * pspec)
{
	FilesAbstractDirectoryView * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FILES_TYPE_ABSTRACT_DIRECTORY_VIEW, FilesAbstractDirectoryView);
	switch (property_id) {
		case FILES_ABSTRACT_DIRECTORY_VIEW_ZOOM_LEVEL_PROPERTY:
		files_abstract_directory_view_set_zoom_level (self, g_value_get_enum (value));
		break;
		case FILES_ABSTRACT_DIRECTORY_VIEW_SINGLECLICK_SELECT_PROPERTY:
		files_abstract_directory_view_set_singleclick_select (self, g_value_get_boolean (value));
		break;
		case FILES_ABSTRACT_DIRECTORY_VIEW_RENAMING_PROPERTY:
		files_abstract_directory_view_set_renaming (self, g_value_get_boolean (value));
		break;
		case FILES_ABSTRACT_DIRECTORY_VIEW_IS_FROZEN_PROPERTY:
		files_abstract_directory_view_set_is_frozen (self, g_value_get_boolean (value));
		break;
		case FILES_ABSTRACT_DIRECTORY_VIEW_IN_RECENT_PROPERTY:
		files_abstract_directory_view_set_in_recent (self, g_value_get_boolean (value));
		break;
		case FILES_ABSTRACT_DIRECTORY_VIEW_TREE_FROZEN_PROPERTY:
		files_abstract_directory_view_set_tree_frozen (self, g_value_get_boolean (value));
		break;
		case FILES_ABSTRACT_DIRECTORY_VIEW_SHOW_REMOTE_THUMBNAILS_PROPERTY:
		files_abstract_directory_view_set_show_remote_thumbnails (self, g_value_get_boolean (value));
		break;
		case FILES_ABSTRACT_DIRECTORY_VIEW_SHOW_LOCAL_THUMBNAILS_PROPERTY:
		files_abstract_directory_view_set_show_local_thumbnails (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gssize
_vala_array_length (gpointer array)
{
	gssize length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

