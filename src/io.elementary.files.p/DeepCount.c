/* DeepCount.c generated by valac 0.56.3, the Vala compiler
 * generated from DeepCount.vala, do not modify */

#include <glib-object.h>
#include <glib.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define FILES_TYPE_DEEP_COUNT (files_deep_count_get_type ())
#define FILES_DEEP_COUNT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_TYPE_DEEP_COUNT, FilesDeepCount))
#define FILES_DEEP_COUNT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_TYPE_DEEP_COUNT, FilesDeepCountClass))
#define FILES_IS_DEEP_COUNT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_TYPE_DEEP_COUNT))
#define FILES_IS_DEEP_COUNT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_TYPE_DEEP_COUNT))
#define FILES_DEEP_COUNT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_TYPE_DEEP_COUNT, FilesDeepCountClass))

typedef struct _FilesDeepCount FilesDeepCount;
typedef struct _FilesDeepCountClass FilesDeepCountClass;
typedef struct _FilesDeepCountPrivate FilesDeepCountPrivate;
enum  {
	FILES_DEEP_COUNT_0_PROPERTY,
	FILES_DEEP_COUNT_NUM_PROPERTIES
};
static GParamSpec* files_deep_count_properties[FILES_DEEP_COUNT_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _FilesDeepCountProcessDirectoryData FilesDeepCountProcessDirectoryData;
enum  {
	FILES_DEEP_COUNT_FINISHED_SIGNAL,
	FILES_DEEP_COUNT_NUM_SIGNALS
};
static guint files_deep_count_signals[FILES_DEEP_COUNT_NUM_SIGNALS] = {0};

struct _FilesDeepCount {
	GObject parent_instance;
	FilesDeepCountPrivate * priv;
	gint file_not_read;
	guint64 total_size;
	guint files_count;
	guint dirs_count;
	guint directories_count;
};

struct _FilesDeepCountClass {
	GObjectClass parent_class;
};

struct _FilesDeepCountPrivate {
	GFile* file;
	gchar* deep_count_attrs;
	GCancellable* cancellable;
	GList* directories;
	GMutex mutex;
};

struct _FilesDeepCountProcessDirectoryData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	FilesDeepCount* self;
	GFile* directory;
	GFile* _tmp0_;
	GFileEnumerator* e;
	const gchar* _tmp1_;
	GCancellable* _tmp2_;
	GFileEnumerator* _tmp3_;
	GList* files;
	GFileEnumerator* _tmp4_;
	GCancellable* _tmp5_;
	GList* _tmp6_;
	GList* _tmp7_;
	GList* _tmp8_;
	GList* f_collection;
	GList* f_it;
	GFileInfo* _tmp9_;
	GFileInfo* f;
	const gchar* name;
	GFileInfo* _tmp10_;
	const gchar* _tmp11_;
	GFile* location;
	const gchar* _tmp12_;
	GFile* _tmp13_;
	GFileInfo* _tmp14_;
	GFile* _tmp15_;
	guint _tmp16_;
	guint _tmp17_;
	guint64 file_size;
	GFileInfo* _tmp18_;
	guint64 allocated_size;
	GFileInfo* _tmp19_;
	gboolean _tmp20_;
	gboolean _tmp21_;
	GFileInfo* _tmp22_;
	GError* err;
	GError* _tmp23_;
	gint _tmp24_;
	GError* _tmp25_;
	const gchar* _tmp26_;
	GList* _tmp27_;
	GError* _inner_error0_;
};

static gint FilesDeepCount_private_offset;
static gpointer files_deep_count_parent_class = NULL;

VALA_EXTERN GType files_deep_count_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesDeepCount, g_object_unref)
static void _g_object_unref0_ (gpointer var);
static inline void _g_list_free__g_object_unref0_ (GList* self);
VALA_EXTERN FilesDeepCount* files_deep_count_new (GFile* _file);
VALA_EXTERN FilesDeepCount* files_deep_count_construct (GType object_type,
                                            GFile* _file);
static void files_deep_count_process_directory (FilesDeepCount* self,
                                         GFile* directory,
                                         GAsyncReadyCallback _callback_,
                                         gpointer _user_data_);
static void files_deep_count_process_directory_finish (FilesDeepCount* self,
                                                GAsyncResult* _res_);
static void files_deep_count_process_directory_data_free (gpointer _data);
static gboolean files_deep_count_process_directory_co (FilesDeepCountProcessDirectoryData* _data_);
static void files_deep_count_process_directory_ready (GObject* source_object,
                                               GAsyncResult* _res_,
                                               gpointer _user_data_);
VALA_EXTERN void files_deep_count_cancel (FilesDeepCount* self);
static void files_deep_count_finalize (GObject * obj);
static GType files_deep_count_get_type_once (void);
static void _vala_clear_GMutex (GMutex * mutex);
static void _vala_clear_GRecMutex (GRecMutex * mutex);
static void _vala_clear_GRWLock (GRWLock * mutex);
static void _vala_clear_GCond (GCond * mutex);

static inline gpointer
files_deep_count_get_instance_private (FilesDeepCount* self)
{
	return G_STRUCT_MEMBER_P (self, FilesDeepCount_private_offset);
}

static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}

static inline void
_g_list_free__g_object_unref0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_object_unref0_);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

FilesDeepCount*
files_deep_count_construct (GType object_type,
                            GFile* _file)
{
	FilesDeepCount * self = NULL;
	GFile* _tmp0_;
	gchar* _tmp1_;
	GCancellable* _tmp2_;
	GFile* _tmp3_;
	g_return_val_if_fail (_file != NULL, NULL);
	self = (FilesDeepCount*) g_object_new (object_type, NULL);
	_tmp0_ = _g_object_ref0 (_file);
	_g_object_unref0 (self->priv->file);
	self->priv->file = _tmp0_;
	_tmp1_ = g_strjoin (",", G_FILE_ATTRIBUTE_STANDARD_NAME, G_FILE_ATTRIBUTE_STANDARD_TYPE, G_FILE_ATTRIBUTE_STANDARD_SIZE, G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE, NULL);
	_g_free0 (self->priv->deep_count_attrs);
	self->priv->deep_count_attrs = _tmp1_;
	_tmp2_ = g_cancellable_new ();
	_g_object_unref0 (self->priv->cancellable);
	self->priv->cancellable = _tmp2_;
	_tmp3_ = self->priv->file;
	files_deep_count_process_directory (self, _tmp3_, NULL, NULL);
	return self;
}

FilesDeepCount*
files_deep_count_new (GFile* _file)
{
	return files_deep_count_construct (FILES_TYPE_DEEP_COUNT, _file);
}

static void
files_deep_count_process_directory_data_free (gpointer _data)
{
	FilesDeepCountProcessDirectoryData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->directory);
	_g_object_unref0 (_data_->self);
	g_slice_free (FilesDeepCountProcessDirectoryData, _data_);
}

static void
files_deep_count_process_directory (FilesDeepCount* self,
                                    GFile* directory,
                                    GAsyncReadyCallback _callback_,
                                    gpointer _user_data_)
{
	FilesDeepCountProcessDirectoryData* _data_;
	FilesDeepCount* _tmp0_;
	GFile* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (directory != NULL);
	_data_ = g_slice_new0 (FilesDeepCountProcessDirectoryData);
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, files_deep_count_process_directory_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = _g_object_ref0 (directory);
	_g_object_unref0 (_data_->directory);
	_data_->directory = _tmp1_;
	files_deep_count_process_directory_co (_data_);
}

static void
files_deep_count_process_directory_finish (FilesDeepCount* self,
                                           GAsyncResult* _res_)
{
	FilesDeepCountProcessDirectoryData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static void
files_deep_count_process_directory_ready (GObject* source_object,
                                          GAsyncResult* _res_,
                                          gpointer _user_data_)
{
	FilesDeepCountProcessDirectoryData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	files_deep_count_process_directory_co (_data_);
}

static GList*
vala_g_list_remove_full (GList* self,
                         gconstpointer data,
                         GFreeFunc func)
{
	GList* l = NULL;
	GList* result;
	l = self;
	while (TRUE) {
		GList* _tmp0_;
		GList* _tmp1_;
		gconstpointer _tmp2_;
		_tmp0_ = l;
		if (!(_tmp0_ != NULL)) {
			break;
		}
		_tmp1_ = l;
		_tmp2_ = ((GList*) _tmp1_)->data;
		if (_tmp2_ != data) {
			GList* _tmp3_;
			GList* _tmp4_;
			_tmp3_ = l;
			_tmp4_ = ((GList*) _tmp3_)->next;
			l = _tmp4_;
		} else {
			GList* _tmp5_;
			gconstpointer _tmp6_;
			GList* _tmp7_;
			_tmp5_ = l;
			_tmp6_ = ((GList*) _tmp5_)->data;
			func (_tmp6_);
			_tmp7_ = l;
			self = g_list_delete_link (self, (GList*) _tmp7_);
			break;
		}
	}
	result = self;
	return result;
}

static gboolean
files_deep_count_process_directory_co (FilesDeepCountProcessDirectoryData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		case 3:
		goto _state_3;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _g_object_ref0 (_data_->directory);
	_data_->self->priv->directories = g_list_prepend (_data_->self->priv->directories, _data_->_tmp0_);
	{
		_data_->_tmp1_ = _data_->self->priv->deep_count_attrs;
		_data_->_tmp2_ = _data_->self->priv->cancellable;
		_data_->_state_ = 1;
		g_file_enumerate_children_async (_data_->directory, _data_->_tmp1_, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, G_PRIORITY_LOW, _data_->_tmp2_, files_deep_count_process_directory_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp3_ = g_file_enumerate_children_finish (_data_->directory, _data_->_res_, &_data_->_inner_error0_);
		_data_->e = _data_->_tmp3_;
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		while (TRUE) {
			_data_->_tmp4_ = _data_->e;
			_data_->_tmp5_ = _data_->self->priv->cancellable;
			_data_->_state_ = 2;
			g_file_enumerator_next_files_async (_data_->_tmp4_, 1024, G_PRIORITY_LOW, _data_->_tmp5_, files_deep_count_process_directory_ready, _data_);
			return FALSE;
			_state_2:
			_data_->_tmp6_ = g_file_enumerator_next_files_finish (_data_->_tmp4_, _data_->_res_, &_data_->_inner_error0_);
			_data_->files = _data_->_tmp6_;
			if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
				_g_object_unref0 (_data_->e);
				goto __catch0_g_error;
			}
			_data_->_tmp7_ = _data_->files;
			if (_data_->_tmp7_ == NULL) {
				(_data_->files == NULL) ? NULL : (_data_->files = (_g_list_free__g_object_unref0_ (_data_->files), NULL));
				break;
			}
			_data_->_tmp8_ = _data_->files;
			{
				_data_->f_collection = _data_->_tmp8_;
				for (_data_->f_it = _data_->f_collection; _data_->f_it != NULL; _data_->f_it = _data_->f_it->next) {
					_data_->_tmp9_ = _g_object_ref0 ((GFileInfo*) _data_->f_it->data);
					_data_->f = _data_->_tmp9_;
					{
						_data_->_tmp10_ = _data_->f;
						_data_->_tmp11_ = g_file_info_get_name (_data_->_tmp10_);
						_data_->name = _data_->_tmp11_;
						_data_->_tmp12_ = _data_->name;
						_data_->_tmp13_ = g_file_get_child (_data_->directory, _data_->_tmp12_);
						_data_->location = _data_->_tmp13_;
						_data_->_tmp14_ = _data_->f;
						if (g_file_info_get_file_type (_data_->_tmp14_) == G_FILE_TYPE_DIRECTORY) {
							_data_->_tmp15_ = _data_->location;
							_data_->_state_ = 3;
							files_deep_count_process_directory (_data_->self, _data_->_tmp15_, files_deep_count_process_directory_ready, _data_);
							return FALSE;
							_state_3:
							files_deep_count_process_directory_finish (_data_->self, _data_->_res_);
							_data_->_tmp16_ = _data_->self->dirs_count;
							_data_->self->dirs_count = _data_->_tmp16_ + 1;
						} else {
							_data_->_tmp17_ = _data_->self->files_count;
							_data_->self->files_count = _data_->_tmp17_ + 1;
						}
						g_mutex_lock (&_data_->self->priv->mutex);
						_data_->_tmp18_ = _data_->f;
						_data_->file_size = (guint64) g_file_info_get_size (_data_->_tmp18_);
						_data_->_tmp19_ = _data_->f;
						_data_->allocated_size = g_file_info_get_attribute_uint64 (_data_->_tmp19_, G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE);
						if (_data_->allocated_size > ((guint64) 0)) {
							_data_->_tmp21_ = _data_->allocated_size < _data_->file_size;
						} else {
							_data_->_tmp21_ = FALSE;
						}
						if (_data_->_tmp21_) {
							_data_->_tmp22_ = _data_->f;
							_data_->_tmp20_ = g_file_info_get_file_type (_data_->_tmp22_) != G_FILE_TYPE_DIRECTORY;
						} else {
							_data_->_tmp20_ = FALSE;
						}
						if (_data_->_tmp20_) {
							_data_->file_size = _data_->allocated_size;
						}
						_data_->self->total_size = _data_->self->total_size + _data_->file_size;
						g_mutex_unlock (&_data_->self->priv->mutex);
						_g_object_unref0 (_data_->location);
						_g_object_unref0 (_data_->f);
					}
				}
			}
			(_data_->files == NULL) ? NULL : (_data_->files = (_g_list_free__g_object_unref0_ (_data_->files), NULL));
		}
		_g_object_unref0 (_data_->e);
	}
	goto __finally0;
	__catch0_g_error:
	{
		_data_->err = _data_->_inner_error0_;
		_data_->_inner_error0_ = NULL;
		_data_->_tmp23_ = _data_->err;
		if (!g_error_matches (_data_->_tmp23_, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
			g_mutex_lock (&_data_->self->priv->mutex);
			_data_->_tmp24_ = _data_->self->file_not_read;
			_data_->self->file_not_read = _data_->_tmp24_ + 1;
			g_mutex_unlock (&_data_->self->priv->mutex);
			_data_->_tmp25_ = _data_->err;
			_data_->_tmp26_ = _data_->_tmp25_->message;
			g_debug ("DeepCount.vala:95: %s", _data_->_tmp26_);
		}
		_g_error_free0 (_data_->err);
	}
	__finally0:
	if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
		g_clear_error (&_data_->_inner_error0_);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->self->priv->directories = vala_g_list_remove_full (_data_->self->priv->directories, _data_->directory, _g_object_unref0_);
	_data_->_tmp27_ = _data_->self->priv->directories;
	if (_data_->_tmp27_ == NULL) {
		g_signal_emit (_data_->self, files_deep_count_signals[FILES_DEEP_COUNT_FINISHED_SIGNAL], 0);
	}
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

void
files_deep_count_cancel (FilesDeepCount* self)
{
	GCancellable* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->cancellable;
	g_cancellable_cancel (_tmp0_);
}

static void
files_deep_count_class_init (FilesDeepCountClass * klass,
                             gpointer klass_data)
{
	files_deep_count_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &FilesDeepCount_private_offset);
	G_OBJECT_CLASS (klass)->finalize = files_deep_count_finalize;
	files_deep_count_signals[FILES_DEEP_COUNT_FINISHED_SIGNAL] = g_signal_new ("finished", FILES_TYPE_DEEP_COUNT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}

static void
files_deep_count_instance_init (FilesDeepCount * self,
                                gpointer klass)
{
	self->priv = files_deep_count_get_instance_private (self);
	self->priv->directories = NULL;
	self->file_not_read = 0;
	self->total_size = (guint64) 0;
	self->files_count = (guint) 0;
	self->dirs_count = (guint) 0;
	self->directories_count = (guint) 0;
}

static void
files_deep_count_finalize (GObject * obj)
{
	FilesDeepCount * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_TYPE_DEEP_COUNT, FilesDeepCount);
	_g_object_unref0 (self->priv->file);
	_g_free0 (self->priv->deep_count_attrs);
	_g_object_unref0 (self->priv->cancellable);
	(self->priv->directories == NULL) ? NULL : (self->priv->directories = (_g_list_free__g_object_unref0_ (self->priv->directories), NULL));
	_vala_clear_GMutex (&self->priv->mutex);
	G_OBJECT_CLASS (files_deep_count_parent_class)->finalize (obj);
}

/***
    Copyright (C) 2011 Marlin Developers

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    Author: ammonkey <am.monkeyd@gmail.com>
***/
static GType
files_deep_count_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FilesDeepCountClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) files_deep_count_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FilesDeepCount), 0, (GInstanceInitFunc) files_deep_count_instance_init, NULL };
	GType files_deep_count_type_id;
	files_deep_count_type_id = g_type_register_static (G_TYPE_OBJECT, "FilesDeepCount", &g_define_type_info, 0);
	FilesDeepCount_private_offset = g_type_add_instance_private (files_deep_count_type_id, sizeof (FilesDeepCountPrivate));
	return files_deep_count_type_id;
}

GType
files_deep_count_get_type (void)
{
	static volatile gsize files_deep_count_type_id__once = 0;
	if (g_once_init_enter (&files_deep_count_type_id__once)) {
		GType files_deep_count_type_id;
		files_deep_count_type_id = files_deep_count_get_type_once ();
		g_once_init_leave (&files_deep_count_type_id__once, files_deep_count_type_id);
	}
	return files_deep_count_type_id__once;
}

static void
_vala_clear_GMutex (GMutex * mutex)
{
	GMutex zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GMutex))) {
		g_mutex_clear (mutex);
		memset (mutex, 0, sizeof (GMutex));
	}
}

static void
_vala_clear_GRecMutex (GRecMutex * mutex)
{
	GRecMutex zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GRecMutex))) {
		g_rec_mutex_clear (mutex);
		memset (mutex, 0, sizeof (GRecMutex));
	}
}

static void
_vala_clear_GRWLock (GRWLock * mutex)
{
	GRWLock zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GRWLock))) {
		g_rw_lock_clear (mutex);
		memset (mutex, 0, sizeof (GRWLock));
	}
}

static void
_vala_clear_GCond (GCond * mutex)
{
	GCond zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GCond))) {
		g_cond_clear (mutex);
		memset (mutex, 0, sizeof (GCond));
	}
}

