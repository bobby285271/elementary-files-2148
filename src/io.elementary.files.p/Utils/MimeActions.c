/* MimeActions.c generated by valac 0.56.3, the Vala compiler
 * generated from MimeActions.vala, do not modify */

#include <glib-object.h>
#include "pantheon-files-core.h"
#include <gio/gio.h>
#include <glib.h>
#include <stdlib.h>
#include <string.h>
#include <gtk/gtk.h>
#include <glib/gi18n-lib.h>
#include <granite.h>
#include <gobject/gvaluecollector.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define FILES_TYPE_MIME_ACTIONS (files_mime_actions_get_type ())
#define FILES_MIME_ACTIONS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_TYPE_MIME_ACTIONS, FilesMimeActions))
#define FILES_MIME_ACTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_TYPE_MIME_ACTIONS, FilesMimeActionsClass))
#define FILES_IS_MIME_ACTIONS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_TYPE_MIME_ACTIONS))
#define FILES_IS_MIME_ACTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_TYPE_MIME_ACTIONS))
#define FILES_MIME_ACTIONS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_TYPE_MIME_ACTIONS, FilesMimeActionsClass))

typedef struct _FilesMimeActions FilesMimeActions;
typedef struct _FilesMimeActionsClass FilesMimeActionsClass;
typedef struct _FilesMimeActionsPrivate FilesMimeActionsPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _Block10Data Block10Data;
typedef struct _Block11Data Block11Data;

#define PF_TYPE_CHOOSE_APP_DIALOG (pf_choose_app_dialog_get_type ())
#define PF_CHOOSE_APP_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PF_TYPE_CHOOSE_APP_DIALOG, PFChooseAppDialog))
#define PF_CHOOSE_APP_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PF_TYPE_CHOOSE_APP_DIALOG, PFChooseAppDialogClass))
#define PF_IS_CHOOSE_APP_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PF_TYPE_CHOOSE_APP_DIALOG))
#define PF_IS_CHOOSE_APP_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PF_TYPE_CHOOSE_APP_DIALOG))
#define PF_CHOOSE_APP_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PF_TYPE_CHOOSE_APP_DIALOG, PFChooseAppDialogClass))

typedef struct _PFChooseAppDialog PFChooseAppDialog;
typedef struct _PFChooseAppDialogClass PFChooseAppDialogClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _FilesParamSpecMimeActions FilesParamSpecMimeActions;

struct _FilesMimeActions {
	GTypeInstance parent_instance;
	volatile int ref_count;
	FilesMimeActionsPrivate * priv;
};

struct _FilesMimeActionsClass {
	GTypeClass parent_class;
	void (*finalize) (FilesMimeActions *self);
};

struct _Block10Data {
	int _ref_count_;
	GList* sorted_files;
};

struct _Block11Data {
	int _ref_count_;
	GList* sorted_files;
};

struct _FilesParamSpecMimeActions {
	GParamSpec parent_instance;
};

static gpointer files_mime_actions_parent_class = NULL;

VALA_EXTERN gpointer files_mime_actions_ref (gpointer instance);
VALA_EXTERN void files_mime_actions_unref (gpointer instance);
VALA_EXTERN GParamSpec* files_param_spec_mime_actions (const gchar* name,
                                           const gchar* nick,
                                           const gchar* blurb,
                                           GType object_type,
                                           GParamFlags flags);
VALA_EXTERN void files_value_set_mime_actions (GValue* value,
                                   gpointer v_object);
VALA_EXTERN void files_value_take_mime_actions (GValue* value,
                                    gpointer v_object);
VALA_EXTERN gpointer files_value_get_mime_actions (const GValue* value);
VALA_EXTERN GType files_mime_actions_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FilesMimeActions, files_mime_actions_unref)
VALA_EXTERN GAppInfo* files_mime_actions_get_default_application_for_file (FilesFile* file);
VALA_EXTERN GAppInfo* files_mime_actions_get_default_application_for_files (GList* files);
static Block10Data* block10_data_ref (Block10Data* _data10_);
static void _g_object_unref0_ (gpointer var);
static inline void _g_list_free__g_object_unref0_ (GList* self);
static void block10_data_unref (void * _userdata_);
static void __lambda20_ (Block10Data* _data10_,
                  FilesFile* file);
static void ___lambda20__gfunc (gconstpointer data,
                         gpointer self);
static gint files_mime_actions_file_compare_by_mime_type (FilesFile* a,
                                                   FilesFile* b);
static gint _files_mime_actions_file_compare_by_mime_type_gcompare_func (gconstpointer a,
                                                                  gconstpointer b);
static gint files_mime_actions_file_compare_by_parent_uri (FilesFile* a,
                                                    FilesFile* b);
VALA_EXTERN GList* files_mime_actions_get_applications_for_file (FilesFile* file);
static gboolean files_mime_actions_file_has_local_path (FilesFile* file);
static GList* files_mime_actions_filter_non_uri_apps (GList* apps);
static gint files_mime_actions_application_compare_by_name (GAppInfo* a,
                                                     GAppInfo* b);
static gint _files_mime_actions_application_compare_by_name_gcompare_func (gconstpointer a,
                                                                    gconstpointer b);
VALA_EXTERN GList* files_mime_actions_get_applications_for_folder (FilesFile* file);
VALA_EXTERN GList* files_mime_actions_get_applications_for_files (GList* files);
static Block11Data* block11_data_ref (Block11Data* _data11_);
static void block11_data_unref (void * _userdata_);
static void __lambda21_ (Block11Data* _data11_,
                  FilesFile* file);
static void ___lambda21__gfunc (gconstpointer data,
                         gpointer self);
static gint files_mime_actions_application_compare_by_id (GAppInfo* a,
                                                   GAppInfo* b);
static gint _files_mime_actions_application_compare_by_id_gcompare_func (gconstpointer a,
                                                                  gconstpointer b);
static GList* files_mime_actions_intersect_application_lists (GList* a,
                                                       GList* b);
static gchar* files_mime_actions_gof_get_parent_uri (FilesFile* file);
VALA_EXTERN GAppInfo* files_mime_actions_get_default_application_for_glib_file (GFile* file);
VALA_EXTERN void files_mime_actions_open_glib_file_request (GFile* file_to_open,
                                                GtkWidget* parent,
                                                GAppInfo* app);
VALA_EXTERN GAppInfo* files_mime_actions_choose_app_for_glib_file (GFile* file_to_open,
                                                       GtkWidget* parent);
static void files_mime_actions_launch_glib_file_with_app (GFile* file_to_open,
                                                   GtkWidget* parent,
                                                   GAppInfo* app);
VALA_EXTERN void files_mime_actions_open_multiple_gof_files_request (GList* gofs_to_open,
                                                         GtkWidget* parent,
                                                         GAppInfo* app);
VALA_EXTERN GtkWindow* files_get_active_window (void);
static void files_mime_actions_launch_with_app (GList* files_to_open,
                                         GAppInfo* app,
                                         GtkWindow* win);
VALA_EXTERN GType pf_choose_app_dialog_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PFChooseAppDialog, g_object_unref)
VALA_EXTERN PFChooseAppDialog* pf_choose_app_dialog_new (GtkWindow* parent,
                                             GFile* file_to_open);
VALA_EXTERN PFChooseAppDialog* pf_choose_app_dialog_construct (GType object_type,
                                                   GtkWindow* parent,
                                                   GFile* file_to_open);
VALA_EXTERN GAppInfo* pf_choose_app_dialog_get_app_info (PFChooseAppDialog* self);
static void _g_free0_ (gpointer var);
static inline void _g_list_free__g_free0_ (GList* self);
VALA_EXTERN FilesMimeActions* files_mime_actions_new (void);
VALA_EXTERN FilesMimeActions* files_mime_actions_construct (GType object_type);
static void files_mime_actions_finalize (FilesMimeActions * obj);
static GType files_mime_actions_get_type_once (void);

GAppInfo*
files_mime_actions_get_default_application_for_file (FilesFile* file)
{
	GAppInfo* app = NULL;
	GAppInfo* _tmp0_;
	GAppInfo* _tmp1_;
	GAppInfo* result;
	g_return_val_if_fail (file != NULL, NULL);
	_tmp0_ = files_file_get_default_handler (file);
	app = _tmp0_;
	_tmp1_ = app;
	if (_tmp1_ == NULL) {
		gchar* uri_scheme = NULL;
		GFile* _tmp2_;
		GFile* _tmp3_;
		gchar* _tmp4_;
		const gchar* _tmp5_;
		_tmp2_ = files_file_get_location (file);
		_tmp3_ = _tmp2_;
		_tmp4_ = g_file_get_uri_scheme (_tmp3_);
		uri_scheme = _tmp4_;
		_tmp5_ = uri_scheme;
		if (_tmp5_ != NULL) {
			const gchar* _tmp6_;
			GAppInfo* _tmp7_;
			_tmp6_ = uri_scheme;
			_tmp7_ = g_app_info_get_default_for_uri_scheme (_tmp6_);
			_g_object_unref0 (app);
			app = _tmp7_;
		}
		_g_free0 (uri_scheme);
	}
	result = app;
	return result;
}

static Block10Data*
block10_data_ref (Block10Data* _data10_)
{
	g_atomic_int_inc (&_data10_->_ref_count_);
	return _data10_;
}

static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}

static inline void
_g_list_free__g_object_unref0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_object_unref0_);
}

static void
block10_data_unref (void * _userdata_)
{
	Block10Data* _data10_;
	_data10_ = (Block10Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data10_->_ref_count_)) {
		(_data10_->sorted_files == NULL) ? NULL : (_data10_->sorted_files = (_g_list_free__g_object_unref0_ (_data10_->sorted_files), NULL));
		g_slice_free (Block10Data, _data10_);
	}
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static void
__lambda20_ (Block10Data* _data10_,
             FilesFile* file)
{
	FilesFile* _tmp0_;
	g_return_if_fail (file != NULL);
	_tmp0_ = _g_object_ref0 (file);
	_data10_->sorted_files = g_list_prepend (_data10_->sorted_files, _tmp0_);
}

static void
___lambda20__gfunc (gconstpointer data,
                    gpointer self)
{
	__lambda20_ (self, (FilesFile*) data);
}

static gint
_files_mime_actions_file_compare_by_mime_type_gcompare_func (gconstpointer a,
                                                             gconstpointer b)
{
	gint result;
	result = files_mime_actions_file_compare_by_mime_type ((FilesFile*) a, (FilesFile*) b);
	return result;
}

GAppInfo*
files_mime_actions_get_default_application_for_files (GList* files)
{
	Block10Data* _data10_;
	GAppInfo* app = NULL;
	FilesFile* previous_file = NULL;
	GList* _tmp0_;
	GAppInfo* result;
	_data10_ = g_slice_new0 (Block10Data);
	_data10_->_ref_count_ = 1;
	_data10_->sorted_files = NULL;
	g_list_foreach (files, ___lambda20__gfunc, _data10_);
	_data10_->sorted_files = g_list_sort (_data10_->sorted_files, _files_mime_actions_file_compare_by_mime_type_gcompare_func);
	app = NULL;
	previous_file = NULL;
	_tmp0_ = _data10_->sorted_files;
	{
		GList* file_collection = NULL;
		GList* file_it = NULL;
		file_collection = _tmp0_;
		for (file_it = file_collection; file_it != NULL; file_it = file_it->next) {
			FilesFile* _tmp1_;
			FilesFile* file = NULL;
			_tmp1_ = _g_object_ref0 ((FilesFile*) file_it->data);
			file = _tmp1_;
			{
				FilesFile* _tmp2_;
				gboolean _tmp7_ = FALSE;
				FilesFile* _tmp8_;
				FilesFile* _tmp9_;
				GAppInfo* one_app = NULL;
				FilesFile* _tmp12_;
				GAppInfo* _tmp13_;
				gboolean _tmp14_ = FALSE;
				GAppInfo* _tmp15_;
				GAppInfo* _tmp20_;
				FilesFile* _tmp23_;
				FilesFile* _tmp24_;
				_tmp2_ = previous_file;
				if (_tmp2_ == NULL) {
					FilesFile* _tmp3_;
					GAppInfo* _tmp4_;
					FilesFile* _tmp5_;
					FilesFile* _tmp6_;
					_tmp3_ = file;
					_tmp4_ = files_mime_actions_get_default_application_for_file (_tmp3_);
					_g_object_unref0 (app);
					app = _tmp4_;
					_tmp5_ = file;
					_tmp6_ = _g_object_ref0 (_tmp5_);
					_g_object_unref0 (previous_file);
					previous_file = _tmp6_;
					_g_object_unref0 (file);
					continue;
				}
				_tmp8_ = file;
				_tmp9_ = previous_file;
				if (files_mime_actions_file_compare_by_mime_type (_tmp8_, _tmp9_) == 0) {
					FilesFile* _tmp10_;
					FilesFile* _tmp11_;
					_tmp10_ = file;
					_tmp11_ = previous_file;
					_tmp7_ = files_mime_actions_file_compare_by_parent_uri (_tmp10_, _tmp11_) == 0;
				} else {
					_tmp7_ = FALSE;
				}
				if (_tmp7_) {
					_g_object_unref0 (file);
					continue;
				}
				_tmp12_ = file;
				_tmp13_ = files_mime_actions_get_default_application_for_file (_tmp12_);
				one_app = _tmp13_;
				_tmp15_ = one_app;
				if (_tmp15_ == NULL) {
					_tmp14_ = TRUE;
				} else {
					gboolean _tmp16_ = FALSE;
					GAppInfo* _tmp17_;
					_tmp17_ = app;
					if (_tmp17_ != NULL) {
						GAppInfo* _tmp18_;
						GAppInfo* _tmp19_;
						_tmp18_ = app;
						_tmp19_ = one_app;
						_tmp16_ = !g_app_info_equal (_tmp18_, _tmp19_);
					} else {
						_tmp16_ = FALSE;
					}
					_tmp14_ = _tmp16_;
				}
				if (_tmp14_) {
					_g_object_unref0 (app);
					app = NULL;
					_g_object_unref0 (one_app);
					_g_object_unref0 (file);
					break;
				}
				_tmp20_ = app;
				if (_tmp20_ == NULL) {
					GAppInfo* _tmp21_;
					GAppInfo* _tmp22_;
					_tmp21_ = one_app;
					_tmp22_ = _g_object_ref0 (_tmp21_);
					_g_object_unref0 (app);
					app = _tmp22_;
				}
				_tmp23_ = file;
				_tmp24_ = _g_object_ref0 (_tmp23_);
				_g_object_unref0 (previous_file);
				previous_file = _tmp24_;
				_g_object_unref0 (one_app);
				_g_object_unref0 (file);
			}
		}
	}
	result = app;
	_g_object_unref0 (previous_file);
	block10_data_unref (_data10_);
	_data10_ = NULL;
	return result;
}

static gint
_files_mime_actions_application_compare_by_name_gcompare_func (gconstpointer a,
                                                               gconstpointer b)
{
	gint result;
	result = files_mime_actions_application_compare_by_name ((GAppInfo*) a, (GAppInfo*) b);
	return result;
}

GList*
files_mime_actions_get_applications_for_file (FilesFile* file)
{
	GList* _result_ = NULL;
	gchar* type = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	GList* _tmp4_;
	gchar* uri_scheme = NULL;
	GFile* _tmp5_;
	GFile* _tmp6_;
	gchar* _tmp7_;
	const gchar* _tmp8_;
	GList* result;
	g_return_val_if_fail (file != NULL, NULL);
	_result_ = NULL;
	_tmp0_ = files_file_get_ftype (file);
	_tmp1_ = g_strdup (_tmp0_);
	type = _tmp1_;
	_tmp2_ = type;
	if (_tmp2_ == NULL) {
		result = _result_;
		_g_free0 (type);
		return result;
	}
	_tmp3_ = type;
	_tmp4_ = g_app_info_get_all_for_type (_tmp3_);
	(_result_ == NULL) ? NULL : (_result_ = (_g_list_free__g_object_unref0_ (_result_), NULL));
	_result_ = _tmp4_;
	_tmp5_ = files_file_get_location (file);
	_tmp6_ = _tmp5_;
	_tmp7_ = g_file_get_uri_scheme (_tmp6_);
	uri_scheme = _tmp7_;
	_tmp8_ = uri_scheme;
	if (_tmp8_ != NULL) {
		GAppInfo* uri_handler = NULL;
		const gchar* _tmp9_;
		GAppInfo* _tmp10_;
		GAppInfo* _tmp11_;
		_tmp9_ = uri_scheme;
		_tmp10_ = g_app_info_get_default_for_uri_scheme (_tmp9_);
		uri_handler = _tmp10_;
		_tmp11_ = uri_handler;
		if (_tmp11_ != NULL) {
			GAppInfo* _tmp12_;
			GAppInfo* _tmp13_;
			_tmp12_ = uri_handler;
			_tmp13_ = _g_object_ref0 (_tmp12_);
			_result_ = g_list_prepend (_result_, _tmp13_);
		}
		_g_object_unref0 (uri_handler);
	}
	if (!files_mime_actions_file_has_local_path (file)) {
		GList* _tmp14_;
		GList* _tmp15_;
		GList* _tmp16_;
		_tmp14_ = _result_;
		_tmp15_ = files_mime_actions_filter_non_uri_apps (_tmp14_);
		_tmp16_ = _tmp15_;
		(_tmp16_ == NULL) ? NULL : (_tmp16_ = (_g_list_free__g_object_unref0_ (_tmp16_), NULL));
	}
	_result_ = g_list_sort (_result_, _files_mime_actions_application_compare_by_name_gcompare_func);
	result = _result_;
	_g_free0 (uri_scheme);
	_g_free0 (type);
	return result;
}

GList*
files_mime_actions_get_applications_for_folder (FilesFile* file)
{
	GList* _result_ = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	GList* _tmp2_;
	GList* _tmp3_;
	gchar* uri_scheme = NULL;
	GFile* _tmp4_;
	GFile* _tmp5_;
	gchar* _tmp6_;
	const gchar* _tmp7_;
	GList* result;
	g_return_val_if_fail (file != NULL, NULL);
	_tmp0_ = g_content_type_get_mime_type ("inode/directory");
	_tmp1_ = _tmp0_;
	_tmp2_ = g_app_info_get_all_for_type (_tmp1_);
	_tmp3_ = _tmp2_;
	_g_free0 (_tmp1_);
	_result_ = _tmp3_;
	_tmp4_ = files_file_get_location (file);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_file_get_uri_scheme (_tmp5_);
	uri_scheme = _tmp6_;
	_tmp7_ = uri_scheme;
	if (_tmp7_ != NULL) {
		GAppInfo* uri_handler = NULL;
		const gchar* _tmp8_;
		GAppInfo* _tmp9_;
		GAppInfo* _tmp10_;
		_tmp8_ = uri_scheme;
		_tmp9_ = g_app_info_get_default_for_uri_scheme (_tmp8_);
		uri_handler = _tmp9_;
		_tmp10_ = uri_handler;
		if (_tmp10_ != NULL) {
			GAppInfo* _tmp11_;
			GAppInfo* _tmp12_;
			_tmp11_ = uri_handler;
			_tmp12_ = _g_object_ref0 (_tmp11_);
			_result_ = g_list_prepend (_result_, _tmp12_);
		}
		_g_object_unref0 (uri_handler);
	}
	if (!files_mime_actions_file_has_local_path (file)) {
		GList* _tmp13_;
		GList* _tmp14_;
		_tmp13_ = _result_;
		_tmp14_ = files_mime_actions_filter_non_uri_apps (_tmp13_);
		(_result_ == NULL) ? NULL : (_result_ = (_g_list_free__g_object_unref0_ (_result_), NULL));
		_result_ = _tmp14_;
	}
	_result_ = g_list_sort (_result_, _files_mime_actions_application_compare_by_name_gcompare_func);
	result = _result_;
	_g_free0 (uri_scheme);
	return result;
}

static Block11Data*
block11_data_ref (Block11Data* _data11_)
{
	g_atomic_int_inc (&_data11_->_ref_count_);
	return _data11_;
}

static void
block11_data_unref (void * _userdata_)
{
	Block11Data* _data11_;
	_data11_ = (Block11Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data11_->_ref_count_)) {
		(_data11_->sorted_files == NULL) ? NULL : (_data11_->sorted_files = (g_list_free (_data11_->sorted_files), NULL));
		g_slice_free (Block11Data, _data11_);
	}
}

static void
__lambda21_ (Block11Data* _data11_,
             FilesFile* file)
{
	g_return_if_fail (file != NULL);
	_data11_->sorted_files = g_list_prepend (_data11_->sorted_files, file);
}

static void
___lambda21__gfunc (gconstpointer data,
                    gpointer self)
{
	__lambda21_ (self, (FilesFile*) data);
}

static gint
_files_mime_actions_application_compare_by_id_gcompare_func (gconstpointer a,
                                                             gconstpointer b)
{
	gint result;
	result = files_mime_actions_application_compare_by_id ((GAppInfo*) a, (GAppInfo*) b);
	return result;
}

GList*
files_mime_actions_get_applications_for_files (GList* files)
{
	Block11Data* _data11_;
	GList* _result_ = NULL;
	FilesFile* previous_file = NULL;
	GList* _tmp0_;
	GList* result;
	_data11_ = g_slice_new0 (Block11Data);
	_data11_->_ref_count_ = 1;
	_data11_->sorted_files = NULL;
	g_list_foreach (files, ___lambda21__gfunc, _data11_);
	_data11_->sorted_files = g_list_sort (_data11_->sorted_files, _files_mime_actions_file_compare_by_mime_type_gcompare_func);
	_result_ = NULL;
	previous_file = NULL;
	_tmp0_ = _data11_->sorted_files;
	{
		GList* file_collection = NULL;
		GList* file_it = NULL;
		file_collection = _tmp0_;
		for (file_it = file_collection; file_it != NULL; file_it = file_it->next) {
			FilesFile* file = NULL;
			file = (FilesFile*) file_it->data;
			{
				FilesFile* _tmp1_;
				gboolean _tmp8_ = FALSE;
				FilesFile* _tmp9_;
				FilesFile* _tmp10_;
				GList* one_result = NULL;
				FilesFile* _tmp13_;
				GList* _tmp14_;
				gboolean _tmp15_ = FALSE;
				GList* _tmp16_;
				gboolean _tmp23_ = FALSE;
				GList* _tmp24_;
				FilesFile* _tmp27_;
				_tmp1_ = previous_file;
				if (_tmp1_ == NULL) {
					FilesFile* _tmp2_;
					GList* _tmp3_;
					GList* _tmp4_;
					FilesFile* _tmp7_;
					_tmp2_ = file;
					_tmp3_ = files_mime_actions_get_applications_for_file (_tmp2_);
					(_result_ == NULL) ? NULL : (_result_ = (_g_list_free__g_object_unref0_ (_result_), NULL));
					_result_ = _tmp3_;
					_tmp4_ = _result_;
					if (_tmp4_ == NULL) {
						FilesFile* _tmp5_;
						const gchar* _tmp6_;
						_tmp5_ = file;
						_tmp6_ = files_file_get_ftype (_tmp5_);
						g_debug ("MimeActions.vala:148: No application found for %s", _tmp6_);
						result = _result_;
						block11_data_unref (_data11_);
						_data11_ = NULL;
						return result;
					}
					_tmp7_ = file;
					previous_file = _tmp7_;
					continue;
				}
				_tmp9_ = file;
				_tmp10_ = previous_file;
				if (files_mime_actions_file_compare_by_mime_type (_tmp9_, _tmp10_) == 0) {
					FilesFile* _tmp11_;
					FilesFile* _tmp12_;
					_tmp11_ = file;
					_tmp12_ = previous_file;
					_tmp8_ = files_mime_actions_file_compare_by_parent_uri (_tmp11_, _tmp12_) == 0;
				} else {
					_tmp8_ = FALSE;
				}
				if (_tmp8_) {
					continue;
				}
				_tmp13_ = file;
				_tmp14_ = files_mime_actions_get_applications_for_file (_tmp13_);
				one_result = _tmp14_;
				one_result = g_list_sort (one_result, _files_mime_actions_application_compare_by_id_gcompare_func);
				_tmp16_ = _result_;
				if (_tmp16_ != NULL) {
					GList* _tmp17_;
					gconstpointer _tmp18_;
					_tmp17_ = _result_;
					_tmp18_ = _tmp17_->data;
					_tmp15_ = ((GAppInfo*) _tmp18_) != NULL;
				} else {
					_tmp15_ = FALSE;
				}
				if (_tmp15_) {
					GList* _tmp19_;
					GList* _tmp20_;
					GList* _tmp21_;
					_tmp19_ = _result_;
					_tmp20_ = one_result;
					_tmp21_ = files_mime_actions_intersect_application_lists (_tmp19_, _tmp20_);
					(_result_ == NULL) ? NULL : (_result_ = (_g_list_free__g_object_unref0_ (_result_), NULL));
					_result_ = _tmp21_;
				} else {
					GList* _tmp22_;
					_tmp22_ = one_result;
					one_result = NULL;
					(_result_ == NULL) ? NULL : (_result_ = (_g_list_free__g_object_unref0_ (_result_), NULL));
					_result_ = _tmp22_;
				}
				_tmp24_ = _result_;
				if (_tmp24_ == NULL) {
					_tmp23_ = TRUE;
				} else {
					GList* _tmp25_;
					gconstpointer _tmp26_;
					_tmp25_ = _result_;
					_tmp26_ = _tmp25_->data;
					_tmp23_ = ((GAppInfo*) _tmp26_) == NULL;
				}
				if (_tmp23_) {
					result = _result_;
					(one_result == NULL) ? NULL : (one_result = (_g_list_free__g_object_unref0_ (one_result), NULL));
					block11_data_unref (_data11_);
					_data11_ = NULL;
					return result;
				}
				_tmp27_ = file;
				previous_file = _tmp27_;
				(one_result == NULL) ? NULL : (one_result = (_g_list_free__g_object_unref0_ (one_result), NULL));
			}
		}
	}
	_result_ = g_list_sort (_result_, _files_mime_actions_application_compare_by_name_gcompare_func);
	result = _result_;
	block11_data_unref (_data11_);
	_data11_ = NULL;
	return result;
}

static gboolean
files_mime_actions_file_has_local_path (FilesFile* file)
{
	GFile* _tmp0_;
	GFile* _tmp1_;
	gboolean result;
	g_return_val_if_fail (file != NULL, FALSE);
	_tmp0_ = files_file_get_location (file);
	_tmp1_ = _tmp0_;
	if (g_file_is_native (_tmp1_)) {
		result = TRUE;
		return result;
	} else {
		gchar* path = NULL;
		GFile* _tmp2_;
		GFile* _tmp3_;
		gchar* _tmp4_;
		const gchar* _tmp5_;
		_tmp2_ = files_file_get_location (file);
		_tmp3_ = _tmp2_;
		_tmp4_ = g_file_get_path (_tmp3_);
		path = _tmp4_;
		_tmp5_ = path;
		result = _tmp5_ != NULL;
		_g_free0 (path);
		return result;
	}
}

static gint
files_mime_actions_file_compare_by_mime_type (FilesFile* a,
                                              FilesFile* b)
{
	GCompareFunc _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	gint result;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = ((GCompareFunc) g_strcmp0);
	_tmp1_ = files_file_get_ftype (a);
	_tmp2_ = files_file_get_ftype (b);
	result = _tmp0_ (_tmp1_, _tmp2_);
	return result;
}

static gchar*
files_mime_actions_gof_get_parent_uri (FilesFile* file)
{
	gchar* _tmp0_ = NULL;
	GFile* _tmp1_;
	GFile* _tmp2_;
	gchar* result;
	g_return_val_if_fail (file != NULL, NULL);
	_tmp1_ = files_file_get_directory (file);
	_tmp2_ = _tmp1_;
	if (_tmp2_ != NULL) {
		GFile* _tmp3_;
		GFile* _tmp4_;
		gchar* _tmp5_;
		_tmp3_ = files_file_get_directory (file);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_file_get_uri (_tmp4_);
		_g_free0 (_tmp0_);
		_tmp0_ = _tmp5_;
	} else {
		_g_free0 (_tmp0_);
		_tmp0_ = NULL;
	}
	result = _tmp0_;
	return result;
}

static gint
files_mime_actions_file_compare_by_parent_uri (FilesFile* a,
                                               FilesFile* b)
{
	GCompareFunc _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gint _tmp5_;
	gint result;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = ((GCompareFunc) g_strcmp0);
	_tmp1_ = files_mime_actions_gof_get_parent_uri (a);
	_tmp2_ = _tmp1_;
	_tmp3_ = files_mime_actions_gof_get_parent_uri (b);
	_tmp4_ = _tmp3_;
	_tmp5_ = _tmp0_ (_tmp2_, _tmp4_);
	_g_free0 (_tmp4_);
	_g_free0 (_tmp2_);
	result = _tmp5_;
	return result;
}

static gint
files_mime_actions_application_compare_by_name (GAppInfo* a,
                                                GAppInfo* b)
{
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gint result;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = g_app_info_get_display_name (a);
	_tmp1_ = g_app_info_get_display_name (b);
	result = g_utf8_collate (_tmp0_, _tmp1_);
	return result;
}

static gint
files_mime_actions_application_compare_by_id (GAppInfo* a,
                                              GAppInfo* b)
{
	GCompareFunc _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	gint result;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = ((GCompareFunc) g_strcmp0);
	_tmp1_ = g_app_info_get_id (a);
	_tmp2_ = g_app_info_get_id (b);
	result = _tmp0_ (_tmp1_, _tmp2_);
	return result;
}

static GList*
files_mime_actions_filter_non_uri_apps (GList* apps)
{
	GList* uri_apps = NULL;
	GList* result;
	uri_apps = NULL;
	{
		GList* app_collection = NULL;
		GList* app_it = NULL;
		app_collection = apps;
		for (app_it = app_collection; app_it != NULL; app_it = app_it->next) {
			GAppInfo* _tmp0_;
			GAppInfo* app = NULL;
			_tmp0_ = _g_object_ref0 ((GAppInfo*) app_it->data);
			app = _tmp0_;
			{
				GAppInfo* _tmp1_;
				_tmp1_ = app;
				if (g_app_info_supports_uris (_tmp1_)) {
					GAppInfo* _tmp2_;
					GAppInfo* _tmp3_;
					_tmp2_ = app;
					_tmp3_ = _g_object_ref0 (_tmp2_);
					uri_apps = g_list_append (uri_apps, _tmp3_);
				}
				_g_object_unref0 (app);
			}
		}
	}
	result = uri_apps;
	return result;
}

static GList*
files_mime_actions_intersect_application_lists (GList* a,
                                                GList* b)
{
	GList* _result_ = NULL;
	GList* iterator_a = NULL;
	GList* iterator_b = NULL;
	GList* result;
	_result_ = NULL;
	iterator_a = a;
	iterator_b = b;
	while (TRUE) {
		gboolean _tmp0_ = FALSE;
		GList* _tmp1_;
		GAppInfo* app_a = NULL;
		GList* _tmp3_;
		gconstpointer _tmp4_;
		GAppInfo* _tmp5_;
		GAppInfo* app_b = NULL;
		GList* _tmp6_;
		gconstpointer _tmp7_;
		GAppInfo* _tmp8_;
		gint cmp = 0;
		GAppInfo* _tmp9_;
		GAppInfo* _tmp10_;
		_tmp1_ = iterator_a;
		if (_tmp1_ != NULL) {
			GList* _tmp2_;
			_tmp2_ = iterator_b;
			_tmp0_ = _tmp2_ != NULL;
		} else {
			_tmp0_ = FALSE;
		}
		if (!_tmp0_) {
			break;
		}
		_tmp3_ = iterator_a;
		_tmp4_ = _tmp3_->data;
		_tmp5_ = _g_object_ref0 ((GAppInfo*) _tmp4_);
		app_a = _tmp5_;
		_tmp6_ = iterator_b;
		_tmp7_ = _tmp6_->data;
		_tmp8_ = _g_object_ref0 ((GAppInfo*) _tmp7_);
		app_b = _tmp8_;
		_tmp9_ = app_a;
		_tmp10_ = app_b;
		cmp = files_mime_actions_application_compare_by_id (_tmp9_, _tmp10_);
		if (cmp > 0) {
			GList* _tmp11_;
			GList* _tmp12_;
			_tmp11_ = iterator_b;
			_tmp12_ = _tmp11_->next;
			iterator_b = _tmp12_;
		} else {
			if (cmp < 0) {
				GList* _tmp13_;
				GList* _tmp14_;
				_tmp13_ = iterator_a;
				_tmp14_ = _tmp13_->next;
				iterator_a = _tmp14_;
			} else {
				GAppInfo* _tmp15_;
				GAppInfo* _tmp16_;
				GList* _tmp17_;
				GList* _tmp18_;
				GList* _tmp19_;
				GList* _tmp20_;
				_tmp15_ = app_a;
				_tmp16_ = _g_object_ref0 (_tmp15_);
				_result_ = g_list_append (_result_, _tmp16_);
				_tmp17_ = iterator_a;
				_tmp18_ = _tmp17_->next;
				iterator_a = _tmp18_;
				_tmp19_ = iterator_b;
				_tmp20_ = _tmp19_->next;
				iterator_b = _tmp20_;
			}
		}
		_g_object_unref0 (app_b);
		_g_object_unref0 (app_a);
	}
	result = _result_;
	return result;
}

GAppInfo*
files_mime_actions_get_default_application_for_glib_file (GFile* file)
{
	FilesFile* _tmp0_;
	FilesFile* _tmp1_;
	GAppInfo* _tmp2_;
	GAppInfo* _tmp3_;
	GAppInfo* result;
	g_return_val_if_fail (file != NULL, NULL);
	_tmp0_ = files_file_get (file);
	_tmp1_ = _tmp0_;
	_tmp2_ = files_mime_actions_get_default_application_for_file (_tmp1_);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (_tmp1_);
	result = _tmp3_;
	return result;
}

void
files_mime_actions_open_glib_file_request (GFile* file_to_open,
                                           GtkWidget* parent,
                                           GAppInfo* app)
{
	g_return_if_fail (file_to_open != NULL);
	g_return_if_fail (parent != NULL);
	if (app == NULL) {
		GAppInfo* choice = NULL;
		GAppInfo* _tmp0_;
		GAppInfo* _tmp1_;
		_tmp0_ = files_mime_actions_choose_app_for_glib_file (file_to_open, parent);
		choice = _tmp0_;
		_tmp1_ = choice;
		if (_tmp1_ != NULL) {
			GAppInfo* _tmp2_;
			_tmp2_ = choice;
			files_mime_actions_launch_glib_file_with_app (file_to_open, parent, _tmp2_);
		}
		_g_object_unref0 (choice);
	} else {
		files_mime_actions_launch_glib_file_with_app (file_to_open, parent, app);
	}
}

void
files_mime_actions_open_multiple_gof_files_request (GList* gofs_to_open,
                                                    GtkWidget* parent,
                                                    GAppInfo* app)
{
	GAppInfo* app_info = NULL;
	GAppInfo* _tmp2_;
	g_return_if_fail (parent != NULL);
	app_info = NULL;
	if (app == NULL) {
		GAppInfo* _tmp0_;
		_tmp0_ = files_mime_actions_get_default_application_for_files (gofs_to_open);
		_g_object_unref0 (app_info);
		app_info = _tmp0_;
	} else {
		GAppInfo* _tmp1_;
		_tmp1_ = _g_object_ref0 (app);
		_g_object_unref0 (app_info);
		app_info = _tmp1_;
	}
	_tmp2_ = app_info;
	if (_tmp2_ == NULL) {
		GtkWindow* _tmp3_;
		GtkWindow* _tmp4_;
		GraniteMessageDialog* _tmp5_;
		GraniteMessageDialog* _tmp6_;
		_tmp3_ = files_get_active_window ();
		_tmp4_ = _tmp3_;
		_tmp5_ = pf_dialogs_show_error_dialog (_ ("Multiple file types selected"), _ ("No single app can open all these types of file"), _tmp4_);
		_tmp6_ = _tmp5_;
		_g_object_unref0 (_tmp6_);
		_g_object_unref0 (_tmp4_);
	} else {
		GList* files_to_open = NULL;
		GList* _tmp12_;
		GAppInfo* _tmp13_;
		GtkWindow* _tmp14_;
		GtkWindow* _tmp15_;
		files_to_open = NULL;
		{
			GList* gof_collection = NULL;
			GList* gof_it = NULL;
			gof_collection = gofs_to_open;
			for (gof_it = gof_collection; gof_it != NULL; gof_it = gof_it->next) {
				FilesFile* _tmp7_;
				FilesFile* gof = NULL;
				_tmp7_ = _g_object_ref0 ((FilesFile*) gof_it->data);
				gof = _tmp7_;
				{
					FilesFile* _tmp8_;
					GFile* _tmp9_;
					GFile* _tmp10_;
					GFile* _tmp11_;
					_tmp8_ = gof;
					_tmp9_ = files_file_get_location (_tmp8_);
					_tmp10_ = _tmp9_;
					_tmp11_ = _g_object_ref0 (_tmp10_);
					files_to_open = g_list_append (files_to_open, _tmp11_);
					_g_object_unref0 (gof);
				}
			}
		}
		_tmp12_ = files_to_open;
		_tmp13_ = app_info;
		_tmp14_ = files_get_active_window ();
		_tmp15_ = _tmp14_;
		files_mime_actions_launch_with_app (_tmp12_, _tmp13_, _tmp15_);
		_g_object_unref0 (_tmp15_);
		(files_to_open == NULL) ? NULL : (files_to_open = (_g_list_free__g_object_unref0_ (files_to_open), NULL));
	}
	_g_object_unref0 (app_info);
}

GAppInfo*
files_mime_actions_choose_app_for_glib_file (GFile* file_to_open,
                                             GtkWidget* parent)
{
	PFChooseAppDialog* chooser = NULL;
	GtkWindow* _tmp0_;
	GtkWindow* _tmp1_;
	PFChooseAppDialog* _tmp2_;
	PFChooseAppDialog* _tmp3_;
	GAppInfo* _tmp4_;
	GAppInfo* result;
	g_return_val_if_fail (file_to_open != NULL, NULL);
	g_return_val_if_fail (parent != NULL, NULL);
	_tmp0_ = files_get_active_window ();
	_tmp1_ = _tmp0_;
	_tmp2_ = pf_choose_app_dialog_new (_tmp1_, file_to_open);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (_tmp1_);
	chooser = _tmp3_;
	_tmp4_ = pf_choose_app_dialog_get_app_info (chooser);
	result = _tmp4_;
	_g_object_unref0 (chooser);
	return result;
}

static void
files_mime_actions_launch_glib_file_with_app (GFile* file_to_open,
                                              GtkWidget* parent,
                                              GAppInfo* app)
{
	GList* files_to_open = NULL;
	GFile* _tmp0_;
	GtkWindow* _tmp1_;
	GtkWindow* _tmp2_;
	g_return_if_fail (file_to_open != NULL);
	g_return_if_fail (parent != NULL);
	g_return_if_fail (app != NULL);
	files_to_open = NULL;
	_tmp0_ = _g_object_ref0 (file_to_open);
	files_to_open = g_list_append (files_to_open, _tmp0_);
	_tmp1_ = files_get_active_window ();
	_tmp2_ = _tmp1_;
	files_mime_actions_launch_with_app (files_to_open, app, _tmp2_);
	_g_object_unref0 (_tmp2_);
	(files_to_open == NULL) ? NULL : (files_to_open = (_g_list_free__g_object_unref0_ (files_to_open), NULL));
}

static void
_g_free0_ (gpointer var)
{
	var = (g_free (var), NULL);
}

static inline void
_g_list_free__g_free0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_free0_);
}

static void
files_mime_actions_launch_with_app (GList* files_to_open,
                                    GAppInfo* app,
                                    GtkWindow* win)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (app != NULL);
	if (g_app_info_supports_files (app)) {
		{
			g_app_info_launch (app, files_to_open, NULL, &_inner_error0_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				goto __catch0_g_error;
			}
		}
		goto __finally0;
		__catch0_g_error:
		{
			GError* e = NULL;
			GError* _tmp0_;
			const gchar* _tmp1_;
			GraniteMessageDialog* _tmp2_;
			GraniteMessageDialog* _tmp3_;
			e = _inner_error0_;
			_inner_error0_ = NULL;
			_tmp0_ = e;
			_tmp1_ = _tmp0_->message;
			_tmp2_ = pf_dialogs_show_error_dialog (_ ("Failed to open files"), _tmp1_, win);
			_tmp3_ = _tmp2_;
			_g_object_unref0 (_tmp3_);
			_g_error_free0 (e);
		}
		__finally0:
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	} else {
		if (g_app_info_supports_uris (app)) {
			GList* uris = NULL;
			uris = NULL;
			{
				GList* file_collection = NULL;
				GList* file_it = NULL;
				file_collection = files_to_open;
				for (file_it = file_collection; file_it != NULL; file_it = file_it->next) {
					GFile* _tmp4_;
					GFile* file = NULL;
					_tmp4_ = _g_object_ref0 ((GFile*) file_it->data);
					file = _tmp4_;
					{
						GFile* _tmp5_;
						gchar* _tmp6_;
						_tmp5_ = file;
						_tmp6_ = g_file_get_uri (_tmp5_);
						uris = g_list_append (uris, _tmp6_);
						_g_object_unref0 (file);
					}
				}
			}
			{
				GList* _tmp7_;
				_tmp7_ = uris;
				g_app_info_launch_uris (app, _tmp7_, NULL, &_inner_error0_);
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					goto __catch1_g_error;
				}
			}
			goto __finally1;
			__catch1_g_error:
			{
				GError* e = NULL;
				GError* _tmp8_;
				const gchar* _tmp9_;
				GraniteMessageDialog* _tmp10_;
				GraniteMessageDialog* _tmp11_;
				e = _inner_error0_;
				_inner_error0_ = NULL;
				_tmp8_ = e;
				_tmp9_ = _tmp8_->message;
				_tmp10_ = pf_dialogs_show_error_dialog (_ ("Could not open URIs"), _tmp9_, win);
				_tmp11_ = _tmp10_;
				_g_object_unref0 (_tmp11_);
				_g_error_free0 (e);
			}
			__finally1:
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				(uris == NULL) ? NULL : (uris = (_g_list_free__g_free0_ (uris), NULL));
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
			(uris == NULL) ? NULL : (uris = (_g_list_free__g_free0_ (uris), NULL));
		} else {
			GraniteMessageDialog* _tmp12_;
			GraniteMessageDialog* _tmp13_;
			_tmp12_ = pf_dialogs_show_error_dialog (_ ("Could not open files or URIs with this app"), "", win);
			_tmp13_ = _tmp12_;
			_g_object_unref0 (_tmp13_);
		}
	}
}

FilesMimeActions*
files_mime_actions_construct (GType object_type)
{
	FilesMimeActions* self = NULL;
	self = (FilesMimeActions*) g_type_create_instance (object_type);
	return self;
}

FilesMimeActions*
files_mime_actions_new (void)
{
	return files_mime_actions_construct (FILES_TYPE_MIME_ACTIONS);
}

static void
files_value_mime_actions_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
files_value_mime_actions_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		files_mime_actions_unref (value->data[0].v_pointer);
	}
}

static void
files_value_mime_actions_copy_value (const GValue* src_value,
                                     GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = files_mime_actions_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
files_value_mime_actions_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
files_value_mime_actions_collect_value (GValue* value,
                                        guint n_collect_values,
                                        GTypeCValue* collect_values,
                                        guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		FilesMimeActions * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = files_mime_actions_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
files_value_mime_actions_lcopy_value (const GValue* value,
                                      guint n_collect_values,
                                      GTypeCValue* collect_values,
                                      guint collect_flags)
{
	FilesMimeActions ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = files_mime_actions_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
files_param_spec_mime_actions (const gchar* name,
                               const gchar* nick,
                               const gchar* blurb,
                               GType object_type,
                               GParamFlags flags)
{
	FilesParamSpecMimeActions* spec;
	g_return_val_if_fail (g_type_is_a (object_type, FILES_TYPE_MIME_ACTIONS), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
files_value_get_mime_actions (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, FILES_TYPE_MIME_ACTIONS), NULL);
	return value->data[0].v_pointer;
}

void
files_value_set_mime_actions (GValue* value,
                              gpointer v_object)
{
	FilesMimeActions * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, FILES_TYPE_MIME_ACTIONS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, FILES_TYPE_MIME_ACTIONS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		files_mime_actions_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		files_mime_actions_unref (old);
	}
}

void
files_value_take_mime_actions (GValue* value,
                               gpointer v_object)
{
	FilesMimeActions * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, FILES_TYPE_MIME_ACTIONS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, FILES_TYPE_MIME_ACTIONS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		files_mime_actions_unref (old);
	}
}

static void
files_mime_actions_class_init (FilesMimeActionsClass * klass,
                               gpointer klass_data)
{
	files_mime_actions_parent_class = g_type_class_peek_parent (klass);
	((FilesMimeActionsClass *) klass)->finalize = files_mime_actions_finalize;
}

static void
files_mime_actions_instance_init (FilesMimeActions * self,
                                  gpointer klass)
{
	self->ref_count = 1;
}

static void
files_mime_actions_finalize (FilesMimeActions * obj)
{
	FilesMimeActions * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_TYPE_MIME_ACTIONS, FilesMimeActions);
	g_signal_handlers_destroy (self);
}

/***
    Copyright (c) 2000 Eazel, Inc.
    Copyright (c) 2011 ammonkey <am.monkeyd@gmail.com>
    Copyright (c) 2013-2018 elementary LLC <https://elementary.io>

    This program is free software: you can redistribute it and/or modify it
    under the terms of the GNU Lesser General Public License version 3, as published
    by the Free Software Foundation.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranties of
    MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
    PURPOSE. See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program. If not, see <http://www.gnu.org/licenses/>.

    Authors: Maciej Stachowiak <mjs@eazel.com>
             ammonkey <am.monkeyd@gmail.com>
             Julián Unrrein <junrrein@gmail.com>
***/
static GType
files_mime_actions_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { files_value_mime_actions_init, files_value_mime_actions_free_value, files_value_mime_actions_copy_value, files_value_mime_actions_peek_pointer, "p", files_value_mime_actions_collect_value, "p", files_value_mime_actions_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (FilesMimeActionsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) files_mime_actions_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FilesMimeActions), 0, (GInstanceInitFunc) files_mime_actions_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType files_mime_actions_type_id;
	files_mime_actions_type_id = g_type_register_fundamental (g_type_fundamental_next (), "FilesMimeActions", &g_define_type_info, &g_define_type_fundamental_info, 0);
	return files_mime_actions_type_id;
}

GType
files_mime_actions_get_type (void)
{
	static volatile gsize files_mime_actions_type_id__once = 0;
	if (g_once_init_enter (&files_mime_actions_type_id__once)) {
		GType files_mime_actions_type_id;
		files_mime_actions_type_id = files_mime_actions_get_type_once ();
		g_once_init_leave (&files_mime_actions_type_id__once, files_mime_actions_type_id);
	}
	return files_mime_actions_type_id__once;
}

gpointer
files_mime_actions_ref (gpointer instance)
{
	FilesMimeActions * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
files_mime_actions_unref (gpointer instance)
{
	FilesMimeActions * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		FILES_MIME_ACTIONS_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

