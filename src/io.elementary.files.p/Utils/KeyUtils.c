/* KeyUtils.c generated by valac 0.56.3, the Vala compiler
 * generated from KeyUtils.vala, do not modify */

#include <gdk/gdk.h>
#include <glib.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

VALA_EXTERN guint key_utils_map_key (GdkEventKey* event,
                         GdkModifierType* consumed_mods);
VALA_EXTERN gboolean key_utils_match_keycode (GdkKeymap* keymap,
                                  guint keyval,
                                  guint code,
                                  gint level);

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

guint
key_utils_map_key (GdkEventKey* event,
                   GdkModifierType* consumed_mods)
{
	GdkModifierType _vala_consumed_mods = 0U;
	guint original_keyval = 0U;
	guint keyval = 0U;
	guint _tmp0_ = 0U;
	guint result;
	g_return_val_if_fail (event != NULL, 0U);
	gdk_event_get_keyval ((GdkEvent*) event, &_tmp0_);
	original_keyval = _tmp0_;
	keyval = original_keyval;
	_vala_consumed_mods = 0;
	if (keyval > ((guint) 127)) {
		gint eff_grp = 0;
		gint level = 0;
		GdkDisplay* display = NULL;
		GdkDevice* _tmp1_;
		GdkDisplay* _tmp2_;
		GdkDisplay* _tmp3_;
		GdkKeymap* keymap = NULL;
		GdkDisplay* _tmp4_;
		GdkKeymap* _tmp5_;
		GdkKeymap* _tmp6_;
		GdkKeymap* _tmp7_;
		guint _tmp8_ = 0U;
		gint _tmp9_ = 0;
		gint _tmp10_ = 0;
		GdkModifierType _tmp11_ = 0U;
		gboolean _tmp12_;
		_tmp1_ = gdk_event_get_device ((GdkEvent*) event);
		_tmp2_ = gdk_device_get_display (_tmp1_);
		_tmp3_ = _g_object_ref0 (_tmp2_);
		display = _tmp3_;
		_tmp4_ = display;
		_tmp5_ = gdk_keymap_get_for_display (_tmp4_);
		_tmp6_ = _g_object_ref0 (_tmp5_);
		keymap = _tmp6_;
		_tmp7_ = keymap;
		_tmp12_ = gdk_keymap_translate_keyboard_state (_tmp7_, (guint) event->hardware_keycode, event->state, (gint) event->group, &_tmp8_, &_tmp9_, &_tmp10_, &_tmp11_);
		keyval = _tmp8_;
		eff_grp = _tmp9_;
		level = _tmp10_;
		_vala_consumed_mods = _tmp11_;
		if (!_tmp12_) {
			g_warning ("KeyUtils.vala:43: translate keyboard state failed");
			keyval = original_keyval;
			_vala_consumed_mods = 0;
		} else {
			keyval = (guint) 0;
			{
				guint key = 0U;
				key = (guint) 32;
				{
					gboolean _tmp13_ = FALSE;
					_tmp13_ = TRUE;
					while (TRUE) {
						GdkKeymap* _tmp15_;
						if (!_tmp13_) {
							guint _tmp14_;
							_tmp14_ = key;
							key = _tmp14_ + 1;
						}
						_tmp13_ = FALSE;
						if (!(key < ((guint) 128))) {
							break;
						}
						_tmp15_ = keymap;
						if (key_utils_match_keycode (_tmp15_, key, (guint) event->hardware_keycode, level)) {
							keyval = key;
							break;
						}
					}
				}
			}
			if (keyval == ((guint) 0)) {
				g_debug ("KeyUtils.vala:56: Could not match hardware code to ASCII hotkey");
				keyval = original_keyval;
				_vala_consumed_mods = 0;
			}
		}
		_g_object_unref0 (keymap);
		_g_object_unref0 (display);
	}
	result = keyval;
	if (consumed_mods) {
		*consumed_mods = _vala_consumed_mods;
	}
	return result;
}

/** Returns true if the code parameter matches the keycode of the keyval parameter for
      * any keyboard group or level (in order to allow for non-QWERTY keyboards) **/
gboolean
key_utils_match_keycode (GdkKeymap* keymap,
                         guint keyval,
                         guint code,
                         gint level)
{
	GdkKeymapKey* keys = NULL;
	gint keys_length1 = 0;
	gint _keys_size_ = 0;
	GdkKeymapKey* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gboolean _tmp2_;
	gboolean result;
	g_return_val_if_fail (keymap != NULL, FALSE);
	_tmp2_ = gdk_keymap_get_entries_for_keyval (keymap, keyval, &_tmp0_, &_tmp1_);
	keys = (g_free (keys), NULL);
	keys = _tmp0_;
	keys_length1 = _tmp1_;
	_keys_size_ = keys_length1;
	if (_tmp2_) {
		GdkKeymapKey* _tmp3_;
		gint _tmp3__length1;
		_tmp3_ = keys;
		_tmp3__length1 = keys_length1;
		{
			GdkKeymapKey* key_collection = NULL;
			gint key_collection_length1 = 0;
			gint _key_collection_size_ = 0;
			gint key_it = 0;
			key_collection = _tmp3_;
			key_collection_length1 = _tmp3__length1;
			for (key_it = 0; key_it < key_collection_length1; key_it = key_it + 1) {
				GdkKeymapKey key = {0};
				key = key_collection[key_it];
				{
					gboolean _tmp4_ = FALSE;
					GdkKeymapKey _tmp5_;
					_tmp5_ = key;
					if (code == _tmp5_.keycode) {
						GdkKeymapKey _tmp6_;
						_tmp6_ = key;
						_tmp4_ = level == _tmp6_.level;
					} else {
						_tmp4_ = FALSE;
					}
					if (_tmp4_) {
						result = TRUE;
						keys = (g_free (keys), NULL);
						return result;
					}
				}
			}
		}
	}
	result = FALSE;
	keys = (g_free (keys), NULL);
	return result;
}

