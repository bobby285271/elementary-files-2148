/* FileManager1.c generated by valac 0.56.3, the Vala compiler
 * generated from FileManager1.vala, do not modify */

#include <glib-object.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_FILE_MANAGER1 (file_manager1_get_type ())
#define FILE_MANAGER1(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FILE_MANAGER1, FileManager1))
#define FILE_MANAGER1_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FILE_MANAGER1, FileManager1Class))
#define IS_FILE_MANAGER1(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FILE_MANAGER1))
#define IS_FILE_MANAGER1_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FILE_MANAGER1))
#define FILE_MANAGER1_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FILE_MANAGER1, FileManager1Class))

typedef struct _FileManager1 FileManager1;
typedef struct _FileManager1Class FileManager1Class;
typedef struct _FileManager1Private FileManager1Private;
enum  {
	FILE_MANAGER1_0_PROPERTY,
	FILE_MANAGER1_NUM_PROPERTIES
};
static GParamSpec* file_manager1_properties[FILE_MANAGER1_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

struct _FileManager1 {
	GObject parent_instance;
	FileManager1Private * priv;
};

struct _FileManager1Class {
	GObjectClass parent_class;
};

static gpointer file_manager1_parent_class = NULL;
static gchar* file_manager1_reserved_chars;
static gchar* file_manager1_reserved_chars = NULL;

VALA_EXTERN GType file_manager1_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FileManager1, g_object_unref)
VALA_EXTERN guint file_manager1_register_object (void* object,
                                     GDBusConnection* connection,
                                     const gchar* path,
                                     GError** error);
VALA_EXTERN void file_manager1_show_folders (FileManager1* self,
                                 gchar** uris,
                                 gint uris_length1,
                                 const gchar* startup_id,
                                 GError** error);
static void file_manager1_open_items_and_folders (FileManager1* self,
                                           gchar** uris,
                                           gint uris_length1,
                                           const gchar* startup_id,
                                           GError** error);
VALA_EXTERN void file_manager1_show_items (FileManager1* self,
                               gchar** uris,
                               gint uris_length1,
                               const gchar* startup_id,
                               GError** error);
VALA_EXTERN void file_manager1_show_item_properties (FileManager1* self,
                                         gchar** uris,
                                         gint uris_length1,
                                         const gchar* startup_id,
                                         GError** error);
static gchar* file_manager1_prepare_uri_for_appinfo_create (const gchar* uri,
                                                     gboolean allow_utf8);
VALA_EXTERN FileManager1* file_manager1_new (void);
VALA_EXTERN FileManager1* file_manager1_construct (GType object_type);
static void file_manager1_finalize (GObject * obj);
static GType file_manager1_get_type_once (void);
static void _dbus_file_manager1_show_folders (FileManager1* self,
                                       GVariant* _parameters_,
                                       GDBusMethodInvocation* invocation);
static void _dbus_file_manager1_show_items (FileManager1* self,
                                     GVariant* _parameters_,
                                     GDBusMethodInvocation* invocation);
static void _dbus_file_manager1_show_item_properties (FileManager1* self,
                                               GVariant* _parameters_,
                                               GDBusMethodInvocation* invocation);
static void file_manager1_dbus_interface_method_call (GDBusConnection* connection,
                                               const gchar* sender,
                                               const gchar* object_path,
                                               const gchar* interface_name,
                                               const gchar* method_name,
                                               GVariant* parameters,
                                               GDBusMethodInvocation* invocation,
                                               gpointer user_data);
static GVariant* file_manager1_dbus_interface_get_property (GDBusConnection* connection,
                                                     const gchar* sender,
                                                     const gchar* object_path,
                                                     const gchar* interface_name,
                                                     const gchar* property_name,
                                                     GError** error,
                                                     gpointer user_data);
static gboolean file_manager1_dbus_interface_set_property (GDBusConnection* connection,
                                                    const gchar* sender,
                                                    const gchar* object_path,
                                                    const gchar* interface_name,
                                                    const gchar* property_name,
                                                    GVariant* value,
                                                    GError** error,
                                                    gpointer user_data);
static void _file_manager1_unregister_object (gpointer user_data);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);

static const GDBusArgInfo _file_manager1_dbus_arg_info_show_folders_uris = {-1, "uris", "as", NULL};
static const GDBusArgInfo _file_manager1_dbus_arg_info_show_folders_startup_id = {-1, "startup_id", "s", NULL};
static const GDBusArgInfo * const _file_manager1_dbus_arg_info_show_folders_in[] = {&_file_manager1_dbus_arg_info_show_folders_uris, &_file_manager1_dbus_arg_info_show_folders_startup_id, NULL};
static const GDBusArgInfo * const _file_manager1_dbus_arg_info_show_folders_out[] = {NULL};
static const GDBusMethodInfo _file_manager1_dbus_method_info_show_folders = {-1, "ShowFolders", (GDBusArgInfo **) (&_file_manager1_dbus_arg_info_show_folders_in), (GDBusArgInfo **) (&_file_manager1_dbus_arg_info_show_folders_out), NULL};
static const GDBusArgInfo _file_manager1_dbus_arg_info_show_items_uris = {-1, "uris", "as", NULL};
static const GDBusArgInfo _file_manager1_dbus_arg_info_show_items_startup_id = {-1, "startup_id", "s", NULL};
static const GDBusArgInfo * const _file_manager1_dbus_arg_info_show_items_in[] = {&_file_manager1_dbus_arg_info_show_items_uris, &_file_manager1_dbus_arg_info_show_items_startup_id, NULL};
static const GDBusArgInfo * const _file_manager1_dbus_arg_info_show_items_out[] = {NULL};
static const GDBusMethodInfo _file_manager1_dbus_method_info_show_items = {-1, "ShowItems", (GDBusArgInfo **) (&_file_manager1_dbus_arg_info_show_items_in), (GDBusArgInfo **) (&_file_manager1_dbus_arg_info_show_items_out), NULL};
static const GDBusArgInfo _file_manager1_dbus_arg_info_show_item_properties_uris = {-1, "uris", "as", NULL};
static const GDBusArgInfo _file_manager1_dbus_arg_info_show_item_properties_startup_id = {-1, "startup_id", "s", NULL};
static const GDBusArgInfo * const _file_manager1_dbus_arg_info_show_item_properties_in[] = {&_file_manager1_dbus_arg_info_show_item_properties_uris, &_file_manager1_dbus_arg_info_show_item_properties_startup_id, NULL};
static const GDBusArgInfo * const _file_manager1_dbus_arg_info_show_item_properties_out[] = {NULL};
static const GDBusMethodInfo _file_manager1_dbus_method_info_show_item_properties = {-1, "ShowItemProperties", (GDBusArgInfo **) (&_file_manager1_dbus_arg_info_show_item_properties_in), (GDBusArgInfo **) (&_file_manager1_dbus_arg_info_show_item_properties_out), NULL};
static const GDBusMethodInfo * const _file_manager1_dbus_method_info[] = {&_file_manager1_dbus_method_info_show_folders, &_file_manager1_dbus_method_info_show_items, &_file_manager1_dbus_method_info_show_item_properties, NULL};
static const GDBusSignalInfo * const _file_manager1_dbus_signal_info[] = {NULL};
static const GDBusPropertyInfo * const _file_manager1_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _file_manager1_dbus_interface_info = {-1, "org.freedesktop.FileManager1", (GDBusMethodInfo **) (&_file_manager1_dbus_method_info), (GDBusSignalInfo **) (&_file_manager1_dbus_signal_info), (GDBusPropertyInfo **) (&_file_manager1_dbus_property_info), NULL};
static const GDBusInterfaceVTable _file_manager1_dbus_interface_vtable = {file_manager1_dbus_interface_method_call, file_manager1_dbus_interface_get_property, file_manager1_dbus_interface_set_property};

static gchar*
string_replace (const gchar* self,
                const gchar* old,
                const gchar* replacement)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GError* _inner_error0_ = NULL;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	if ((*((gchar*) self)) == '\0') {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = (*((gchar*) old)) == '\0';
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_strcmp0 (old, replacement) == 0;
	}
	if (_tmp0_) {
		gchar* _tmp2_;
		_tmp2_ = g_strdup (self);
		result = _tmp2_;
		return result;
	}
	{
		GRegex* regex = NULL;
		gchar* _tmp3_;
		gchar* _tmp4_;
		GRegex* _tmp5_;
		GRegex* _tmp6_;
		gchar* _tmp7_ = NULL;
		GRegex* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		_tmp3_ = g_regex_escape_string (old, -1);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_regex_new (_tmp4_, 0, 0, &_inner_error0_);
		_tmp6_ = _tmp5_;
		_g_free0 (_tmp4_);
		regex = _tmp6_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return NULL;
		}
		_tmp8_ = regex;
		_tmp9_ = g_regex_replace_literal (_tmp8_, self, (gssize) -1, 0, replacement, 0, &_inner_error0_);
		_tmp7_ = _tmp9_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error0_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return NULL;
		}
		_tmp10_ = _tmp7_;
		_tmp7_ = NULL;
		result = _tmp10_;
		_g_free0 (_tmp7_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally0;
	__catch0_g_regex_error:
	{
		g_clear_error (&_inner_error0_);
		g_assert_not_reached ();
	}
	__finally0:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
	g_clear_error (&_inner_error0_);
	return NULL;
}

void
file_manager1_show_folders (FileManager1* self,
                            gchar** uris,
                            gint uris_length1,
                            const gchar* startup_id,
                            GError** error)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (startup_id != NULL);
	file_manager1_open_items_and_folders (self, uris, (gint) uris_length1, startup_id, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		if ((_inner_error0_->domain == G_DBUS_ERROR) || (_inner_error0_->domain == G_IO_ERROR)) {
			g_propagate_error (error, _inner_error0_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
}

void
file_manager1_show_items (FileManager1* self,
                          gchar** uris,
                          gint uris_length1,
                          const gchar* startup_id,
                          GError** error)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (startup_id != NULL);
	file_manager1_open_items_and_folders (self, uris, (gint) uris_length1, startup_id, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		if ((_inner_error0_->domain == G_DBUS_ERROR) || (_inner_error0_->domain == G_IO_ERROR)) {
			g_propagate_error (error, _inner_error0_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
}

void
file_manager1_show_item_properties (FileManager1* self,
                                    gchar** uris,
                                    gint uris_length1,
                                    const gchar* startup_id,
                                    GError** error)
{
	gchar* msg = NULL;
	gchar* _tmp0_;
	GError* _tmp1_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (startup_id != NULL);
	_tmp0_ = g_strdup ("ShowItemProperties method not currently supported by Files.");
	msg = _tmp0_;
	_tmp1_ = g_error_new_literal (G_DBUS_ERROR, G_DBUS_ERROR_NOT_SUPPORTED, msg);
	_inner_error0_ = _tmp1_;
	if ((_inner_error0_->domain == G_DBUS_ERROR) || (_inner_error0_->domain == G_IO_ERROR)) {
		g_propagate_error (error, _inner_error0_);
		_g_free0 (msg);
		return;
	} else {
		_g_free0 (msg);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

static void
file_manager1_open_items_and_folders (FileManager1* self,
                                      gchar** uris,
                                      gint uris_length1,
                                      const gchar* startup_id,
                                      GError** error)
{
	GString* sb = NULL;
	GString* _tmp0_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (startup_id != NULL);
	_tmp0_ = g_string_new ("io.elementary.files -t");
	sb = _tmp0_;
	{
		gchar** s_collection = NULL;
		gint s_collection_length1 = 0;
		gint _s_collection_size_ = 0;
		gint s_it = 0;
		s_collection = uris;
		s_collection_length1 = uris_length1;
		for (s_it = 0; s_it < s_collection_length1; s_it = s_it + 1) {
			gchar* _tmp1_;
			gchar* s = NULL;
			_tmp1_ = g_strdup (s_collection[s_it]);
			s = _tmp1_;
			{
				GString* _tmp2_;
				GString* _tmp3_;
				const gchar* _tmp4_;
				gchar* _tmp5_;
				gchar* _tmp6_;
				_tmp2_ = sb;
				g_string_append (_tmp2_, " ");
				_tmp3_ = sb;
				_tmp4_ = s;
				_tmp5_ = file_manager1_prepare_uri_for_appinfo_create (_tmp4_, TRUE);
				_tmp6_ = _tmp5_;
				g_string_append (_tmp3_, _tmp6_);
				_g_free0 (_tmp6_);
				_g_free0 (s);
			}
		}
	}
	{
		GAppInfo* pf_app_info = NULL;
		GString* _tmp7_;
		const gchar* _tmp8_;
		GAppInfo* _tmp9_;
		GAppInfo* _tmp10_;
		_tmp7_ = sb;
		_tmp8_ = _tmp7_->str;
		_tmp9_ = g_app_info_create_from_commandline (_tmp8_, NULL, G_APP_INFO_CREATE_NONE, &_inner_error0_);
		pf_app_info = _tmp9_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		_tmp10_ = pf_app_info;
		if (_tmp10_ != NULL) {
			GAppInfo* _tmp11_;
			_tmp11_ = pf_app_info;
			g_app_info_launch (_tmp11_, NULL, NULL, &_inner_error0_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				_g_object_unref0 (pf_app_info);
				goto __catch0_g_error;
			}
		}
		_g_object_unref0 (pf_app_info);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		gchar* msg = NULL;
		GString* _tmp12_;
		const gchar* _tmp13_;
		GError* _tmp14_;
		const gchar* _tmp15_;
		gchar* _tmp16_;
		const gchar* _tmp17_;
		GError* _tmp18_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp12_ = sb;
		_tmp13_ = _tmp12_->str;
		_tmp14_ = e;
		_tmp15_ = _tmp14_->message;
		_tmp16_ = g_strdup_printf ("Unable to open item or folder with command %s: %s", _tmp13_, _tmp15_);
		msg = _tmp16_;
		_tmp17_ = msg;
		_tmp18_ = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, _tmp17_);
		_inner_error0_ = _tmp18_;
		_g_free0 (msg);
		_g_error_free0 (e);
		goto __finally0;
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		if ((_inner_error0_->domain == G_DBUS_ERROR) || (_inner_error0_->domain == G_IO_ERROR)) {
			g_propagate_error (error, _inner_error0_);
			_g_string_free0 (sb);
			return;
		} else {
			_g_string_free0 (sb);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	_g_string_free0 (sb);
}

static gchar*
file_manager1_prepare_uri_for_appinfo_create (const gchar* uri,
                                              gboolean allow_utf8)
{
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* escaped_uri = NULL;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	const gchar* _tmp5_ = NULL;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* result;
	g_return_val_if_fail (uri != NULL, NULL);
	_tmp1_ = g_uri_unescape_string (uri, NULL);
	_tmp0_ = _tmp1_;
	if (_tmp0_ == NULL) {
		gchar* _tmp2_;
		_tmp2_ = g_strdup (uri);
		_g_free0 (_tmp0_);
		_tmp0_ = _tmp2_;
	}
	_tmp3_ = file_manager1_reserved_chars;
	_tmp4_ = g_uri_escape_string (_tmp0_, _tmp3_, allow_utf8);
	escaped_uri = _tmp4_;
	_tmp6_ = escaped_uri;
	_tmp5_ = _tmp6_;
	if (_tmp5_ == NULL) {
		_tmp5_ = "";
	}
	_tmp7_ = string_replace (_tmp5_, "%", "%%");
	result = _tmp7_;
	_g_free0 (escaped_uri);
	_g_free0 (_tmp0_);
	return result;
}

FileManager1*
file_manager1_construct (GType object_type)
{
	FileManager1 * self = NULL;
	self = (FileManager1*) g_object_new (object_type, NULL);
	return self;
}

FileManager1*
file_manager1_new (void)
{
	return file_manager1_construct (TYPE_FILE_MANAGER1);
}

static void
file_manager1_class_init (FileManager1Class * klass,
                          gpointer klass_data)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	file_manager1_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = file_manager1_finalize;
	_tmp0_ = string_replace (G_URI_RESERVED_CHARS_GENERIC_DELIMITERS G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS, "#", "");
	_tmp1_ = _tmp0_;
	_tmp2_ = string_replace (_tmp1_, "*", "");
	file_manager1_reserved_chars = _tmp2_;
}

static void
file_manager1_instance_init (FileManager1 * self,
                             gpointer klass)
{
}

static void
file_manager1_finalize (GObject * obj)
{
	FileManager1 * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FILE_MANAGER1, FileManager1);
	G_OBJECT_CLASS (file_manager1_parent_class)->finalize (obj);
}

/***
    Copyright (c) 2017 - 2018 elementary LLC.

    This program is free software: you can redistribute it and/or modify it
    under the terms of the GNU Lesser General Public License version 3, as published
    by the Free Software Foundation.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranties of
    MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
    PURPOSE. See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program. If not, see <http://www.gnu.org/licenses/>.

    Authors: Jeremy Wootten <jeremy@elementaryos.org>
***/
static GType
file_manager1_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FileManager1Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) file_manager1_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FileManager1), 0, (GInstanceInitFunc) file_manager1_instance_init, NULL };
	GType file_manager1_type_id;
	file_manager1_type_id = g_type_register_static (G_TYPE_OBJECT, "FileManager1", &g_define_type_info, 0);
	g_type_set_qdata (file_manager1_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) file_manager1_register_object);
	return file_manager1_type_id;
}

GType
file_manager1_get_type (void)
{
	static volatile gsize file_manager1_type_id__once = 0;
	if (g_once_init_enter (&file_manager1_type_id__once)) {
		GType file_manager1_type_id;
		file_manager1_type_id = file_manager1_get_type_once ();
		g_once_init_leave (&file_manager1_type_id__once, file_manager1_type_id);
	}
	return file_manager1_type_id__once;
}

static void
_dbus_file_manager1_show_folders (FileManager1* self,
                                  GVariant* _parameters_,
                                  GDBusMethodInvocation* invocation)
{
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar** uris = NULL;
	gint uris_length1 = 0;
	GVariant* _tmp0_;
	gchar** _tmp1_;
	gint _tmp1__length;
	gint _tmp1__size;
	gint _tmp1__length1;
	GVariantIter _tmp2_;
	GVariant* _tmp3_;
	gchar* startup_id = NULL;
	GVariant* _tmp4_;
	GDBusMessage* _reply_message = NULL;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	_tmp0_ = g_variant_iter_next_value (&_arguments_iter);
	_tmp1_ = g_new (gchar*, 5);
	_tmp1__length = 0;
	_tmp1__size = 4;
	_tmp1__length1 = 0;
	g_variant_iter_init (&_tmp2_, _tmp0_);
	for (; (_tmp3_ = g_variant_iter_next_value (&_tmp2_)) != NULL; _tmp1__length1++) {
		if (_tmp1__size == _tmp1__length) {
			_tmp1__size = 2 * _tmp1__size;
			_tmp1_ = g_renew (gchar*, _tmp1_, _tmp1__size + 1);
		}
		_tmp1_[_tmp1__length++] = g_variant_dup_string (_tmp3_, NULL);
		g_variant_unref (_tmp3_);
	}
	uris_length1 = _tmp1__length1;
	_tmp1_[_tmp1__length] = NULL;
	uris = _tmp1_;
	g_variant_unref (_tmp0_);
	_tmp4_ = g_variant_iter_next_value (&_arguments_iter);
	startup_id = g_variant_dup_string (_tmp4_, NULL);
	g_variant_unref (_tmp4_);
	file_manager1_show_folders (self, uris, uris_length1, startup_id, &error);
	if (error) {
		g_dbus_method_invocation_take_error (invocation, error);
		goto _error;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
	_error:
	uris = (_vala_array_free (uris, uris_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (startup_id);
	;
}

static void
_dbus_file_manager1_show_items (FileManager1* self,
                                GVariant* _parameters_,
                                GDBusMethodInvocation* invocation)
{
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar** uris = NULL;
	gint uris_length1 = 0;
	GVariant* _tmp5_;
	gchar** _tmp6_;
	gint _tmp6__length;
	gint _tmp6__size;
	gint _tmp6__length1;
	GVariantIter _tmp7_;
	GVariant* _tmp8_;
	gchar* startup_id = NULL;
	GVariant* _tmp9_;
	GDBusMessage* _reply_message = NULL;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	_tmp5_ = g_variant_iter_next_value (&_arguments_iter);
	_tmp6_ = g_new (gchar*, 5);
	_tmp6__length = 0;
	_tmp6__size = 4;
	_tmp6__length1 = 0;
	g_variant_iter_init (&_tmp7_, _tmp5_);
	for (; (_tmp8_ = g_variant_iter_next_value (&_tmp7_)) != NULL; _tmp6__length1++) {
		if (_tmp6__size == _tmp6__length) {
			_tmp6__size = 2 * _tmp6__size;
			_tmp6_ = g_renew (gchar*, _tmp6_, _tmp6__size + 1);
		}
		_tmp6_[_tmp6__length++] = g_variant_dup_string (_tmp8_, NULL);
		g_variant_unref (_tmp8_);
	}
	uris_length1 = _tmp6__length1;
	_tmp6_[_tmp6__length] = NULL;
	uris = _tmp6_;
	g_variant_unref (_tmp5_);
	_tmp9_ = g_variant_iter_next_value (&_arguments_iter);
	startup_id = g_variant_dup_string (_tmp9_, NULL);
	g_variant_unref (_tmp9_);
	file_manager1_show_items (self, uris, uris_length1, startup_id, &error);
	if (error) {
		g_dbus_method_invocation_take_error (invocation, error);
		goto _error;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
	_error:
	uris = (_vala_array_free (uris, uris_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (startup_id);
	;
}

static void
_dbus_file_manager1_show_item_properties (FileManager1* self,
                                          GVariant* _parameters_,
                                          GDBusMethodInvocation* invocation)
{
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar** uris = NULL;
	gint uris_length1 = 0;
	GVariant* _tmp10_;
	gchar** _tmp11_;
	gint _tmp11__length;
	gint _tmp11__size;
	gint _tmp11__length1;
	GVariantIter _tmp12_;
	GVariant* _tmp13_;
	gchar* startup_id = NULL;
	GVariant* _tmp14_;
	GDBusMessage* _reply_message = NULL;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	_tmp10_ = g_variant_iter_next_value (&_arguments_iter);
	_tmp11_ = g_new (gchar*, 5);
	_tmp11__length = 0;
	_tmp11__size = 4;
	_tmp11__length1 = 0;
	g_variant_iter_init (&_tmp12_, _tmp10_);
	for (; (_tmp13_ = g_variant_iter_next_value (&_tmp12_)) != NULL; _tmp11__length1++) {
		if (_tmp11__size == _tmp11__length) {
			_tmp11__size = 2 * _tmp11__size;
			_tmp11_ = g_renew (gchar*, _tmp11_, _tmp11__size + 1);
		}
		_tmp11_[_tmp11__length++] = g_variant_dup_string (_tmp13_, NULL);
		g_variant_unref (_tmp13_);
	}
	uris_length1 = _tmp11__length1;
	_tmp11_[_tmp11__length] = NULL;
	uris = _tmp11_;
	g_variant_unref (_tmp10_);
	_tmp14_ = g_variant_iter_next_value (&_arguments_iter);
	startup_id = g_variant_dup_string (_tmp14_, NULL);
	g_variant_unref (_tmp14_);
	file_manager1_show_item_properties (self, uris, uris_length1, startup_id, &error);
	if (error) {
		g_dbus_method_invocation_take_error (invocation, error);
		goto _error;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
	_error:
	uris = (_vala_array_free (uris, uris_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (startup_id);
	;
}

static void
file_manager1_dbus_interface_method_call (GDBusConnection* connection,
                                          const gchar* sender,
                                          const gchar* object_path,
                                          const gchar* interface_name,
                                          const gchar* method_name,
                                          GVariant* parameters,
                                          GDBusMethodInvocation* invocation,
                                          gpointer user_data)
{
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "ShowFolders") == 0) {
		_dbus_file_manager1_show_folders (object, parameters, invocation);
	} else if (strcmp (method_name, "ShowItems") == 0) {
		_dbus_file_manager1_show_items (object, parameters, invocation);
	} else if (strcmp (method_name, "ShowItemProperties") == 0) {
		_dbus_file_manager1_show_item_properties (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}

static GVariant*
file_manager1_dbus_interface_get_property (GDBusConnection* connection,
                                           const gchar* sender,
                                           const gchar* object_path,
                                           const gchar* interface_name,
                                           const gchar* property_name,
                                           GError** error,
                                           gpointer user_data)
{
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}

static gboolean
file_manager1_dbus_interface_set_property (GDBusConnection* connection,
                                           const gchar* sender,
                                           const gchar* object_path,
                                           const gchar* interface_name,
                                           const gchar* property_name,
                                           GVariant* value,
                                           GError** error,
                                           gpointer user_data)
{
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}

guint
file_manager1_register_object (gpointer object,
                               GDBusConnection* connection,
                               const gchar* path,
                               GError** error)
{
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_file_manager1_dbus_interface_info), &_file_manager1_dbus_interface_vtable, data, _file_manager1_unregister_object, error);
	if (!result) {
		return 0;
	}
	return result;
}

static void
_file_manager1_unregister_object (gpointer user_data)
{
	gpointer* data;
	data = user_data;
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

