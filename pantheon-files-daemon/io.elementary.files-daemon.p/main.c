/* main.c generated by valac 0.56.3, the Vala compiler
 * generated from main.vala, do not modify */

#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <glib-object.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_MARLIN_TAGS (marlin_tags_get_type ())
#define MARLIN_TAGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MARLIN_TAGS, MarlinTags))
#define MARLIN_TAGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MARLIN_TAGS, MarlinTagsClass))
#define IS_MARLIN_TAGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MARLIN_TAGS))
#define IS_MARLIN_TAGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MARLIN_TAGS))
#define MARLIN_TAGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MARLIN_TAGS, MarlinTagsClass))

typedef struct _MarlinTags MarlinTags;
typedef struct _MarlinTagsClass MarlinTagsClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_FILE_MANAGER1 (file_manager1_get_type ())
#define FILE_MANAGER1(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FILE_MANAGER1, FileManager1))
#define FILE_MANAGER1_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FILE_MANAGER1, FileManager1Class))
#define IS_FILE_MANAGER1(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FILE_MANAGER1))
#define IS_FILE_MANAGER1_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FILE_MANAGER1))
#define FILE_MANAGER1_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FILE_MANAGER1, FileManager1Class))

typedef struct _FileManager1 FileManager1;
typedef struct _FileManager1Class FileManager1Class;
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))

VALA_EXTERN void on_bus_aquired (GDBusConnection* conn,
                     const gchar* n);
VALA_EXTERN GType marlin_tags_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MarlinTags, g_object_unref)
VALA_EXTERN guint marlin_tags_register_object (void* object,
                                   GDBusConnection* connection,
                                   const gchar* path,
                                   GError** error);
VALA_EXTERN MarlinTags* marlin_tags_new (void);
VALA_EXTERN MarlinTags* marlin_tags_construct (GType object_type);
VALA_EXTERN void on_fm1_bus_aquired (GDBusConnection* conn,
                         const gchar* n);
VALA_EXTERN GType file_manager1_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FileManager1, g_object_unref)
VALA_EXTERN guint file_manager1_register_object (void* object,
                                     GDBusConnection* connection,
                                     const gchar* path,
                                     GError** error);
VALA_EXTERN FileManager1* file_manager1_new (void);
VALA_EXTERN FileManager1* file_manager1_construct (GType object_type);
void exit (gint exit_code);
VALA_EXTERN void on_name_lost (GDBusConnection* connection,
                   const gchar* name);
static void _vala_main (void);
static void _on_bus_aquired_gbus_acquired_callback (GDBusConnection* connection,
                                             const gchar* name,
                                             gpointer self);
static void __lambda4_ (void);
static void ___lambda4__gbus_name_acquired_callback (GDBusConnection* connection,
                                              const gchar* name,
                                              gpointer self);
static void _on_name_lost_gbus_name_lost_callback (GDBusConnection* connection,
                                            const gchar* name,
                                            gpointer self);
static void _on_fm1_bus_aquired_gbus_acquired_callback (GDBusConnection* connection,
                                                 const gchar* name,
                                                 gpointer self);
static void __lambda5_ (void);
static void ___lambda5__gbus_name_acquired_callback (GDBusConnection* connection,
                                              const gchar* name,
                                              gpointer self);

/***
    Copyright (C) 2010 Jordi Puigdellívol <jordi@gloobus.net>
    Copyright (c) 2017 - 2018 elementary LLC.

    This program is free software: you can redistribute it and/or modify it
    under the terms of the GNU Lesser General Public License version 3, as published
    by the Free Software Foundation.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranties of
    MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
    PURPOSE. See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program. If not, see <http://www.gnu.org/licenses/>.

    Authors: Jordi Puigdellívol <jordi@gloobus.net>
             ammonkey <am.monkeyd@gmail.com>
             Jeremy Wootten <jeremy@elementaryos.org>
***/
void
on_bus_aquired (GDBusConnection* conn,
                const gchar* n)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (conn != NULL);
	g_return_if_fail (n != NULL);
	{
		gchar* name = NULL;
		gchar* _tmp0_;
		MarlinTags* object = NULL;
		MarlinTags* _tmp1_;
		_tmp0_ = g_strdup ("/io/elementary/files/db");
		name = _tmp0_;
		_tmp1_ = marlin_tags_new ();
		object = _tmp1_;
		marlin_tags_register_object (object, conn, name, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (object);
			_g_free0 (name);
			if (_inner_error0_->domain == G_IO_ERROR) {
				goto __catch0_g_io_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
		g_debug ("main.vala:27: MarlinTags object registered with dbus connection name %" \
"s", name);
		_g_object_unref0 (object);
		_g_free0 (name);
	}
	goto __finally0;
	__catch0_g_io_error:
	{
		g_clear_error (&_inner_error0_);
		g_error ("main.vala:29: Could not register MarlinTags service");
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

void
on_fm1_bus_aquired (GDBusConnection* conn,
                    const gchar* n)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (conn != NULL);
	g_return_if_fail (n != NULL);
	{
		gchar* name = NULL;
		gchar* _tmp0_;
		FileManager1* object = NULL;
		FileManager1* _tmp1_;
		_tmp0_ = g_strdup ("/org/freedesktop/FileManager1");
		name = _tmp0_;
		_tmp1_ = file_manager1_new ();
		object = _tmp1_;
		file_manager1_register_object (object, conn, name, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (object);
			_g_free0 (name);
			if (_inner_error0_->domain == G_IO_ERROR) {
				goto __catch0_g_io_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
		g_debug ("main.vala:38: FileManager1 object registered with dbus connection name" \
" %s", name);
		_g_object_unref0 (object);
		_g_free0 (name);
	}
	goto __finally0;
	__catch0_g_io_error:
	{
		g_clear_error (&_inner_error0_);
		g_error ("main.vala:40: Could not register FileManager1 service");
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

void
on_name_lost (GDBusConnection* connection,
              const gchar* name)
{
	g_return_if_fail (connection != NULL);
	g_return_if_fail (name != NULL);
	g_critical ("main.vala:48: Name %s was not acquired", name);
	exit (-1);
}

static void
_on_bus_aquired_gbus_acquired_callback (GDBusConnection* connection,
                                        const gchar* name,
                                        gpointer self)
{
	on_bus_aquired (connection, name);
}

static void
__lambda4_ (void)
{
}

static void
___lambda4__gbus_name_acquired_callback (GDBusConnection* connection,
                                         const gchar* name,
                                         gpointer self)
{
	__lambda4_ ();
}

static void
_on_name_lost_gbus_name_lost_callback (GDBusConnection* connection,
                                       const gchar* name,
                                       gpointer self)
{
	on_name_lost (connection, name);
}

static void
_on_fm1_bus_aquired_gbus_acquired_callback (GDBusConnection* connection,
                                            const gchar* name,
                                            gpointer self)
{
	on_fm1_bus_aquired (connection, name);
}

static void
__lambda5_ (void)
{
}

static void
___lambda5__gbus_name_acquired_callback (GDBusConnection* connection,
                                         const gchar* name,
                                         gpointer self)
{
	__lambda5_ ();
}

static void
_vala_main (void)
{
	GMainLoop* _tmp0_;
	GMainLoop* _tmp1_;
	g_bus_own_name_with_closures (G_BUS_TYPE_SESSION, "io.elementary.files.db", G_BUS_NAME_OWNER_FLAGS_NONE, (GClosure*) g_cclosure_new ((GCallback) _on_bus_aquired_gbus_acquired_callback, NULL, (GClosureNotify) NULL), (GClosure*) ((___lambda4__gbus_name_acquired_callback == NULL) ? NULL : g_cclosure_new ((GCallback) ___lambda4__gbus_name_acquired_callback, NULL, (GClosureNotify) NULL)), (GClosure*) g_cclosure_new ((GCallback) _on_name_lost_gbus_name_lost_callback, NULL, (GClosureNotify) NULL));
	g_bus_own_name_with_closures (G_BUS_TYPE_SESSION, "org.freedesktop.FileManager1", G_BUS_NAME_OWNER_FLAGS_REPLACE, (GClosure*) g_cclosure_new ((GCallback) _on_fm1_bus_aquired_gbus_acquired_callback, NULL, (GClosureNotify) NULL), (GClosure*) ((___lambda5__gbus_name_acquired_callback == NULL) ? NULL : g_cclosure_new ((GCallback) ___lambda5__gbus_name_acquired_callback, NULL, (GClosureNotify) NULL)), (GClosure*) g_cclosure_new ((GCallback) _on_name_lost_gbus_name_lost_callback, NULL, (GClosureNotify) NULL));
	_tmp0_ = g_main_loop_new (NULL, FALSE);
	_tmp1_ = _tmp0_;
	g_main_loop_run (_tmp1_);
	_g_main_loop_unref0 (_tmp1_);
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

