/* plugin.c generated by valac 0.56.3, the Vala compiler
 * generated from plugin.vala, do not modify */

#include <glib-object.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include "pantheon-files-ctags.h"
#include "pantheon-files-core.h"
#include <gtk/gtk.h>
#include <stdio.h>
#include <granite.h>
#include <gee.h>
#include <gdk/gdk.h>
#include <float.h>
#include <math.h>

#define FILES_PLUGINS_CTAGS_COLOR_WIDGET_COLORBOX_SPACING 3

#define TYPE_MARLIN_DAEMON (marlin_daemon_get_type ())
#define MARLIN_DAEMON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MARLIN_DAEMON, MarlinDaemon))
#define IS_MARLIN_DAEMON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MARLIN_DAEMON))
#define MARLIN_DAEMON_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MARLIN_DAEMON, MarlinDaemonIface))

typedef struct _MarlinDaemon MarlinDaemon;
typedef struct _MarlinDaemonIface MarlinDaemonIface;

#define TYPE_MARLIN_DAEMON_PROXY (marlin_daemon_proxy_get_type ())
typedef GDBusProxy MarlinDaemonProxy;
typedef GDBusProxyClass MarlinDaemonProxyClass;
typedef struct _MarlinDaemonGetUriInfosReadyData MarlinDaemonGetUriInfosReadyData;
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _MarlinDaemonRecordUrisReadyData MarlinDaemonRecordUrisReadyData;
typedef struct _MarlinDaemonDeleteEntryReadyData MarlinDaemonDeleteEntryReadyData;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _files_plugins_base_unref0(var) ((var == NULL) ? NULL : (var = (files_plugins_base_unref (var), NULL)))
#define _g_ptr_array_unref0(var) ((var == NULL) ? NULL : (var = (g_ptr_array_unref (var), NULL)))
typedef struct _FilesPluginsCtagsConsumeKnownsQueueData FilesPluginsCtagsConsumeKnownsQueueData;
typedef struct _FilesPluginsCtagsConsumeUnknownsQueueData FilesPluginsCtagsConsumeUnknownsQueueData;
#define _g_variant_iter_free0(var) ((var == NULL) ? NULL : (var = (g_variant_iter_free (var), NULL)))
typedef struct _FilesPluginsCtagsRrealUpdateFileInfoData FilesPluginsCtagsRrealUpdateFileInfoData;
typedef struct _FilesPluginsCtagsRrealUpdateFileInfoForRecentData FilesPluginsCtagsRrealUpdateFileInfoForRecentData;

#define FILES_PLUGINS_CTAGS_TYPE_COLOR_WIDGET (files_plugins_ctags_color_widget_get_type ())
#define FILES_PLUGINS_CTAGS_COLOR_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_PLUGINS_CTAGS_TYPE_COLOR_WIDGET, FilesPluginsCTagsColorWidget))
#define FILES_PLUGINS_CTAGS_COLOR_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_PLUGINS_CTAGS_TYPE_COLOR_WIDGET, FilesPluginsCTagsColorWidgetClass))
#define FILES_PLUGINS_CTAGS_IS_COLOR_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_PLUGINS_CTAGS_TYPE_COLOR_WIDGET))
#define FILES_PLUGINS_CTAGS_IS_COLOR_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_PLUGINS_CTAGS_TYPE_COLOR_WIDGET))
#define FILES_PLUGINS_CTAGS_COLOR_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_PLUGINS_CTAGS_TYPE_COLOR_WIDGET, FilesPluginsCTagsColorWidgetClass))

typedef struct _FilesPluginsCTagsColorWidget FilesPluginsCTagsColorWidget;
typedef struct _FilesPluginsCTagsColorWidgetClass FilesPluginsCTagsColorWidgetClass;
typedef struct _FilesPluginsCtagsSetColorData FilesPluginsCtagsSetColorData;

#define FILES_PLUGINS_CTAGS_TYPE_COLOR_BUTTON (files_plugins_ctags_color_button_get_type ())
#define FILES_PLUGINS_CTAGS_COLOR_BUTTON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FILES_PLUGINS_CTAGS_TYPE_COLOR_BUTTON, FilesPluginsCTagsColorButton))
#define FILES_PLUGINS_CTAGS_COLOR_BUTTON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FILES_PLUGINS_CTAGS_TYPE_COLOR_BUTTON, FilesPluginsCTagsColorButtonClass))
#define FILES_PLUGINS_CTAGS_IS_COLOR_BUTTON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FILES_PLUGINS_CTAGS_TYPE_COLOR_BUTTON))
#define FILES_PLUGINS_CTAGS_IS_COLOR_BUTTON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FILES_PLUGINS_CTAGS_TYPE_COLOR_BUTTON))
#define FILES_PLUGINS_CTAGS_COLOR_BUTTON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FILES_PLUGINS_CTAGS_TYPE_COLOR_BUTTON, FilesPluginsCTagsColorButtonClass))

typedef struct _FilesPluginsCTagsColorButton FilesPluginsCTagsColorButton;
typedef struct _FilesPluginsCTagsColorButtonClass FilesPluginsCTagsColorButtonClass;
typedef struct _FilesPluginsCTagsColorButtonPrivate FilesPluginsCTagsColorButtonPrivate;
enum  {
	FILES_PLUGINS_CTAGS_COLOR_BUTTON_0_PROPERTY,
	FILES_PLUGINS_CTAGS_COLOR_BUTTON_COLOR_NAME_PROPERTY,
	FILES_PLUGINS_CTAGS_COLOR_BUTTON_NUM_PROPERTIES
};
static GParamSpec* files_plugins_ctags_color_button_properties[FILES_PLUGINS_CTAGS_COLOR_BUTTON_NUM_PROPERTIES];
typedef struct _FilesPluginsCTagsColorWidgetPrivate FilesPluginsCTagsColorWidgetPrivate;
enum  {
	FILES_PLUGINS_CTAGS_COLOR_WIDGET_0_PROPERTY,
	FILES_PLUGINS_CTAGS_COLOR_WIDGET_NUM_PROPERTIES
};
static GParamSpec* files_plugins_ctags_color_widget_properties[FILES_PLUGINS_CTAGS_COLOR_WIDGET_NUM_PROPERTIES];
enum  {
	FILES_PLUGINS_CTAGS_COLOR_WIDGET_COLOR_CHANGED_SIGNAL,
	FILES_PLUGINS_CTAGS_COLOR_WIDGET_NUM_SIGNALS
};
static guint files_plugins_ctags_color_widget_signals[FILES_PLUGINS_CTAGS_COLOR_WIDGET_NUM_SIGNALS] = {0};
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _MarlinDaemonIface {
	GTypeInterface parent_iface;
	void (*get_uri_infos) (MarlinDaemon* self, const gchar* raw_uri, GAsyncReadyCallback _callback_, gpointer _user_data_);
	GVariant* (*get_uri_infos_finish) (MarlinDaemon* self, GAsyncResult* _res_, GError** error);
	void (*record_uris) (MarlinDaemon* self, GVariant** entries, gint entries_length1, GAsyncReadyCallback _callback_, gpointer _user_data_);
	gboolean (*record_uris_finish) (MarlinDaemon* self, GAsyncResult* _res_, GError** error);
	void (*delete_entry) (MarlinDaemon* self, const gchar* uri, GAsyncReadyCallback _callback_, gpointer _user_data_);
	gboolean (*delete_entry_finish) (MarlinDaemon* self, GAsyncResult* _res_, GError** error);
};

struct _MarlinDaemonGetUriInfosReadyData {
	GDBusMethodInvocation* _invocation_;
	gchar* raw_uri;
};

struct _MarlinDaemonRecordUrisReadyData {
	GDBusMethodInvocation* _invocation_;
	GVariant** entries;
	gint entries_length1;
};

struct _MarlinDaemonDeleteEntryReadyData {
	GDBusMethodInvocation* _invocation_;
	gchar* uri;
};

struct _FilesPluginsCTagsPrivate {
	MarlinDaemon* daemon;
	gboolean ignore_dir;
	GQueue* unknowns;
	GQueue* knowns;
	guint idle_consume_unknowns;
	guint t_consume_knowns;
	GCancellable* cancellable;
	GList* current_selected_files;
};

struct _FilesPluginsCtagsConsumeKnownsQueueData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	FilesPluginsCTags* self;
	GPtrArray* entries;
	GPtrArray* _tmp0_;
	FilesFile* gof;
	GQueue* _tmp1_;
	gpointer _tmp2_;
	FilesFile* _tmp3_;
	FilesFile* _tmp4_;
	GPtrArray* _tmp5_;
	GPtrArray* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	GPtrArray* _tmp9_;
	gint _tmp10_;
	gint _tmp11_;
	MarlinDaemon* _tmp12_;
	GPtrArray* _tmp13_;
	gpointer* _tmp14_;
	gint _tmp14__length1;
	GError* err;
	GError* _tmp15_;
	const gchar* _tmp16_;
	GError* _inner_error0_;
};

struct _FilesPluginsCtagsConsumeUnknownsQueueData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	FilesPluginsCTags* self;
	FilesFile* gof;
	GQueue* _tmp0_;
	gpointer _tmp1_;
	FilesFile* _tmp2_;
	GFileInfo* info;
	FilesFile* _tmp3_;
	GFileInfo* _tmp4_;
	GFileInfo* _tmp5_;
	GFileInfo* _tmp6_;
	GFileInfo* _tmp7_;
	FilesFile* _tmp8_;
	GFile* _tmp9_;
	GFile* _tmp10_;
	GCancellable* _tmp11_;
	GFileInfo* _tmp12_;
	GFileInfo* _tmp13_;
	FilesFile* _tmp14_;
	GFileInfo* _tmp15_;
	GError* err2;
	GError* _tmp16_;
	const gchar* _tmp17_;
	FilesFile* _tmp18_;
	const gchar* _tmp19_;
	const gchar* _tmp20_;
	GError* _inner_error0_;
};

struct _FilesPluginsCtagsRrealUpdateFileInfoData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	FilesPluginsCTags* self;
	FilesFile* file;
	MarlinDaemon* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	GVariant* rc;
	MarlinDaemon* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	GVariant* _tmp6_;
	GVariantIter* iter;
	GVariant* _tmp7_;
	GVariantIter* _tmp8_;
	GVariantIter* _tmp9_;
	GVariantIter* row_iter;
	GVariantIter* _tmp10_;
	GVariant* _tmp11_;
	GVariant* _tmp12_;
	GVariantIter* _tmp13_;
	GVariantIter* _tmp14_;
	GVariantIter* _tmp15_;
	guint64 modified;
	GVariantIter* _tmp16_;
	GVariant* _tmp17_;
	GVariant* _tmp18_;
	const gchar* _tmp19_;
	guint64 _tmp20_;
	const gchar* type;
	GVariantIter* _tmp21_;
	GVariant* _tmp22_;
	GVariant* _tmp23_;
	const gchar* _tmp24_;
	const gchar* _tmp25_;
	gint color;
	GVariantIter* _tmp26_;
	GVariant* _tmp27_;
	GVariant* _tmp28_;
	const gchar* _tmp29_;
	gint _tmp30_;
	gboolean _tmp31_;
	GFileInfo* _tmp32_;
	GFile* _tmp33_;
	GFile* _tmp34_;
	gboolean _tmp35_;
	const gchar* _tmp36_;
	gint _tmp37_;
	gint _tmp38_;
	const gchar* _tmp39_;
	const gchar* _tmp40_;
	const gchar* _tmp41_;
	gchar* _tmp42_;
	GError* err;
	GError* _tmp43_;
	const gchar* _tmp44_;
	GError* _inner_error0_;
};

struct _FilesPluginsCtagsRrealUpdateFileInfoForRecentData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	FilesPluginsCTags* self;
	FilesFile* file;
	gchar* target_uri;
	GVariant* rc;
	MarlinDaemon* _tmp0_;
	GVariant* _tmp1_;
	GVariantIter* iter;
	GVariant* _tmp2_;
	GVariantIter* _tmp3_;
	GVariantIter* _tmp4_;
	GVariantIter* row_iter;
	GVariantIter* _tmp5_;
	GVariant* _tmp6_;
	GVariant* _tmp7_;
	GVariantIter* _tmp8_;
	GVariantIter* _tmp9_;
	GVariantIter* _tmp10_;
	GVariantIter* _tmp11_;
	GVariant* _tmp12_;
	GVariant* _tmp13_;
	GVariantIter* _tmp14_;
	GVariant* _tmp15_;
	GVariant* _tmp16_;
	GVariantIter* _tmp17_;
	GVariant* _tmp18_;
	GVariant* _tmp19_;
	const gchar* _tmp20_;
	GError* err;
	GError* _tmp21_;
	const gchar* _tmp22_;
	GError* _inner_error0_;
};

struct _FilesPluginsCtagsSetColorData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	FilesPluginsCTags* self;
	GList* files;
	gint n;
	GPtrArray* entries;
	GPtrArray* _tmp0_;
	GList* file_collection;
	GList* file_it;
	FilesFile* file;
	FilesFile* _tmp1_;
	FilesFile* target_file;
	FilesFile* _tmp2_;
	GFile* _tmp3_;
	GFile* _tmp4_;
	FilesFile* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	FilesFile* _tmp8_;
	FilesFile* _tmp9_;
	FilesFile* _tmp10_;
	FilesFile* _tmp11_;
	FilesFile* _tmp12_;
	FilesFile* _tmp13_;
	GPtrArray* _tmp14_;
	GPtrArray* _tmp15_;
	MarlinDaemon* _tmp16_;
	GPtrArray* _tmp17_;
	gpointer* _tmp18_;
	gint _tmp18__length1;
	GList* _vala1_file_collection;
	GList* _vala1_file_it;
	FilesFile* _vala1_file;
	FilesFile* _tmp19_;
	GFile* _tmp20_;
	GFile* _tmp21_;
	FilesFile* _tmp22_;
	FilesFile* _tmp23_;
	GError* err;
	GError* _tmp24_;
	const gchar* _tmp25_;
	GError* _inner_error0_;
};

struct _FilesPluginsCTagsColorButton {
	GtkCheckButton parent_instance;
	FilesPluginsCTagsColorButtonPrivate * priv;
};

struct _FilesPluginsCTagsColorButtonClass {
	GtkCheckButtonClass parent_class;
};

struct _FilesPluginsCTagsColorButtonPrivate {
	gchar* _color_name;
};

struct _FilesPluginsCTagsColorWidget {
	GtkMenuItem parent_instance;
	FilesPluginsCTagsColorWidgetPrivate * priv;
};

struct _FilesPluginsCTagsColorWidgetClass {
	GtkMenuItemClass parent_class;
};

struct _FilesPluginsCTagsColorWidgetPrivate {
	GeeArrayList* color_buttons;
};

static gint FilesPluginsCTags_private_offset;
static gpointer files_plugins_ctags_parent_class = NULL;
static gint FilesPluginsCTagsColorButton_private_offset;
static gpointer files_plugins_ctags_color_button_parent_class = NULL;
static GtkCssProvider* files_plugins_ctags_color_button_css_provider;
static GtkCssProvider* files_plugins_ctags_color_button_css_provider = NULL;
static gint FilesPluginsCTagsColorWidget_private_offset;
static gpointer files_plugins_ctags_color_widget_parent_class = NULL;

VALA_EXTERN GType marlin_daemon_proxy_get_type (void) G_GNUC_CONST ;
VALA_EXTERN guint marlin_daemon_register_object (void* object,
                                     GDBusConnection* connection,
                                     const gchar* path,
                                     GError** error);
VALA_EXTERN GType marlin_daemon_get_type (void) G_GNUC_CONST ;
VALA_EXTERN void marlin_daemon_get_uri_infos (MarlinDaemon* self,
                                  const gchar* raw_uri,
                                  GAsyncReadyCallback _callback_,
                                  gpointer _user_data_);
VALA_EXTERN GVariant* marlin_daemon_get_uri_infos_finish (MarlinDaemon* self,
                                              GAsyncResult* _res_,
                                              GError** error);
VALA_EXTERN void marlin_daemon_record_uris (MarlinDaemon* self,
                                GVariant** entries,
                                gint entries_length1,
                                GAsyncReadyCallback _callback_,
                                gpointer _user_data_);
VALA_EXTERN gboolean marlin_daemon_record_uris_finish (MarlinDaemon* self,
                                           GAsyncResult* _res_,
                                           GError** error);
VALA_EXTERN void marlin_daemon_delete_entry (MarlinDaemon* self,
                                 const gchar* uri,
                                 GAsyncReadyCallback _callback_,
                                 gpointer _user_data_);
VALA_EXTERN gboolean marlin_daemon_delete_entry_finish (MarlinDaemon* self,
                                            GAsyncResult* _res_,
                                            GError** error);
static GType marlin_daemon_get_type_once (void);
static void marlin_daemon_proxy_g_signal (GDBusProxy* proxy,
                                   const gchar* sender_name,
                                   const gchar* signal_name,
                                   GVariant* parameters);
static void _vala_g_async_ready_callback (GObject *source_object,
                                   GAsyncResult *res,
                                   void *user_data);
static void marlin_daemon_proxy_get_uri_infos_async (MarlinDaemon* self,
                                              const gchar* raw_uri,
                                              GAsyncReadyCallback _callback_,
                                              gpointer _user_data_);
static GVariant* marlin_daemon_proxy_get_uri_infos_finish (MarlinDaemon* self,
                                                    GAsyncResult* _res_,
                                                    GError** error);
static void marlin_daemon_proxy_record_uris_async (MarlinDaemon* self,
                                            GVariant** entries,
                                            gint entries_length1,
                                            GAsyncReadyCallback _callback_,
                                            gpointer _user_data_);
static gboolean marlin_daemon_proxy_record_uris_finish (MarlinDaemon* self,
                                                 GAsyncResult* _res_,
                                                 GError** error);
static void marlin_daemon_proxy_delete_entry_async (MarlinDaemon* self,
                                             const gchar* uri,
                                             GAsyncReadyCallback _callback_,
                                             gpointer _user_data_);
static gboolean marlin_daemon_proxy_delete_entry_finish (MarlinDaemon* self,
                                                  GAsyncResult* _res_,
                                                  GError** error);
static void marlin_daemon_proxy_marlin_daemon_interface_init (MarlinDaemonIface* iface);
static void _dbus_marlin_daemon_get_uri_infos (MarlinDaemon* self,
                                        GVariant* _parameters_,
                                        GDBusMethodInvocation* invocation);
static void _dbus_marlin_daemon_get_uri_infos_ready (GObject * source_object,
                                              GAsyncResult * _res_,
                                              gpointer _user_data_);
static void _dbus_marlin_daemon_record_uris (MarlinDaemon* self,
                                      GVariant* _parameters_,
                                      GDBusMethodInvocation* invocation);
static void _dbus_marlin_daemon_record_uris_ready (GObject * source_object,
                                            GAsyncResult * _res_,
                                            gpointer _user_data_);
static void _dbus_marlin_daemon_delete_entry (MarlinDaemon* self,
                                       GVariant* _parameters_,
                                       GDBusMethodInvocation* invocation);
static void _dbus_marlin_daemon_delete_entry_ready (GObject * source_object,
                                             GAsyncResult * _res_,
                                             gpointer _user_data_);
static void marlin_daemon_dbus_interface_method_call (GDBusConnection* connection,
                                               const gchar* sender,
                                               const gchar* object_path,
                                               const gchar* interface_name,
                                               const gchar* method_name,
                                               GVariant* parameters,
                                               GDBusMethodInvocation* invocation,
                                               gpointer user_data);
static GVariant* marlin_daemon_dbus_interface_get_property (GDBusConnection* connection,
                                                     const gchar* sender,
                                                     const gchar* object_path,
                                                     const gchar* interface_name,
                                                     const gchar* property_name,
                                                     GError** error,
                                                     gpointer user_data);
static gboolean marlin_daemon_dbus_interface_set_property (GDBusConnection* connection,
                                                    const gchar* sender,
                                                    const gchar* object_path,
                                                    const gchar* interface_name,
                                                    const gchar* property_name,
                                                    GVariant* value,
                                                    GError** error,
                                                    gpointer user_data);
static void _marlin_daemon_unregister_object (gpointer user_data);
static void _g_object_unref0_ (gpointer var);
static inline void _g_queue_free__g_object_unref0_ (GQueue* self);
static inline void _g_list_free__g_object_unref0_ (GList* self);
static gboolean files_plugins_ctags_f_is_user_dir (FilesPluginsCTags* self,
                                            GFile* dir);
static gboolean files_plugins_ctags_f_ignore_dir (FilesPluginsCTags* self,
                                           GFile* dir);
static void files_plugins_ctags_real_directory_loaded (FilesPluginsBase* base,
                                                GtkApplicationWindow* window,
                                                FilesAbstractSlot* view,
                                                FilesFile* directory);
static void files_plugins_ctags_add_entry (FilesPluginsCTags* self,
                                    FilesFile* gof,
                                    GPtrArray* entries);
static void files_plugins_ctags_consume_knowns_queue_data_free (gpointer _data);
static void files_plugins_ctags_consume_knowns_queue (FilesPluginsCTags* self,
                                               GAsyncReadyCallback _callback_,
                                               gpointer _user_data_);
static void files_plugins_ctags_consume_knowns_queue_finish (FilesPluginsCTags* self,
                                                      GAsyncResult* _res_);
static gboolean files_plugins_ctags_consume_knowns_queue_co (FilesPluginsCtagsConsumeKnownsQueueData* _data_);
static void _g_variant_unref0_ (gpointer var);
static void files_plugins_ctags_consume_knowns_queue_ready (GObject* source_object,
                                                     GAsyncResult* _res_,
                                                     gpointer _user_data_);
static void files_plugins_ctags_consume_unknowns_queue_data_free (gpointer _data);
static void files_plugins_ctags_consume_unknowns_queue (FilesPluginsCTags* self,
                                                 GAsyncReadyCallback _callback_,
                                                 gpointer _user_data_);
static void files_plugins_ctags_consume_unknowns_queue_finish (FilesPluginsCTags* self,
                                                        GAsyncResult* _res_);
static gboolean files_plugins_ctags_consume_unknowns_queue_co (FilesPluginsCtagsConsumeUnknownsQueueData* _data_);
static void files_plugins_ctags_consume_unknowns_queue_ready (GObject* source_object,
                                                       GAsyncResult* _res_,
                                                       gpointer _user_data_);
static void files_plugins_ctags_add_to_knowns_queue (FilesPluginsCTags* self,
                                              FilesFile* file,
                                              GFileInfo* info);
static gboolean __lambda4_ (FilesPluginsCTags* self);
static gboolean ___lambda4__gsource_func (gpointer self);
static void files_plugins_ctags_add_to_unknowns_queue (FilesPluginsCTags* self,
                                                FilesFile* file);
static gboolean ____lambda5_ (FilesPluginsCTags* self);
static gboolean _____lambda5__gsource_func (gpointer self);
static void files_plugins_ctags_rreal_update_file_info_data_free (gpointer _data);
static void files_plugins_ctags_rreal_update_file_info (FilesPluginsCTags* self,
                                                 FilesFile* file,
                                                 GAsyncReadyCallback _callback_,
                                                 gpointer _user_data_);
static void files_plugins_ctags_rreal_update_file_info_finish (FilesPluginsCTags* self,
                                                        GAsyncResult* _res_);
static gboolean files_plugins_ctags_rreal_update_file_info_co (FilesPluginsCtagsRrealUpdateFileInfoData* _data_);
static void files_plugins_ctags_rreal_update_file_info_ready (GObject* source_object,
                                                       GAsyncResult* _res_,
                                                       gpointer _user_data_);
static void files_plugins_ctags_rreal_update_file_info_for_recent_data_free (gpointer _data);
static void files_plugins_ctags_rreal_update_file_info_for_recent (FilesPluginsCTags* self,
                                                            FilesFile* file,
                                                            const gchar* target_uri,
                                                            GAsyncReadyCallback _callback_,
                                                            gpointer _user_data_);
static void files_plugins_ctags_rreal_update_file_info_for_recent_finish (FilesPluginsCTags* self,
                                                                   GAsyncResult* _res_);
static gboolean files_plugins_ctags_rreal_update_file_info_for_recent_co (FilesPluginsCtagsRrealUpdateFileInfoForRecentData* _data_);
static void files_plugins_ctags_rreal_update_file_info_for_recent_ready (GObject* source_object,
                                                                  GAsyncResult* _res_,
                                                                  gpointer _user_data_);
static void files_plugins_ctags_real_update_file_info (FilesPluginsBase* base,
                                                FilesFile* file);
static void files_plugins_ctags_real_context_menu (FilesPluginsBase* base,
                                            GtkWidget* widget,
                                            GList* selected_files);
static GType files_plugins_ctags_color_widget_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static FilesPluginsCTagsColorWidget* files_plugins_ctags_color_widget_new (void);
static FilesPluginsCTagsColorWidget* files_plugins_ctags_color_widget_construct (GType object_type);
static void files_plugins_ctags_color_widget_check_color (FilesPluginsCTagsColorWidget* self,
                                                   gint color);
static void __lambda7_ (FilesPluginsCTags* self,
                 gint ncolor);
static void files_plugins_ctags_set_color (FilesPluginsCTags* self,
                                    GList* files,
                                    gint n,
                                    GAsyncReadyCallback _callback_,
                                    gpointer _user_data_);
static void files_plugins_ctags_set_color_finish (FilesPluginsCTags* self,
                                           GAsyncResult* _res_,
                                           GError** error);
static void ___lambda7__files_plugins_ctags_color_widget_color_changed (FilesPluginsCTagsColorWidget* _sender,
                                                                 gint ncolor,
                                                                 gpointer self);
static void files_plugins_ctags_add_menuitem (FilesPluginsCTags* self,
                                       GtkMenu* menu,
                                       GtkMenuItem* menu_item);
static void files_plugins_ctags_set_color_data_free (gpointer _data);
static gboolean files_plugins_ctags_set_color_co (FilesPluginsCtagsSetColorData* _data_);
static void files_plugins_ctags_set_color_ready (GObject* source_object,
                                          GAsyncResult* _res_,
                                          gpointer _user_data_);
static GType files_plugins_ctags_color_button_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static FilesPluginsCTagsColorButton* files_plugins_ctags_color_button_new (const gchar* color_name);
static FilesPluginsCTagsColorButton* files_plugins_ctags_color_button_construct (GType object_type,
                                                                          const gchar* color_name);
static const gchar* files_plugins_ctags_color_button_get_color_name (FilesPluginsCTagsColorButton* self);
static void files_plugins_ctags_color_button_set_color_name (FilesPluginsCTagsColorButton* self,
                                                      const gchar* value);
static GObject * files_plugins_ctags_color_button_constructor (GType type,
                                                        guint n_construct_properties,
                                                        GObjectConstructParam * construct_properties);
static void files_plugins_ctags_color_button_finalize (GObject * obj);
static GType files_plugins_ctags_color_button_get_type_once (void);
static void _vala_files_plugins_ctags_color_button_get_property (GObject * object,
                                                          guint property_id,
                                                          GValue * value,
                                                          GParamSpec * pspec);
static void _vala_files_plugins_ctags_color_button_set_property (GObject * object,
                                                          guint property_id,
                                                          const GValue * value,
                                                          GParamSpec * pspec);
static void files_plugins_ctags_color_widget_clear_checks (FilesPluginsCTagsColorWidget* self);
static gboolean __lambda6_ (FilesPluginsCTagsColorWidget* self,
                     FilesPluginsCTagsColorButton* b);
static gboolean ___lambda6__gee_forall_func (gpointer g,
                                      gpointer self);
static gboolean files_plugins_ctags_color_widget_button_pressed_cb (FilesPluginsCTagsColorWidget* self,
                                                             GdkEventButton* event);
static GObject * files_plugins_ctags_color_widget_constructor (GType type,
                                                        guint n_construct_properties,
                                                        GObjectConstructParam * construct_properties);
static gboolean _files_plugins_ctags_color_widget_button_pressed_cb_gtk_widget_button_press_event (GtkWidget* _sender,
                                                                                            GdkEventButton* event,
                                                                                            gpointer self);
static void files_plugins_ctags_color_widget_finalize (GObject * obj);
static GType files_plugins_ctags_color_widget_get_type_once (void);
static void files_plugins_ctags_finalize (FilesPluginsBase * obj);
static GType files_plugins_ctags_get_type_once (void);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);

static const GDBusArgInfo _marlin_daemon_dbus_arg_info_get_uri_infos_raw_uri = {-1, "raw_uri", "s", NULL};
static const GDBusArgInfo _marlin_daemon_dbus_arg_info_get_uri_infos_result = {-1, "result", "v", NULL};
static const GDBusArgInfo * const _marlin_daemon_dbus_arg_info_get_uri_infos_in[] = {&_marlin_daemon_dbus_arg_info_get_uri_infos_raw_uri, NULL};
static const GDBusArgInfo * const _marlin_daemon_dbus_arg_info_get_uri_infos_out[] = {&_marlin_daemon_dbus_arg_info_get_uri_infos_result, NULL};
static const GDBusMethodInfo _marlin_daemon_dbus_method_info_get_uri_infos = {-1, "GetUriInfos", (GDBusArgInfo **) (&_marlin_daemon_dbus_arg_info_get_uri_infos_in), (GDBusArgInfo **) (&_marlin_daemon_dbus_arg_info_get_uri_infos_out), NULL};
static const GDBusArgInfo _marlin_daemon_dbus_arg_info_record_uris_entries = {-1, "entries", "av", NULL};
static const GDBusArgInfo _marlin_daemon_dbus_arg_info_record_uris_result = {-1, "result", "b", NULL};
static const GDBusArgInfo * const _marlin_daemon_dbus_arg_info_record_uris_in[] = {&_marlin_daemon_dbus_arg_info_record_uris_entries, NULL};
static const GDBusArgInfo * const _marlin_daemon_dbus_arg_info_record_uris_out[] = {&_marlin_daemon_dbus_arg_info_record_uris_result, NULL};
static const GDBusMethodInfo _marlin_daemon_dbus_method_info_record_uris = {-1, "RecordUris", (GDBusArgInfo **) (&_marlin_daemon_dbus_arg_info_record_uris_in), (GDBusArgInfo **) (&_marlin_daemon_dbus_arg_info_record_uris_out), NULL};
static const GDBusArgInfo _marlin_daemon_dbus_arg_info_delete_entry_uri = {-1, "uri", "s", NULL};
static const GDBusArgInfo _marlin_daemon_dbus_arg_info_delete_entry_result = {-1, "result", "b", NULL};
static const GDBusArgInfo * const _marlin_daemon_dbus_arg_info_delete_entry_in[] = {&_marlin_daemon_dbus_arg_info_delete_entry_uri, NULL};
static const GDBusArgInfo * const _marlin_daemon_dbus_arg_info_delete_entry_out[] = {&_marlin_daemon_dbus_arg_info_delete_entry_result, NULL};
static const GDBusMethodInfo _marlin_daemon_dbus_method_info_delete_entry = {-1, "DeleteEntry", (GDBusArgInfo **) (&_marlin_daemon_dbus_arg_info_delete_entry_in), (GDBusArgInfo **) (&_marlin_daemon_dbus_arg_info_delete_entry_out), NULL};
static const GDBusMethodInfo * const _marlin_daemon_dbus_method_info[] = {&_marlin_daemon_dbus_method_info_get_uri_infos, &_marlin_daemon_dbus_method_info_record_uris, &_marlin_daemon_dbus_method_info_delete_entry, NULL};
static const GDBusSignalInfo * const _marlin_daemon_dbus_signal_info[] = {NULL};
static const GDBusPropertyInfo * const _marlin_daemon_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _marlin_daemon_dbus_interface_info = {-1, "io.elementary.files.db", (GDBusMethodInfo **) (&_marlin_daemon_dbus_method_info), (GDBusSignalInfo **) (&_marlin_daemon_dbus_signal_info), (GDBusPropertyInfo **) (&_marlin_daemon_dbus_property_info), NULL};
static const GDBusInterfaceVTable _marlin_daemon_dbus_interface_vtable = {marlin_daemon_dbus_interface_method_call, marlin_daemon_dbus_interface_get_property, marlin_daemon_dbus_interface_set_property};
static const gchar* FILES_PLUGINS_CTAGS_USER_DIRS[2] = {"file:///home", "file:///media"};
static const gchar* FILES_PLUGINS_CTAGS_IGNORE_SCHEMES[5] = {"ftp", "sftp", "afp", "dav", "davs"};

void
marlin_daemon_get_uri_infos (MarlinDaemon* self,
                             const gchar* raw_uri,
                             GAsyncReadyCallback _callback_,
                             gpointer _user_data_)
{
	MarlinDaemonIface* _iface_;
	_iface_ = MARLIN_DAEMON_GET_INTERFACE (self);
	if (_iface_->get_uri_infos) {
		_iface_->get_uri_infos (self, raw_uri, _callback_, _user_data_);
	}
}

GVariant*
marlin_daemon_get_uri_infos_finish (MarlinDaemon* self,
                                    GAsyncResult* _res_,
                                    GError** error)
{
	MarlinDaemonIface* _iface_;
	_iface_ = MARLIN_DAEMON_GET_INTERFACE (self);
	if (_iface_->get_uri_infos_finish) {
		return _iface_->get_uri_infos_finish (self, _res_, error);
	}
	return NULL;
}

void
marlin_daemon_record_uris (MarlinDaemon* self,
                           GVariant** entries,
                           gint entries_length1,
                           GAsyncReadyCallback _callback_,
                           gpointer _user_data_)
{
	MarlinDaemonIface* _iface_;
	_iface_ = MARLIN_DAEMON_GET_INTERFACE (self);
	if (_iface_->record_uris) {
		_iface_->record_uris (self, entries, entries_length1, _callback_, _user_data_);
	}
}

gboolean
marlin_daemon_record_uris_finish (MarlinDaemon* self,
                                  GAsyncResult* _res_,
                                  GError** error)
{
	MarlinDaemonIface* _iface_;
	_iface_ = MARLIN_DAEMON_GET_INTERFACE (self);
	if (_iface_->record_uris_finish) {
		return _iface_->record_uris_finish (self, _res_, error);
	}
	return FALSE;
}

void
marlin_daemon_delete_entry (MarlinDaemon* self,
                            const gchar* uri,
                            GAsyncReadyCallback _callback_,
                            gpointer _user_data_)
{
	MarlinDaemonIface* _iface_;
	_iface_ = MARLIN_DAEMON_GET_INTERFACE (self);
	if (_iface_->delete_entry) {
		_iface_->delete_entry (self, uri, _callback_, _user_data_);
	}
}

gboolean
marlin_daemon_delete_entry_finish (MarlinDaemon* self,
                                   GAsyncResult* _res_,
                                   GError** error)
{
	MarlinDaemonIface* _iface_;
	_iface_ = MARLIN_DAEMON_GET_INTERFACE (self);
	if (_iface_->delete_entry_finish) {
		return _iface_->delete_entry_finish (self, _res_, error);
	}
	return FALSE;
}

static void
marlin_daemon_default_init (MarlinDaemonIface * iface,
                            gpointer iface_data)
{
}

/***
    Copyright (c) ammonkey 2011 <am.monkeyd@gmail.com>

    Marlin is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Marlin is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program.  If not, see <http://www.gnu.org/licenses/>.
***/
static GType
marlin_daemon_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (MarlinDaemonIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) marlin_daemon_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
	GType marlin_daemon_type_id;
	marlin_daemon_type_id = g_type_register_static (G_TYPE_INTERFACE, "MarlinDaemon", &g_define_type_info, 0);
	g_type_interface_add_prerequisite (marlin_daemon_type_id, G_TYPE_OBJECT);
	g_type_set_qdata (marlin_daemon_type_id, g_quark_from_static_string ("vala-dbus-proxy-type"), (void*) marlin_daemon_proxy_get_type);
	g_type_set_qdata (marlin_daemon_type_id, g_quark_from_static_string ("vala-dbus-interface-name"), "io.elementary.files.db");
	g_type_set_qdata (marlin_daemon_type_id, g_quark_from_static_string ("vala-dbus-interface-info"), (void*) (&_marlin_daemon_dbus_interface_info));
	g_type_set_qdata (marlin_daemon_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) marlin_daemon_register_object);
	return marlin_daemon_type_id;
}

GType
marlin_daemon_get_type (void)
{
	static volatile gsize marlin_daemon_type_id__once = 0;
	if (g_once_init_enter (&marlin_daemon_type_id__once)) {
		GType marlin_daemon_type_id;
		marlin_daemon_type_id = marlin_daemon_get_type_once ();
		g_once_init_leave (&marlin_daemon_type_id__once, marlin_daemon_type_id);
	}
	return marlin_daemon_type_id__once;
}

G_DEFINE_TYPE_EXTENDED (MarlinDaemonProxy, marlin_daemon_proxy, G_TYPE_DBUS_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_MARLIN_DAEMON, marlin_daemon_proxy_marlin_daemon_interface_init) )
static void
marlin_daemon_proxy_class_init (MarlinDaemonProxyClass* klass)
{
	G_DBUS_PROXY_CLASS (klass)->g_signal = marlin_daemon_proxy_g_signal;
}

static void
marlin_daemon_proxy_g_signal (GDBusProxy* proxy,
                              const gchar* sender_name,
                              const gchar* signal_name,
                              GVariant* parameters)
{
}

static void
marlin_daemon_proxy_init (MarlinDaemonProxy* self)
{
	g_dbus_proxy_set_interface_info (G_DBUS_PROXY (self), (GDBusInterfaceInfo *) (&_marlin_daemon_dbus_interface_info));
}

static void
_vala_g_async_ready_callback (GObject *source_object,
                              GAsyncResult *res,
                              void *user_data)
{
	g_task_return_pointer (user_data, g_object_ref (res), g_object_unref);
	g_object_unref (user_data);
}

static void
marlin_daemon_proxy_get_uri_infos_async (MarlinDaemon* self,
                                         const gchar* raw_uri,
                                         GAsyncReadyCallback _callback_,
                                         gpointer _user_data_)
{
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	G_DBUS_ERROR;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "io.elementary.files.db", "GetUriInfos");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (raw_uri));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	if (_callback_ != NULL) {
		g_dbus_connection_send_message_with_reply (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, _vala_g_async_ready_callback, g_task_new ((GObject *) self, NULL, _callback_, _user_data_));
	} else {
		g_dbus_message_set_flags (_message, G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED);
		g_dbus_connection_send_message (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	}
	g_object_unref (_message);
}

static GVariant*
marlin_daemon_proxy_get_uri_infos_finish (MarlinDaemon* self,
                                          GAsyncResult* _res_,
                                          GError** error)
{
	GAsyncResult *_inner_res;
	GDBusMessage *_reply_message;
	GVariant *_reply;
	GVariantIter _reply_iter;
	GVariant* _result = NULL;
	GVariant* _tmp0_;
	_inner_res = g_task_propagate_pointer ((GTask *) _res_, NULL);
	_reply_message = g_dbus_connection_send_message_with_reply_finish (g_dbus_proxy_get_connection ((GDBusProxy *) self), _inner_res, error);
	g_object_unref (_inner_res);
	if (!_reply_message) {
		return NULL;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return NULL;
	}
	_reply = g_dbus_message_get_body (_reply_message);
	g_variant_iter_init (&_reply_iter, _reply);
	_tmp0_ = g_variant_iter_next_value (&_reply_iter);
	_result = g_variant_get_variant (_tmp0_);
	g_variant_unref (_tmp0_);
	g_object_unref (_reply_message);
	return _result;
}

static void
marlin_daemon_proxy_record_uris_async (MarlinDaemon* self,
                                       GVariant** entries,
                                       gint entries_length1,
                                       GAsyncReadyCallback _callback_,
                                       gpointer _user_data_)
{
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GVariant** _tmp1_;
	GVariantBuilder _tmp2_;
	gint _tmp3_;
	G_DBUS_ERROR;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "io.elementary.files.db", "RecordUris");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	_tmp1_ = entries;
	g_variant_builder_init (&_tmp2_, G_VARIANT_TYPE ("av"));
	for (_tmp3_ = 0; _tmp3_ < entries_length1; _tmp3_++) {
		g_variant_builder_add_value (&_tmp2_, g_variant_new_variant (*_tmp1_));
		_tmp1_++;
	}
	g_variant_builder_add_value (&_arguments_builder, g_variant_builder_end (&_tmp2_));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	if (_callback_ != NULL) {
		g_dbus_connection_send_message_with_reply (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, _vala_g_async_ready_callback, g_task_new ((GObject *) self, NULL, _callback_, _user_data_));
	} else {
		g_dbus_message_set_flags (_message, G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED);
		g_dbus_connection_send_message (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	}
	g_object_unref (_message);
}

static gboolean
marlin_daemon_proxy_record_uris_finish (MarlinDaemon* self,
                                        GAsyncResult* _res_,
                                        GError** error)
{
	GAsyncResult *_inner_res;
	GDBusMessage *_reply_message;
	GVariant *_reply;
	GVariantIter _reply_iter;
	gboolean _result = FALSE;
	GVariant* _tmp6_;
	_inner_res = g_task_propagate_pointer ((GTask *) _res_, NULL);
	_reply_message = g_dbus_connection_send_message_with_reply_finish (g_dbus_proxy_get_connection ((GDBusProxy *) self), _inner_res, error);
	g_object_unref (_inner_res);
	if (!_reply_message) {
		gboolean _tmp4_ = FALSE;
		return _tmp4_;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		gboolean _tmp5_ = FALSE;
		g_object_unref (_reply_message);
		return _tmp5_;
	}
	_reply = g_dbus_message_get_body (_reply_message);
	g_variant_iter_init (&_reply_iter, _reply);
	_tmp6_ = g_variant_iter_next_value (&_reply_iter);
	_result = g_variant_get_boolean (_tmp6_);
	g_variant_unref (_tmp6_);
	g_object_unref (_reply_message);
	return _result;
}

static void
marlin_daemon_proxy_delete_entry_async (MarlinDaemon* self,
                                        const gchar* uri,
                                        GAsyncReadyCallback _callback_,
                                        gpointer _user_data_)
{
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	G_DBUS_ERROR;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "io.elementary.files.db", "DeleteEntry");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (uri));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	if (_callback_ != NULL) {
		g_dbus_connection_send_message_with_reply (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, _vala_g_async_ready_callback, g_task_new ((GObject *) self, NULL, _callback_, _user_data_));
	} else {
		g_dbus_message_set_flags (_message, G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED);
		g_dbus_connection_send_message (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	}
	g_object_unref (_message);
}

static gboolean
marlin_daemon_proxy_delete_entry_finish (MarlinDaemon* self,
                                         GAsyncResult* _res_,
                                         GError** error)
{
	GAsyncResult *_inner_res;
	GDBusMessage *_reply_message;
	GVariant *_reply;
	GVariantIter _reply_iter;
	gboolean _result = FALSE;
	GVariant* _tmp9_;
	_inner_res = g_task_propagate_pointer ((GTask *) _res_, NULL);
	_reply_message = g_dbus_connection_send_message_with_reply_finish (g_dbus_proxy_get_connection ((GDBusProxy *) self), _inner_res, error);
	g_object_unref (_inner_res);
	if (!_reply_message) {
		gboolean _tmp7_ = FALSE;
		return _tmp7_;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		gboolean _tmp8_ = FALSE;
		g_object_unref (_reply_message);
		return _tmp8_;
	}
	_reply = g_dbus_message_get_body (_reply_message);
	g_variant_iter_init (&_reply_iter, _reply);
	_tmp9_ = g_variant_iter_next_value (&_reply_iter);
	_result = g_variant_get_boolean (_tmp9_);
	g_variant_unref (_tmp9_);
	g_object_unref (_reply_message);
	return _result;
}

static void
marlin_daemon_proxy_marlin_daemon_interface_init (MarlinDaemonIface* iface)
{
	iface->get_uri_infos = marlin_daemon_proxy_get_uri_infos_async;
	iface->get_uri_infos_finish = marlin_daemon_proxy_get_uri_infos_finish;
	iface->record_uris = marlin_daemon_proxy_record_uris_async;
	iface->record_uris_finish = marlin_daemon_proxy_record_uris_finish;
	iface->delete_entry = marlin_daemon_proxy_delete_entry_async;
	iface->delete_entry_finish = marlin_daemon_proxy_delete_entry_finish;
}

static void
_dbus_marlin_daemon_get_uri_infos (MarlinDaemon* self,
                                   GVariant* _parameters_,
                                   GDBusMethodInvocation* invocation)
{
	GVariantIter _arguments_iter;
	MarlinDaemonGetUriInfosReadyData* _ready_data;
	GVariant* _tmp10_;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	_ready_data = g_slice_new0 (MarlinDaemonGetUriInfosReadyData);
	_ready_data->_invocation_ = invocation;
	_tmp10_ = g_variant_iter_next_value (&_arguments_iter);
	_ready_data->raw_uri = g_variant_dup_string (_tmp10_, NULL);
	g_variant_unref (_tmp10_);
	marlin_daemon_get_uri_infos (self, _ready_data->raw_uri, (GAsyncReadyCallback) _dbus_marlin_daemon_get_uri_infos_ready, _ready_data);
	_error:
	;
}

static void
_dbus_marlin_daemon_get_uri_infos_ready (GObject * source_object,
                                         GAsyncResult * _res_,
                                         gpointer _user_data_)
{
	MarlinDaemonGetUriInfosReadyData* _ready_data;
	GDBusMethodInvocation* invocation;
	GError* error = NULL;
	GDBusMessage* _reply_message = NULL;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	GVariant* result;
	_ready_data = _user_data_;
	invocation = _ready_data->_invocation_;
	result = marlin_daemon_get_uri_infos_finish ((MarlinDaemon*) source_object, _res_, &error);
	if (error) {
		g_dbus_method_invocation_take_error (invocation, error);
		goto _error;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_variant (result));
	_g_variant_unref0 (result);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
	_error:
	_g_free0 (_ready_data->raw_uri);
	g_slice_free (MarlinDaemonGetUriInfosReadyData, _ready_data);
}

static void
_dbus_marlin_daemon_record_uris (MarlinDaemon* self,
                                 GVariant* _parameters_,
                                 GDBusMethodInvocation* invocation)
{
	GVariantIter _arguments_iter;
	MarlinDaemonRecordUrisReadyData* _ready_data;
	GVariant* _tmp11_;
	GVariant** _tmp12_;
	gint _tmp12__length;
	gint _tmp12__size;
	gint _tmp12__length1;
	GVariantIter _tmp13_;
	GVariant* _tmp14_;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	_ready_data = g_slice_new0 (MarlinDaemonRecordUrisReadyData);
	_ready_data->_invocation_ = invocation;
	_tmp11_ = g_variant_iter_next_value (&_arguments_iter);
	_tmp12_ = g_new (GVariant*, 5);
	_tmp12__length = 0;
	_tmp12__size = 4;
	_tmp12__length1 = 0;
	g_variant_iter_init (&_tmp13_, _tmp11_);
	for (; (_tmp14_ = g_variant_iter_next_value (&_tmp13_)) != NULL; _tmp12__length1++) {
		if (_tmp12__size == _tmp12__length) {
			_tmp12__size = 2 * _tmp12__size;
			_tmp12_ = g_renew (GVariant*, _tmp12_, _tmp12__size + 1);
		}
		_tmp12_[_tmp12__length++] = g_variant_get_variant (_tmp14_);
		g_variant_unref (_tmp14_);
	}
	_ready_data->entries_length1 = _tmp12__length1;
	_tmp12_[_tmp12__length] = NULL;
	_ready_data->entries = _tmp12_;
	g_variant_unref (_tmp11_);
	marlin_daemon_record_uris (self, _ready_data->entries, _ready_data->entries_length1, (GAsyncReadyCallback) _dbus_marlin_daemon_record_uris_ready, _ready_data);
	_error:
	;
}

static void
_dbus_marlin_daemon_record_uris_ready (GObject * source_object,
                                       GAsyncResult * _res_,
                                       gpointer _user_data_)
{
	MarlinDaemonRecordUrisReadyData* _ready_data;
	GDBusMethodInvocation* invocation;
	GError* error = NULL;
	GDBusMessage* _reply_message = NULL;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gboolean result;
	_ready_data = _user_data_;
	invocation = _ready_data->_invocation_;
	result = marlin_daemon_record_uris_finish ((MarlinDaemon*) source_object, _res_, &error);
	if (error) {
		g_dbus_method_invocation_take_error (invocation, error);
		goto _error;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_boolean (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
	_error:
	_ready_data->entries = (_vala_array_free (_ready_data->entries, _ready_data->entries_length1, (GDestroyNotify) g_variant_unref), NULL);
	g_slice_free (MarlinDaemonRecordUrisReadyData, _ready_data);
}

static void
_dbus_marlin_daemon_delete_entry (MarlinDaemon* self,
                                  GVariant* _parameters_,
                                  GDBusMethodInvocation* invocation)
{
	GVariantIter _arguments_iter;
	MarlinDaemonDeleteEntryReadyData* _ready_data;
	GVariant* _tmp15_;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	_ready_data = g_slice_new0 (MarlinDaemonDeleteEntryReadyData);
	_ready_data->_invocation_ = invocation;
	_tmp15_ = g_variant_iter_next_value (&_arguments_iter);
	_ready_data->uri = g_variant_dup_string (_tmp15_, NULL);
	g_variant_unref (_tmp15_);
	marlin_daemon_delete_entry (self, _ready_data->uri, (GAsyncReadyCallback) _dbus_marlin_daemon_delete_entry_ready, _ready_data);
	_error:
	;
}

static void
_dbus_marlin_daemon_delete_entry_ready (GObject * source_object,
                                        GAsyncResult * _res_,
                                        gpointer _user_data_)
{
	MarlinDaemonDeleteEntryReadyData* _ready_data;
	GDBusMethodInvocation* invocation;
	GError* error = NULL;
	GDBusMessage* _reply_message = NULL;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gboolean result;
	_ready_data = _user_data_;
	invocation = _ready_data->_invocation_;
	result = marlin_daemon_delete_entry_finish ((MarlinDaemon*) source_object, _res_, &error);
	if (error) {
		g_dbus_method_invocation_take_error (invocation, error);
		goto _error;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_boolean (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
	_error:
	_g_free0 (_ready_data->uri);
	g_slice_free (MarlinDaemonDeleteEntryReadyData, _ready_data);
}

static void
marlin_daemon_dbus_interface_method_call (GDBusConnection* connection,
                                          const gchar* sender,
                                          const gchar* object_path,
                                          const gchar* interface_name,
                                          const gchar* method_name,
                                          GVariant* parameters,
                                          GDBusMethodInvocation* invocation,
                                          gpointer user_data)
{
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "GetUriInfos") == 0) {
		_dbus_marlin_daemon_get_uri_infos (object, parameters, invocation);
	} else if (strcmp (method_name, "RecordUris") == 0) {
		_dbus_marlin_daemon_record_uris (object, parameters, invocation);
	} else if (strcmp (method_name, "DeleteEntry") == 0) {
		_dbus_marlin_daemon_delete_entry (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}

static GVariant*
marlin_daemon_dbus_interface_get_property (GDBusConnection* connection,
                                           const gchar* sender,
                                           const gchar* object_path,
                                           const gchar* interface_name,
                                           const gchar* property_name,
                                           GError** error,
                                           gpointer user_data)
{
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}

static gboolean
marlin_daemon_dbus_interface_set_property (GDBusConnection* connection,
                                           const gchar* sender,
                                           const gchar* object_path,
                                           const gchar* interface_name,
                                           const gchar* property_name,
                                           GVariant* value,
                                           GError** error,
                                           gpointer user_data)
{
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}

guint
marlin_daemon_register_object (gpointer object,
                               GDBusConnection* connection,
                               const gchar* path,
                               GError** error)
{
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_marlin_daemon_dbus_interface_info), &_marlin_daemon_dbus_interface_vtable, data, _marlin_daemon_unregister_object, error);
	if (!result) {
		return 0;
	}
	return result;
}

static void
_marlin_daemon_unregister_object (gpointer user_data)
{
	gpointer* data;
	data = user_data;
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}

static inline gpointer
files_plugins_ctags_get_instance_private (FilesPluginsCTags* self)
{
	return G_STRUCT_MEMBER_P (self, FilesPluginsCTags_private_offset);
}

static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}

static inline void
_g_queue_free__g_object_unref0_ (GQueue* self)
{
	g_queue_free_full (self, (GDestroyNotify) _g_object_unref0_);
}

static inline void
_g_list_free__g_object_unref0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_object_unref0_);
}

FilesPluginsCTags*
files_plugins_ctags_construct (GType object_type)
{
	FilesPluginsCTags* self = NULL;
	GQueue* _tmp0_;
	GQueue* _tmp1_;
	GCancellable* _tmp2_;
	GError* _inner_error0_ = NULL;
	self = (FilesPluginsCTags*) files_plugins_base_construct (object_type);
	_tmp0_ = g_queue_new ();
	(self->priv->unknowns == NULL) ? NULL : (self->priv->unknowns = (_g_queue_free__g_object_unref0_ (self->priv->unknowns), NULL));
	self->priv->unknowns = _tmp0_;
	_tmp1_ = g_queue_new ();
	(self->priv->knowns == NULL) ? NULL : (self->priv->knowns = (_g_queue_free__g_object_unref0_ (self->priv->knowns), NULL));
	self->priv->knowns = _tmp1_;
	_tmp2_ = g_cancellable_new ();
	_g_object_unref0 (self->priv->cancellable);
	self->priv->cancellable = _tmp2_;
	{
		MarlinDaemon* _tmp3_ = NULL;
		MarlinDaemon* _tmp4_;
		MarlinDaemon* _tmp5_;
		_tmp4_ = (MarlinDaemon*) g_initable_new (TYPE_MARLIN_DAEMON_PROXY, NULL, &_inner_error0_, "g-flags", 0, "g-name", "io.elementary.files.db", "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", "/io/elementary/files/db", "g-interface-name", "io.elementary.files.db", NULL);
		_tmp3_ = (MarlinDaemon*) _tmp4_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == G_IO_ERROR) {
				goto __catch0_g_io_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return NULL;
		}
		_tmp5_ = _tmp3_;
		_tmp3_ = NULL;
		_g_object_unref0 (self->priv->daemon);
		self->priv->daemon = _tmp5_;
		_g_object_unref0 (_tmp3_);
	}
	goto __finally0;
	__catch0_g_io_error:
	{
		GError* e = NULL;
		FILE* _tmp6_;
		GError* _tmp7_;
		const gchar* _tmp8_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp6_ = stderr;
		_tmp7_ = e;
		_tmp8_ = _tmp7_->message;
		fprintf (_tmp6_, "%s\n", _tmp8_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return NULL;
	}
	return self;
}

FilesPluginsCTags*
files_plugins_ctags_new (void)
{
	return files_plugins_ctags_construct (FILES_PLUGINS_TYPE_CTAGS);
}

static gboolean
files_plugins_ctags_f_is_user_dir (FilesPluginsCTags* self,
                                   GFile* dir)
{
	gchar* uri = NULL;
	gchar* _tmp0_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (dir != NULL, FALSE);
	g_return_val_if_fail (dir != NULL, FALSE);
	_tmp0_ = g_file_get_uri (dir);
	uri = _tmp0_;
	{
		const gchar** duri_collection = NULL;
		gint duri_collection_length1 = 0;
		gint _duri_collection_size_ = 0;
		gint duri_it = 0;
		duri_collection = FILES_PLUGINS_CTAGS_USER_DIRS;
		duri_collection_length1 = 2;
		for (duri_it = 0; duri_it < duri_collection_length1; duri_it = duri_it + 1) {
			const gchar* duri = NULL;
			duri = duri_collection[duri_it];
			{
				const gchar* _tmp1_;
				const gchar* _tmp2_;
				const gchar* _tmp3_;
				gint _tmp4_;
				gint _tmp5_;
				_tmp1_ = uri;
				_tmp2_ = duri;
				_tmp3_ = duri;
				_tmp4_ = strlen (_tmp3_);
				_tmp5_ = _tmp4_;
				if (strncmp (_tmp1_, _tmp2_, (gsize) _tmp5_) == 0) {
					result = TRUE;
					_g_free0 (uri);
					return result;
				}
			}
		}
	}
	result = FALSE;
	_g_free0 (uri);
	return result;
}

static gboolean
files_plugins_ctags_f_ignore_dir (FilesPluginsCTags* self,
                                  GFile* dir)
{
	gchar* uri = NULL;
	gchar* _tmp0_;
	const gchar* _tmp1_;
	gchar* uri_scheme = NULL;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (dir != NULL, FALSE);
	g_return_val_if_fail (dir != NULL, TRUE);
	_tmp0_ = g_file_get_uri (dir);
	uri = _tmp0_;
	_tmp1_ = uri;
	if (g_strcmp0 (_tmp1_, "file:///tmp") == 0) {
		result = TRUE;
		_g_free0 (uri);
		return result;
	}
	_tmp2_ = uri;
	_tmp3_ = g_uri_parse_scheme (_tmp2_);
	uri_scheme = _tmp3_;
	{
		const gchar** scheme_collection = NULL;
		gint scheme_collection_length1 = 0;
		gint _scheme_collection_size_ = 0;
		gint scheme_it = 0;
		scheme_collection = FILES_PLUGINS_CTAGS_IGNORE_SCHEMES;
		scheme_collection_length1 = 5;
		for (scheme_it = 0; scheme_it < scheme_collection_length1; scheme_it = scheme_it + 1) {
			const gchar* scheme = NULL;
			scheme = scheme_collection[scheme_it];
			{
				const gchar* _tmp4_;
				const gchar* _tmp5_;
				_tmp4_ = scheme;
				_tmp5_ = uri_scheme;
				if (g_strcmp0 (_tmp4_, _tmp5_) == 0) {
					result = TRUE;
					_g_free0 (uri_scheme);
					_g_free0 (uri);
					return result;
				}
			}
		}
	}
	result = FALSE;
	_g_free0 (uri_scheme);
	_g_free0 (uri);
	return result;
}

static void
files_plugins_ctags_real_directory_loaded (FilesPluginsBase* base,
                                           GtkApplicationWindow* window,
                                           FilesAbstractSlot* view,
                                           FilesFile* directory)
{
	FilesPluginsCTags * self;
	self = (FilesPluginsCTags*) base;
	g_return_if_fail (window != NULL);
	g_return_if_fail (view != NULL);
	g_return_if_fail (directory != NULL);
}

static gpointer
_g_variant_ref0 (gpointer self)
{
	return self ? g_variant_ref (self) : NULL;
}

static void
files_plugins_ctags_add_entry (FilesPluginsCTags* self,
                               FilesFile* gof,
                               GPtrArray* entries)
{
	GVariant* entry = NULL;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	GFileInfo* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar** _tmp8_;
	gchar** _tmp9_;
	gint _tmp9__length1;
	GVariant* _tmp10_;
	GVariant* _tmp11_;
	GVariant* _tmp12_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (gof != NULL);
	g_return_if_fail (entries != NULL);
	_tmp0_ = files_file_get_uri (gof);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_strdup (_tmp1_);
	_tmp3_ = files_file_get_ftype (gof);
	_tmp4_ = g_strdup (_tmp3_);
	_tmp5_ = gof->info;
	_tmp6_ = g_strdup_printf ("%" G_GUINT64_FORMAT, g_file_info_get_attribute_uint64 (_tmp5_, G_FILE_ATTRIBUTE_TIME_MODIFIED));
	_tmp7_ = g_strdup_printf ("%i", gof->color);
	_tmp8_ = g_new0 (gchar*, 4 + 1);
	_tmp8_[0] = _tmp2_;
	_tmp8_[1] = _tmp4_;
	_tmp8_[2] = _tmp6_;
	_tmp8_[3] = _tmp7_;
	_tmp9_ = _tmp8_;
	_tmp9__length1 = 4;
	_tmp10_ = g_variant_new_strv (_tmp9_, 4);
	g_variant_ref_sink (_tmp10_);
	_tmp11_ = _tmp10_;
	_tmp9_ = (_vala_array_free (_tmp9_, _tmp9__length1, (GDestroyNotify) g_free), NULL);
	entry = _tmp11_;
	_tmp12_ = _g_variant_ref0 (entry);
	g_ptr_array_add (entries, _tmp12_);
	_g_variant_unref0 (entry);
}

static void
files_plugins_ctags_consume_knowns_queue_data_free (gpointer _data)
{
	FilesPluginsCtagsConsumeKnownsQueueData* _data_;
	_data_ = _data;
	_files_plugins_base_unref0 (_data_->self);
	g_slice_free (FilesPluginsCtagsConsumeKnownsQueueData, _data_);
}

static gpointer
_files_plugins_base_ref0 (gpointer self)
{
	return self ? files_plugins_base_ref (self) : NULL;
}

static void
files_plugins_ctags_consume_knowns_queue (FilesPluginsCTags* self,
                                          GAsyncReadyCallback _callback_,
                                          gpointer _user_data_)
{
	FilesPluginsCtagsConsumeKnownsQueueData* _data_;
	FilesPluginsCTags* _tmp0_;
	g_return_if_fail (self != NULL);
	_data_ = g_slice_new0 (FilesPluginsCtagsConsumeKnownsQueueData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, files_plugins_ctags_consume_knowns_queue_data_free);
	_tmp0_ = _files_plugins_base_ref0 (self);
	_data_->self = _tmp0_;
	files_plugins_ctags_consume_knowns_queue_co (_data_);
}

static void
files_plugins_ctags_consume_knowns_queue_finish (FilesPluginsCTags* self,
                                                 GAsyncResult* _res_)
{
	FilesPluginsCtagsConsumeKnownsQueueData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static void
_g_variant_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_variant_unref (var), NULL));
}

static gint
vala_g_ptr_array_get_length (GPtrArray* self)
{
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = (gint) self->len;
	return result;
}

static void
files_plugins_ctags_consume_knowns_queue_ready (GObject* source_object,
                                                GAsyncResult* _res_,
                                                gpointer _user_data_)
{
	FilesPluginsCtagsConsumeKnownsQueueData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	files_plugins_ctags_consume_knowns_queue_co (_data_);
}

static gboolean
files_plugins_ctags_consume_knowns_queue_co (FilesPluginsCtagsConsumeKnownsQueueData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = g_ptr_array_new_full ((guint) 0, _g_variant_unref0_);
	_data_->entries = _data_->_tmp0_;
	while (TRUE) {
		_data_->_tmp1_ = _data_->self->priv->knowns;
		_data_->_tmp2_ = g_queue_pop_head (_data_->_tmp1_);
		_g_object_unref0 (_data_->gof);
		_data_->gof = (FilesFile*) _data_->_tmp2_;
		_data_->_tmp3_ = _data_->gof;
		if (!(_data_->_tmp3_ != NULL)) {
			break;
		}
		_data_->_tmp4_ = _data_->gof;
		_data_->_tmp5_ = _data_->entries;
		files_plugins_ctags_add_entry (_data_->self, _data_->_tmp4_, _data_->_tmp5_);
	}
	_data_->_tmp6_ = _data_->entries;
	_data_->_tmp7_ = vala_g_ptr_array_get_length (_data_->_tmp6_);
	_data_->_tmp8_ = _data_->_tmp7_;
	if (_data_->_tmp8_ > 0) {
		_data_->_tmp9_ = _data_->entries;
		_data_->_tmp10_ = vala_g_ptr_array_get_length (_data_->_tmp9_);
		_data_->_tmp11_ = _data_->_tmp10_;
		g_debug ("plugin.vala:120: --- known entries %d", _data_->_tmp11_);
		{
			_data_->_tmp12_ = _data_->self->priv->daemon;
			_data_->_tmp13_ = _data_->entries;
			_data_->_tmp14_ = _data_->_tmp13_->pdata;
			_data_->_tmp14__length1 = _data_->_tmp13_->len;
			_data_->_state_ = 1;
			marlin_daemon_record_uris (_data_->_tmp12_, _data_->_tmp14_, (gint) _data_->_tmp14__length1, files_plugins_ctags_consume_knowns_queue_ready, _data_);
			return FALSE;
			_state_1:
			marlin_daemon_record_uris_finish (_data_->_tmp12_, _data_->_res_, &_data_->_inner_error0_);
			if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
				goto __catch0_g_error;
			}
		}
		goto __finally0;
		__catch0_g_error:
		{
			_data_->err = _data_->_inner_error0_;
			_data_->_inner_error0_ = NULL;
			_data_->_tmp15_ = _data_->err;
			_data_->_tmp16_ = _data_->_tmp15_->message;
			g_warning ("plugin.vala:124: %s", _data_->_tmp16_);
			_g_error_free0 (_data_->err);
		}
		__finally0:
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
			_g_object_unref0 (_data_->gof);
			_g_ptr_array_unref0 (_data_->entries);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
			g_clear_error (&_data_->_inner_error0_);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
	}
	_g_object_unref0 (_data_->gof);
	_g_ptr_array_unref0 (_data_->entries);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static void
files_plugins_ctags_consume_unknowns_queue_data_free (gpointer _data)
{
	FilesPluginsCtagsConsumeUnknownsQueueData* _data_;
	_data_ = _data;
	_files_plugins_base_unref0 (_data_->self);
	g_slice_free (FilesPluginsCtagsConsumeUnknownsQueueData, _data_);
}

static void
files_plugins_ctags_consume_unknowns_queue (FilesPluginsCTags* self,
                                            GAsyncReadyCallback _callback_,
                                            gpointer _user_data_)
{
	FilesPluginsCtagsConsumeUnknownsQueueData* _data_;
	FilesPluginsCTags* _tmp0_;
	g_return_if_fail (self != NULL);
	_data_ = g_slice_new0 (FilesPluginsCtagsConsumeUnknownsQueueData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, files_plugins_ctags_consume_unknowns_queue_data_free);
	_tmp0_ = _files_plugins_base_ref0 (self);
	_data_->self = _tmp0_;
	files_plugins_ctags_consume_unknowns_queue_co (_data_);
}

static void
files_plugins_ctags_consume_unknowns_queue_finish (FilesPluginsCTags* self,
                                                   GAsyncResult* _res_)
{
	FilesPluginsCtagsConsumeUnknownsQueueData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static void
files_plugins_ctags_consume_unknowns_queue_ready (GObject* source_object,
                                                  GAsyncResult* _res_,
                                                  gpointer _user_data_)
{
	FilesPluginsCtagsConsumeUnknownsQueueData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	files_plugins_ctags_consume_unknowns_queue_co (_data_);
}

static gboolean
files_plugins_ctags_consume_unknowns_queue_co (FilesPluginsCtagsConsumeUnknownsQueueData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->gof = NULL;
	while (TRUE) {
		_data_->_tmp0_ = _data_->self->priv->unknowns;
		_data_->_tmp1_ = g_queue_pop_head (_data_->_tmp0_);
		_g_object_unref0 (_data_->gof);
		_data_->gof = (FilesFile*) _data_->_tmp1_;
		_data_->_tmp2_ = _data_->gof;
		if (!(_data_->_tmp2_ != NULL)) {
			break;
		}
		{
			_data_->_tmp3_ = _data_->gof;
			_data_->_tmp4_ = _data_->_tmp3_->info;
			_data_->_tmp5_ = _g_object_ref0 (_data_->_tmp4_);
			_data_->info = _data_->_tmp5_;
			_data_->_tmp6_ = _data_->info;
			if (_data_->_tmp6_ == NULL) {
				_data_->_tmp8_ = _data_->gof;
				_data_->_tmp9_ = files_file_get_location (_data_->_tmp8_);
				_data_->_tmp10_ = _data_->_tmp9_;
				_data_->_tmp11_ = _data_->self->priv->cancellable;
				_data_->_state_ = 1;
				g_file_query_info_async (_data_->_tmp10_, G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE, 0, 0, _data_->_tmp11_, files_plugins_ctags_consume_unknowns_queue_ready, _data_);
				return FALSE;
				_state_1:
				_data_->_tmp12_ = g_file_query_info_finish (_data_->_tmp10_, _data_->_res_, &_data_->_inner_error0_);
				_data_->_tmp7_ = _data_->_tmp12_;
				if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
					_g_object_unref0 (_data_->info);
					goto __catch0_g_error;
				}
				_data_->_tmp13_ = _data_->_tmp7_;
				_data_->_tmp7_ = NULL;
				_g_object_unref0 (_data_->info);
				_data_->info = _data_->_tmp13_;
				_g_object_unref0 (_data_->_tmp7_);
			}
			_data_->_tmp14_ = _data_->gof;
			_data_->_tmp15_ = _data_->info;
			files_plugins_ctags_add_to_knowns_queue (_data_->self, _data_->_tmp14_, _data_->_tmp15_);
			_g_object_unref0 (_data_->info);
		}
		goto __finally0;
		__catch0_g_error:
		{
			_data_->err2 = _data_->_inner_error0_;
			_data_->_inner_error0_ = NULL;
			_data_->_tmp16_ = _data_->err2;
			_data_->_tmp17_ = _data_->_tmp16_->message;
			_data_->_tmp18_ = _data_->gof;
			_data_->_tmp19_ = files_file_get_uri (_data_->_tmp18_);
			_data_->_tmp20_ = _data_->_tmp19_;
			g_warning ("plugin.vala:142: query_info failed: %s %s", _data_->_tmp17_, _data_->_tmp20_);
			_g_error_free0 (_data_->err2);
		}
		__finally0:
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
			_g_object_unref0 (_data_->gof);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
			g_clear_error (&_data_->_inner_error0_);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
	}
	_g_object_unref0 (_data_->gof);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static gboolean
__lambda4_ (FilesPluginsCTags* self)
{
	gboolean result;
	files_plugins_ctags_consume_knowns_queue (self, NULL, NULL);
	self->priv->t_consume_knowns = (guint) 0;
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
___lambda4__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda4_ ((FilesPluginsCTags*) self);
	return result;
}

static void
files_plugins_ctags_add_to_knowns_queue (FilesPluginsCTags* self,
                                         FilesFile* file,
                                         GFileInfo* info)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	GQueue* _tmp2_;
	FilesFile* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	g_return_if_fail (info != NULL);
	_tmp0_ = g_file_info_get_content_type (info);
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (file->tagstype);
	file->tagstype = _tmp1_;
	files_file_update_type (file);
	_tmp2_ = self->priv->knowns;
	_tmp3_ = _g_object_ref0 (file);
	g_queue_push_head (_tmp2_, _tmp3_);
	if (self->priv->t_consume_knowns != ((guint) 0)) {
		g_source_remove (self->priv->t_consume_knowns);
		self->priv->t_consume_knowns = (guint) 0;
	}
	self->priv->t_consume_knowns = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 300, ___lambda4__gsource_func, files_plugins_base_ref (self), files_plugins_base_unref);
}

static gboolean
____lambda5_ (FilesPluginsCTags* self)
{
	gboolean result;
	files_plugins_ctags_consume_unknowns_queue (self, NULL, NULL);
	self->priv->idle_consume_unknowns = (guint) 0;
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
_____lambda5__gsource_func (gpointer self)
{
	gboolean result;
	result = ____lambda5_ ((FilesPluginsCTags*) self);
	return result;
}

static void
files_plugins_ctags_add_to_unknowns_queue (FilesPluginsCTags* self,
                                           FilesFile* file)
{
	const gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	_tmp0_ = files_file_get_ftype (file);
	if (g_strcmp0 (_tmp0_, "application/octet-stream") == 0) {
		GQueue* _tmp1_;
		FilesFile* _tmp2_;
		_tmp1_ = self->priv->unknowns;
		_tmp2_ = _g_object_ref0 (file);
		g_queue_push_head (_tmp1_, _tmp2_);
		if (self->priv->idle_consume_unknowns == ((guint) 0)) {
			self->priv->idle_consume_unknowns = g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _____lambda5__gsource_func, files_plugins_base_ref (self), files_plugins_base_unref);
		}
	}
}

static void
files_plugins_ctags_rreal_update_file_info_data_free (gpointer _data)
{
	FilesPluginsCtagsRrealUpdateFileInfoData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->file);
	_files_plugins_base_unref0 (_data_->self);
	g_slice_free (FilesPluginsCtagsRrealUpdateFileInfoData, _data_);
}

static void
files_plugins_ctags_rreal_update_file_info (FilesPluginsCTags* self,
                                            FilesFile* file,
                                            GAsyncReadyCallback _callback_,
                                            gpointer _user_data_)
{
	FilesPluginsCtagsRrealUpdateFileInfoData* _data_;
	FilesPluginsCTags* _tmp0_;
	FilesFile* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	_data_ = g_slice_new0 (FilesPluginsCtagsRrealUpdateFileInfoData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, files_plugins_ctags_rreal_update_file_info_data_free);
	_tmp0_ = _files_plugins_base_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = _g_object_ref0 (file);
	_g_object_unref0 (_data_->file);
	_data_->file = _tmp1_;
	files_plugins_ctags_rreal_update_file_info_co (_data_);
}

static void
files_plugins_ctags_rreal_update_file_info_finish (FilesPluginsCTags* self,
                                                   GAsyncResult* _res_)
{
	FilesPluginsCtagsRrealUpdateFileInfoData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static void
files_plugins_ctags_rreal_update_file_info_ready (GObject* source_object,
                                                  GAsyncResult* _res_,
                                                  gpointer _user_data_)
{
	FilesPluginsCtagsRrealUpdateFileInfoData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	files_plugins_ctags_rreal_update_file_info_co (_data_);
}

static gint64
int64_parse (const gchar* str,
             guint _base)
{
	gint64 result;
	g_return_val_if_fail (str != NULL, 0LL);
	result = g_ascii_strtoll (str, NULL, _base);
	return result;
}

static gboolean
files_plugins_ctags_rreal_update_file_info_co (FilesPluginsCtagsRrealUpdateFileInfoData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		if (!_data_->file->exists) {
			_data_->_tmp0_ = _data_->self->priv->daemon;
			_data_->_tmp1_ = files_file_get_uri (_data_->file);
			_data_->_tmp2_ = _data_->_tmp1_;
			_data_->_state_ = 1;
			marlin_daemon_delete_entry (_data_->_tmp0_, _data_->_tmp2_, files_plugins_ctags_rreal_update_file_info_ready, _data_);
			return FALSE;
			_state_1:
			marlin_daemon_delete_entry_finish (_data_->_tmp0_, _data_->_res_, &_data_->_inner_error0_);
			if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
				goto __catch0_g_error;
			}
			g_task_return_pointer (_data_->_async_result, _data_, NULL);
			if (_data_->_state_ != 0) {
				while (!g_task_get_completed (_data_->_async_result)) {
					g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
				}
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		_data_->_tmp3_ = _data_->self->priv->daemon;
		_data_->_tmp4_ = files_file_get_uri (_data_->file);
		_data_->_tmp5_ = _data_->_tmp4_;
		_data_->_state_ = 2;
		marlin_daemon_get_uri_infos (_data_->_tmp3_, _data_->_tmp5_, files_plugins_ctags_rreal_update_file_info_ready, _data_);
		return FALSE;
		_state_2:
		_data_->_tmp6_ = marlin_daemon_get_uri_infos_finish (_data_->_tmp3_, _data_->_res_, &_data_->_inner_error0_);
		_data_->rc = _data_->_tmp6_;
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		_data_->_tmp7_ = _data_->rc;
		_data_->_tmp8_ = g_variant_iter_new (_data_->_tmp7_);
		_data_->iter = _data_->_tmp8_;
		_data_->_tmp9_ = _data_->iter;
		_vala_assert (g_variant_iter_n_children (_data_->_tmp9_) == ((gsize) 1), "iter.n_children () == 1");
		_data_->_tmp10_ = _data_->iter;
		_data_->_tmp11_ = g_variant_iter_next_value (_data_->_tmp10_);
		_data_->_tmp12_ = _data_->_tmp11_;
		_data_->_tmp13_ = g_variant_iter_new (_data_->_tmp12_);
		_data_->_tmp14_ = _data_->_tmp13_;
		_g_variant_unref0 (_data_->_tmp12_);
		_data_->row_iter = _data_->_tmp14_;
		_data_->_tmp15_ = _data_->row_iter;
		if (g_variant_iter_n_children (_data_->_tmp15_) == ((gsize) 3)) {
			_data_->_tmp16_ = _data_->row_iter;
			_data_->_tmp17_ = g_variant_iter_next_value (_data_->_tmp16_);
			_data_->_tmp18_ = _data_->_tmp17_;
			_data_->_tmp19_ = g_variant_get_string (_data_->_tmp18_, NULL);
			_data_->_tmp20_ = (guint64) int64_parse (_data_->_tmp19_, (guint) 0);
			_g_variant_unref0 (_data_->_tmp18_);
			_data_->modified = _data_->_tmp20_;
			_data_->_tmp21_ = _data_->row_iter;
			_data_->_tmp22_ = g_variant_iter_next_value (_data_->_tmp21_);
			_data_->_tmp23_ = _data_->_tmp22_;
			_data_->_tmp24_ = g_variant_get_string (_data_->_tmp23_, NULL);
			_data_->_tmp25_ = _data_->_tmp24_;
			_g_variant_unref0 (_data_->_tmp23_);
			_data_->type = _data_->_tmp25_;
			_data_->_tmp26_ = _data_->row_iter;
			_data_->_tmp27_ = g_variant_iter_next_value (_data_->_tmp26_);
			_data_->_tmp28_ = _data_->_tmp27_;
			_data_->_tmp29_ = g_variant_get_string (_data_->_tmp28_, NULL);
			_data_->_tmp30_ = atoi (_data_->_tmp29_);
			_g_variant_unref0 (_data_->_tmp28_);
			_data_->color = _data_->_tmp30_;
			if (_data_->file->color != _data_->color) {
				_data_->file->color = _data_->color;
				g_signal_emit_by_name (_data_->file, "icon-changed");
			}
			_data_->_tmp32_ = _data_->file->info;
			if (g_file_info_get_attribute_uint64 (_data_->_tmp32_, G_FILE_ATTRIBUTE_TIME_MODIFIED) > _data_->modified) {
				_data_->_tmp33_ = files_file_get_directory (_data_->file);
				_data_->_tmp34_ = _data_->_tmp33_;
				_data_->_tmp31_ = files_plugins_ctags_f_is_user_dir (_data_->self, _data_->_tmp34_);
			} else {
				_data_->_tmp31_ = FALSE;
			}
			if (_data_->_tmp31_) {
				files_plugins_ctags_add_to_unknowns_queue (_data_->self, _data_->file);
				_g_variant_iter_free0 (_data_->row_iter);
				_g_variant_iter_free0 (_data_->iter);
				_g_variant_unref0 (_data_->rc);
				g_task_return_pointer (_data_->_async_result, _data_, NULL);
				if (_data_->_state_ != 0) {
					while (!g_task_get_completed (_data_->_async_result)) {
						g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
					}
				}
				g_object_unref (_data_->_async_result);
				return FALSE;
			}
			_data_->_tmp36_ = _data_->type;
			_data_->_tmp37_ = strlen (_data_->_tmp36_);
			_data_->_tmp38_ = _data_->_tmp37_;
			if (_data_->_tmp38_ > 0) {
				_data_->_tmp39_ = files_file_get_ftype (_data_->file);
				_data_->_tmp35_ = g_strcmp0 (_data_->_tmp39_, "application/octet-stream") == 0;
			} else {
				_data_->_tmp35_ = FALSE;
			}
			if (_data_->_tmp35_) {
				_data_->_tmp40_ = _data_->type;
				if (g_strcmp0 (_data_->_tmp40_, "application/octet-stream") != 0) {
					_data_->_tmp41_ = _data_->type;
					_data_->_tmp42_ = g_strdup (_data_->_tmp41_);
					_g_free0 (_data_->file->tagstype);
					_data_->file->tagstype = _data_->_tmp42_;
					files_file_update_type (_data_->file);
				}
			}
		} else {
			files_plugins_ctags_add_to_unknowns_queue (_data_->self, _data_->file);
		}
		_g_variant_iter_free0 (_data_->row_iter);
		_g_variant_iter_free0 (_data_->iter);
		_g_variant_unref0 (_data_->rc);
	}
	goto __finally0;
	__catch0_g_error:
	{
		_data_->err = _data_->_inner_error0_;
		_data_->_inner_error0_ = NULL;
		_data_->_tmp43_ = _data_->err;
		_data_->_tmp44_ = _data_->_tmp43_->message;
		g_warning ("plugin.vala:221: %s", _data_->_tmp44_);
		_g_error_free0 (_data_->err);
	}
	__finally0:
	if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
		g_clear_error (&_data_->_inner_error0_);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static void
files_plugins_ctags_rreal_update_file_info_for_recent_data_free (gpointer _data)
{
	FilesPluginsCtagsRrealUpdateFileInfoForRecentData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->file);
	_g_free0 (_data_->target_uri);
	_files_plugins_base_unref0 (_data_->self);
	g_slice_free (FilesPluginsCtagsRrealUpdateFileInfoForRecentData, _data_);
}

static void
files_plugins_ctags_rreal_update_file_info_for_recent (FilesPluginsCTags* self,
                                                       FilesFile* file,
                                                       const gchar* target_uri,
                                                       GAsyncReadyCallback _callback_,
                                                       gpointer _user_data_)
{
	FilesPluginsCtagsRrealUpdateFileInfoForRecentData* _data_;
	FilesPluginsCTags* _tmp0_;
	FilesFile* _tmp1_;
	gchar* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	_data_ = g_slice_new0 (FilesPluginsCtagsRrealUpdateFileInfoForRecentData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, files_plugins_ctags_rreal_update_file_info_for_recent_data_free);
	_tmp0_ = _files_plugins_base_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = _g_object_ref0 (file);
	_g_object_unref0 (_data_->file);
	_data_->file = _tmp1_;
	_tmp2_ = g_strdup (target_uri);
	_g_free0 (_data_->target_uri);
	_data_->target_uri = _tmp2_;
	files_plugins_ctags_rreal_update_file_info_for_recent_co (_data_);
}

static void
files_plugins_ctags_rreal_update_file_info_for_recent_finish (FilesPluginsCTags* self,
                                                              GAsyncResult* _res_)
{
	FilesPluginsCtagsRrealUpdateFileInfoForRecentData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static void
files_plugins_ctags_rreal_update_file_info_for_recent_ready (GObject* source_object,
                                                             GAsyncResult* _res_,
                                                             gpointer _user_data_)
{
	FilesPluginsCtagsRrealUpdateFileInfoForRecentData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	files_plugins_ctags_rreal_update_file_info_for_recent_co (_data_);
}

static gboolean
files_plugins_ctags_rreal_update_file_info_for_recent_co (FilesPluginsCtagsRrealUpdateFileInfoForRecentData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	if (_data_->target_uri == NULL) {
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (!g_task_get_completed (_data_->_async_result)) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	{
		_data_->_tmp0_ = _data_->self->priv->daemon;
		_data_->_state_ = 1;
		marlin_daemon_get_uri_infos (_data_->_tmp0_, _data_->target_uri, files_plugins_ctags_rreal_update_file_info_for_recent_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp1_ = marlin_daemon_get_uri_infos_finish (_data_->_tmp0_, _data_->_res_, &_data_->_inner_error0_);
		_data_->rc = _data_->_tmp1_;
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		_data_->_tmp2_ = _data_->rc;
		_data_->_tmp3_ = g_variant_iter_new (_data_->_tmp2_);
		_data_->iter = _data_->_tmp3_;
		_data_->_tmp4_ = _data_->iter;
		_vala_assert (g_variant_iter_n_children (_data_->_tmp4_) == ((gsize) 1), "iter.n_children () == 1");
		_data_->_tmp5_ = _data_->iter;
		_data_->_tmp6_ = g_variant_iter_next_value (_data_->_tmp5_);
		_data_->_tmp7_ = _data_->_tmp6_;
		_data_->_tmp8_ = g_variant_iter_new (_data_->_tmp7_);
		_data_->_tmp9_ = _data_->_tmp8_;
		_g_variant_unref0 (_data_->_tmp7_);
		_data_->row_iter = _data_->_tmp9_;
		_data_->_tmp10_ = _data_->row_iter;
		if (g_variant_iter_n_children (_data_->_tmp10_) == ((gsize) 3)) {
			_data_->_tmp11_ = _data_->row_iter;
			_data_->_tmp12_ = g_variant_iter_next_value (_data_->_tmp11_);
			_data_->_tmp13_ = _data_->_tmp12_;
			_g_variant_unref0 (_data_->_tmp13_);
			_data_->_tmp14_ = _data_->row_iter;
			_data_->_tmp15_ = g_variant_iter_next_value (_data_->_tmp14_);
			_data_->_tmp16_ = _data_->_tmp15_;
			_g_variant_unref0 (_data_->_tmp16_);
			_data_->_tmp17_ = _data_->row_iter;
			_data_->_tmp18_ = g_variant_iter_next_value (_data_->_tmp17_);
			_data_->_tmp19_ = _data_->_tmp18_;
			_data_->_tmp20_ = g_variant_get_string (_data_->_tmp19_, NULL);
			_data_->file->color = atoi (_data_->_tmp20_);
			_g_variant_unref0 (_data_->_tmp19_);
		}
		_g_variant_iter_free0 (_data_->row_iter);
		_g_variant_iter_free0 (_data_->iter);
		_g_variant_unref0 (_data_->rc);
	}
	goto __finally0;
	__catch0_g_error:
	{
		_data_->err = _data_->_inner_error0_;
		_data_->_inner_error0_ = NULL;
		_data_->_tmp21_ = _data_->err;
		_data_->_tmp22_ = _data_->_tmp21_->message;
		g_warning ("plugin.vala:244: %s", _data_->_tmp22_);
		_g_error_free0 (_data_->err);
	}
	__finally0:
	if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
		g_clear_error (&_data_->_inner_error0_);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static void
files_plugins_ctags_real_update_file_info (FilesPluginsBase* base,
                                           FilesFile* file)
{
	FilesPluginsCTags * self;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GFileInfo* _tmp2_;
	self = (FilesPluginsCTags*) base;
	g_return_if_fail (file != NULL);
	_tmp2_ = file->info;
	if (_tmp2_ != NULL) {
		GFile* _tmp3_;
		GFile* _tmp4_;
		_tmp3_ = files_file_get_directory (file);
		_tmp4_ = _tmp3_;
		_tmp1_ = !files_plugins_ctags_f_ignore_dir (self, _tmp4_);
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		gboolean _tmp5_ = FALSE;
		if (!file->is_hidden) {
			_tmp5_ = TRUE;
		} else {
			FilesPreferences* _tmp6_;
			FilesPreferences* _tmp7_;
			gboolean _tmp8_;
			gboolean _tmp9_;
			_tmp6_ = files_preferences_get_default ();
			_tmp7_ = _tmp6_;
			_tmp8_ = files_preferences_get_show_hidden_files (_tmp7_);
			_tmp9_ = _tmp8_;
			_tmp5_ = _tmp9_;
			_g_object_unref0 (_tmp7_);
		}
		_tmp0_ = _tmp5_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		GFile* _tmp10_;
		GFile* _tmp11_;
		_tmp10_ = files_file_get_location (file);
		_tmp11_ = _tmp10_;
		if (g_file_has_uri_scheme (_tmp11_, "recent")) {
			gchar* _tmp12_;
			gchar* _tmp13_;
			_tmp12_ = files_file_get_display_target_uri (file);
			_tmp13_ = _tmp12_;
			files_plugins_ctags_rreal_update_file_info_for_recent (self, file, _tmp13_, NULL, NULL);
			_g_free0 (_tmp13_);
		} else {
			files_plugins_ctags_rreal_update_file_info (self, file, NULL, NULL);
		}
	}
}

static void
__lambda7_ (FilesPluginsCTags* self,
            gint ncolor)
{
	GList* _tmp0_;
	_tmp0_ = self->priv->current_selected_files;
	files_plugins_ctags_set_color (self, _tmp0_, ncolor, NULL, NULL);
}

static void
___lambda7__files_plugins_ctags_color_widget_color_changed (FilesPluginsCTagsColorWidget* _sender,
                                                            gint ncolor,
                                                            gpointer self)
{
	__lambda7_ ((FilesPluginsCTags*) self, ncolor);
}

static void
files_plugins_ctags_real_context_menu (FilesPluginsBase* base,
                                       GtkWidget* widget,
                                       GList* selected_files)
{
	FilesPluginsCTags * self;
	gboolean _tmp0_ = FALSE;
	GtkMenu* menu = NULL;
	GtkMenu* _tmp1_;
	FilesPluginsCTagsColorWidget* color_menu_item = NULL;
	FilesPluginsCTagsColorWidget* _tmp2_;
	GList* _tmp3_;
	GList* _tmp4_;
	FilesPluginsCTagsColorWidget* _tmp8_;
	GtkMenu* _tmp9_;
	GtkSeparatorMenuItem* _tmp10_;
	GtkSeparatorMenuItem* _tmp11_;
	GtkMenu* _tmp12_;
	FilesPluginsCTagsColorWidget* _tmp13_;
	self = (FilesPluginsCTags*) base;
	g_return_if_fail (widget != NULL);
	if (selected_files == NULL) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = self->priv->ignore_dir;
	}
	if (_tmp0_) {
		return;
	}
	_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (widget, gtk_menu_get_type ()) ? ((GtkMenu*) widget) : NULL);
	menu = _tmp1_;
	_tmp2_ = files_plugins_ctags_color_widget_new ();
	g_object_ref_sink (_tmp2_);
	color_menu_item = _tmp2_;
	_tmp3_ = g_list_copy_deep (selected_files, (GCopyFunc) g_object_ref, NULL);
	(self->priv->current_selected_files == NULL) ? NULL : (self->priv->current_selected_files = (_g_list_free__g_object_unref0_ (self->priv->current_selected_files), NULL));
	self->priv->current_selected_files = _tmp3_;
	_tmp4_ = self->priv->current_selected_files;
	{
		GList* gof_collection = NULL;
		GList* gof_it = NULL;
		gof_collection = _tmp4_;
		for (gof_it = gof_collection; gof_it != NULL; gof_it = gof_it->next) {
			FilesFile* _tmp5_;
			FilesFile* gof = NULL;
			_tmp5_ = _g_object_ref0 ((FilesFile*) gof_it->data);
			gof = _tmp5_;
			{
				FilesPluginsCTagsColorWidget* _tmp6_;
				FilesFile* _tmp7_;
				_tmp6_ = color_menu_item;
				_tmp7_ = gof;
				files_plugins_ctags_color_widget_check_color (_tmp6_, _tmp7_->color);
				_g_object_unref0 (gof);
			}
		}
	}
	_tmp8_ = color_menu_item;
	g_signal_connect (_tmp8_, "color-changed", (GCallback) ___lambda7__files_plugins_ctags_color_widget_color_changed, self);
	_tmp9_ = menu;
	_tmp10_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	g_object_ref_sink (_tmp10_);
	_tmp11_ = _tmp10_;
	files_plugins_ctags_add_menuitem (self, _tmp9_, (GtkMenuItem*) _tmp11_);
	_g_object_unref0 (_tmp11_);
	_tmp12_ = menu;
	_tmp13_ = color_menu_item;
	files_plugins_ctags_add_menuitem (self, _tmp12_, (GtkMenuItem*) _tmp13_);
	_g_object_unref0 (color_menu_item);
	_g_object_unref0 (menu);
}

static void
files_plugins_ctags_add_menuitem (FilesPluginsCTags* self,
                                  GtkMenu* menu,
                                  GtkMenuItem* menu_item)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (menu != NULL);
	g_return_if_fail (menu_item != NULL);
	gtk_menu_shell_append ((GtkMenuShell*) menu, menu_item);
	gtk_widget_show ((GtkWidget*) menu_item);
}

static void
files_plugins_ctags_set_color_data_free (gpointer _data)
{
	FilesPluginsCtagsSetColorData* _data_;
	_data_ = _data;
	_files_plugins_base_unref0 (_data_->self);
	g_slice_free (FilesPluginsCtagsSetColorData, _data_);
}

static void
files_plugins_ctags_set_color (FilesPluginsCTags* self,
                               GList* files,
                               gint n,
                               GAsyncReadyCallback _callback_,
                               gpointer _user_data_)
{
	FilesPluginsCtagsSetColorData* _data_;
	FilesPluginsCTags* _tmp0_;
	g_return_if_fail (self != NULL);
	_data_ = g_slice_new0 (FilesPluginsCtagsSetColorData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, files_plugins_ctags_set_color_data_free);
	_tmp0_ = _files_plugins_base_ref0 (self);
	_data_->self = _tmp0_;
	_data_->files = files;
	_data_->n = n;
	files_plugins_ctags_set_color_co (_data_);
}

static void
files_plugins_ctags_set_color_finish (FilesPluginsCTags* self,
                                      GAsyncResult* _res_,
                                      GError** error)
{
	FilesPluginsCtagsSetColorData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		return;
	}
}

static void
files_plugins_ctags_set_color_ready (GObject* source_object,
                                     GAsyncResult* _res_,
                                     gpointer _user_data_)
{
	FilesPluginsCtagsSetColorData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	files_plugins_ctags_set_color_co (_data_);
}

static gboolean
files_plugins_ctags_set_color_co (FilesPluginsCtagsSetColorData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = g_ptr_array_new_full ((guint) 0, _g_variant_unref0_);
	_data_->entries = _data_->_tmp0_;
	{
		_data_->file_collection = _data_->files;
		for (_data_->file_it = _data_->file_collection; _data_->file_it != NULL; _data_->file_it = _data_->file_it->next) {
			_data_->file = (FilesFile*) _data_->file_it->data;
			{
				_data_->_tmp1_ = _data_->file;
				if (!G_TYPE_CHECK_INSTANCE_TYPE (_data_->_tmp1_, FILES_TYPE_FILE)) {
					continue;
				}
				_data_->_tmp2_ = _data_->file;
				_data_->_tmp3_ = files_file_get_location (_data_->_tmp2_);
				_data_->_tmp4_ = _data_->_tmp3_;
				if (g_file_has_uri_scheme (_data_->_tmp4_, "recent")) {
					_data_->_tmp5_ = _data_->file;
					_data_->_tmp6_ = files_file_get_display_target_uri (_data_->_tmp5_);
					_data_->_tmp7_ = _data_->_tmp6_;
					_data_->_tmp8_ = files_file_get_by_uri (_data_->_tmp7_);
					_g_object_unref0 (_data_->target_file);
					_data_->target_file = _data_->_tmp8_;
					_g_free0 (_data_->_tmp7_);
				} else {
					_data_->_tmp9_ = _data_->file;
					_data_->_tmp10_ = _g_object_ref0 (_data_->_tmp9_);
					_g_object_unref0 (_data_->target_file);
					_data_->target_file = _data_->_tmp10_;
				}
				_data_->_tmp11_ = _data_->target_file;
				if (_data_->_tmp11_->color != _data_->n) {
					_data_->_tmp12_ = _data_->target_file;
					_data_->_tmp12_->color = _data_->n;
					_data_->_tmp13_ = _data_->target_file;
					_data_->_tmp14_ = _data_->entries;
					files_plugins_ctags_add_entry (_data_->self, _data_->_tmp13_, _data_->_tmp14_);
				}
				_g_object_unref0 (_data_->target_file);
			}
		}
	}
	_data_->_tmp15_ = _data_->entries;
	if (_data_->_tmp15_ != NULL) {
		{
			_data_->_tmp16_ = _data_->self->priv->daemon;
			_data_->_tmp17_ = _data_->entries;
			_data_->_tmp18_ = _data_->_tmp17_->pdata;
			_data_->_tmp18__length1 = _data_->_tmp17_->len;
			_data_->_state_ = 1;
			marlin_daemon_record_uris (_data_->_tmp16_, _data_->_tmp18_, (gint) _data_->_tmp18__length1, files_plugins_ctags_set_color_ready, _data_);
			return FALSE;
			_state_1:
			marlin_daemon_record_uris_finish (_data_->_tmp16_, _data_->_res_, &_data_->_inner_error0_);
			if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
				goto __catch0_g_error;
			}
			{
				_data_->_vala1_file_collection = _data_->files;
				for (_data_->_vala1_file_it = _data_->_vala1_file_collection; _data_->_vala1_file_it != NULL; _data_->_vala1_file_it = _data_->_vala1_file_it->next) {
					_data_->_vala1_file = (FilesFile*) _data_->_vala1_file_it->data;
					{
						_data_->_tmp19_ = _data_->_vala1_file;
						_data_->_tmp20_ = files_file_get_location (_data_->_tmp19_);
						_data_->_tmp21_ = _data_->_tmp20_;
						if (g_file_has_uri_scheme (_data_->_tmp21_, "recent")) {
							_data_->_tmp22_ = _data_->_vala1_file;
							files_plugins_base_update_file_info ((FilesPluginsBase*) _data_->self, _data_->_tmp22_);
							_data_->_tmp23_ = _data_->_vala1_file;
							g_signal_emit_by_name (_data_->_tmp23_, "icon-changed");
						}
					}
				}
			}
		}
		goto __finally0;
		__catch0_g_error:
		{
			_data_->err = _data_->_inner_error0_;
			_data_->_inner_error0_ = NULL;
			_data_->_tmp24_ = _data_->err;
			_data_->_tmp25_ = _data_->_tmp24_->message;
			g_warning ("plugin.vala:319: %s", _data_->_tmp25_);
			_g_error_free0 (_data_->err);
		}
		__finally0:
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
			if (_data_->_inner_error0_->domain == G_IO_ERROR) {
				g_task_return_error (_data_->_async_result, _data_->_inner_error0_);
				_g_ptr_array_unref0 (_data_->entries);
				g_object_unref (_data_->_async_result);
				return FALSE;
			} else {
				_g_ptr_array_unref0 (_data_->entries);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
				g_clear_error (&_data_->_inner_error0_);
				g_object_unref (_data_->_async_result);
				return FALSE;
			}
		}
	}
	_g_ptr_array_unref0 (_data_->entries);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static inline gpointer
files_plugins_ctags_color_button_get_instance_private (FilesPluginsCTagsColorButton* self)
{
	return G_STRUCT_MEMBER_P (self, FilesPluginsCTagsColorButton_private_offset);
}

static FilesPluginsCTagsColorButton*
files_plugins_ctags_color_button_construct (GType object_type,
                                            const gchar* color_name)
{
	FilesPluginsCTagsColorButton * self = NULL;
	g_return_val_if_fail (color_name != NULL, NULL);
	self = (FilesPluginsCTagsColorButton*) g_object_new (object_type, "color-name", color_name, NULL);
	return self;
}

static FilesPluginsCTagsColorButton*
files_plugins_ctags_color_button_new (const gchar* color_name)
{
	return files_plugins_ctags_color_button_construct (FILES_PLUGINS_CTAGS_TYPE_COLOR_BUTTON, color_name);
}

static const gchar*
files_plugins_ctags_color_button_get_color_name (FilesPluginsCTagsColorButton* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_color_name;
	result = _tmp0_;
	return result;
}

static void
files_plugins_ctags_color_button_set_color_name (FilesPluginsCTagsColorButton* self,
                                                 const gchar* value)
{
	gchar* old_value;
	g_return_if_fail (self != NULL);
	old_value = files_plugins_ctags_color_button_get_color_name (self);
	if (g_strcmp0 (value, old_value) != 0) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (value);
		_g_free0 (self->priv->_color_name);
		self->priv->_color_name = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, files_plugins_ctags_color_button_properties[FILES_PLUGINS_CTAGS_COLOR_BUTTON_COLOR_NAME_PROPERTY]);
	}
}

static GObject *
files_plugins_ctags_color_button_constructor (GType type,
                                              guint n_construct_properties,
                                              GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	FilesPluginsCTagsColorButton * self;
	GtkStyleContext* style_context = NULL;
	GtkStyleContext* _tmp0_;
	GtkStyleContext* _tmp1_;
	GtkStyleContext* _tmp2_;
	GtkCssProvider* _tmp3_;
	GtkStyleContext* _tmp4_;
	GtkStyleContext* _tmp5_;
	const gchar* _tmp6_;
	parent_class = G_OBJECT_CLASS (files_plugins_ctags_color_button_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_PLUGINS_CTAGS_TYPE_COLOR_BUTTON, FilesPluginsCTagsColorButton);
	_tmp0_ = gtk_widget_get_style_context ((GtkWidget*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	style_context = _tmp1_;
	_tmp2_ = style_context;
	_tmp3_ = files_plugins_ctags_color_button_css_provider;
	gtk_style_context_add_provider (_tmp2_, (GtkStyleProvider*) _tmp3_, (guint) GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
	_tmp4_ = style_context;
	gtk_style_context_add_class (_tmp4_, GRANITE_STYLE_CLASS_COLOR_BUTTON);
	_tmp5_ = style_context;
	_tmp6_ = self->priv->_color_name;
	gtk_style_context_add_class (_tmp5_, _tmp6_);
	_g_object_unref0 (style_context);
	return obj;
}

static void
files_plugins_ctags_color_button_class_init (FilesPluginsCTagsColorButtonClass * klass,
                                             gpointer klass_data)
{
	GtkCssProvider* _tmp0_;
	GtkCssProvider* _tmp1_;
	files_plugins_ctags_color_button_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &FilesPluginsCTagsColorButton_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_files_plugins_ctags_color_button_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_files_plugins_ctags_color_button_set_property;
	G_OBJECT_CLASS (klass)->constructor = files_plugins_ctags_color_button_constructor;
	G_OBJECT_CLASS (klass)->finalize = files_plugins_ctags_color_button_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_PLUGINS_CTAGS_COLOR_BUTTON_COLOR_NAME_PROPERTY, files_plugins_ctags_color_button_properties[FILES_PLUGINS_CTAGS_COLOR_BUTTON_COLOR_NAME_PROPERTY] = g_param_spec_string ("color-name", "color-name", "color-name", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	_tmp0_ = gtk_css_provider_new ();
	_g_object_unref0 (files_plugins_ctags_color_button_css_provider);
	files_plugins_ctags_color_button_css_provider = _tmp0_;
	_tmp1_ = files_plugins_ctags_color_button_css_provider;
	gtk_css_provider_load_from_resource (_tmp1_, "io/elementary/files/ColorButton.css");
}

static void
files_plugins_ctags_color_button_instance_init (FilesPluginsCTagsColorButton * self,
                                                gpointer klass)
{
	self->priv = files_plugins_ctags_color_button_get_instance_private (self);
}

static void
files_plugins_ctags_color_button_finalize (GObject * obj)
{
	FilesPluginsCTagsColorButton * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_PLUGINS_CTAGS_TYPE_COLOR_BUTTON, FilesPluginsCTagsColorButton);
	_g_free0 (self->priv->_color_name);
	G_OBJECT_CLASS (files_plugins_ctags_color_button_parent_class)->finalize (obj);
}

static GType
files_plugins_ctags_color_button_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FilesPluginsCTagsColorButtonClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) files_plugins_ctags_color_button_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FilesPluginsCTagsColorButton), 0, (GInstanceInitFunc) files_plugins_ctags_color_button_instance_init, NULL };
	GType files_plugins_ctags_color_button_type_id;
	files_plugins_ctags_color_button_type_id = g_type_register_static (gtk_check_button_get_type (), "FilesPluginsCTagsColorButton", &g_define_type_info, 0);
	FilesPluginsCTagsColorButton_private_offset = g_type_add_instance_private (files_plugins_ctags_color_button_type_id, sizeof (FilesPluginsCTagsColorButtonPrivate));
	return files_plugins_ctags_color_button_type_id;
}

static GType
files_plugins_ctags_color_button_get_type (void)
{
	static volatile gsize files_plugins_ctags_color_button_type_id__once = 0;
	if (g_once_init_enter (&files_plugins_ctags_color_button_type_id__once)) {
		GType files_plugins_ctags_color_button_type_id;
		files_plugins_ctags_color_button_type_id = files_plugins_ctags_color_button_get_type_once ();
		g_once_init_leave (&files_plugins_ctags_color_button_type_id__once, files_plugins_ctags_color_button_type_id);
	}
	return files_plugins_ctags_color_button_type_id__once;
}

static void
_vala_files_plugins_ctags_color_button_get_property (GObject * object,
                                                     guint property_id,
                                                     GValue * value,
                                                     GParamSpec * pspec)
{
	FilesPluginsCTagsColorButton * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FILES_PLUGINS_CTAGS_TYPE_COLOR_BUTTON, FilesPluginsCTagsColorButton);
	switch (property_id) {
		case FILES_PLUGINS_CTAGS_COLOR_BUTTON_COLOR_NAME_PROPERTY:
		g_value_set_string (value, files_plugins_ctags_color_button_get_color_name (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_files_plugins_ctags_color_button_set_property (GObject * object,
                                                     guint property_id,
                                                     const GValue * value,
                                                     GParamSpec * pspec)
{
	FilesPluginsCTagsColorButton * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FILES_PLUGINS_CTAGS_TYPE_COLOR_BUTTON, FilesPluginsCTagsColorButton);
	switch (property_id) {
		case FILES_PLUGINS_CTAGS_COLOR_BUTTON_COLOR_NAME_PROPERTY:
		files_plugins_ctags_color_button_set_color_name (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
files_plugins_ctags_color_widget_get_instance_private (FilesPluginsCTagsColorWidget* self)
{
	return G_STRUCT_MEMBER_P (self, FilesPluginsCTagsColorWidget_private_offset);
}

static gboolean
__lambda6_ (FilesPluginsCTagsColorWidget* self,
            FilesPluginsCTagsColorButton* b)
{
	gboolean result;
	g_return_val_if_fail (b != NULL, FALSE);
	gtk_toggle_button_set_active ((GtkToggleButton*) b, FALSE);
	result = TRUE;
	_g_object_unref0 (b);
	return result;
}

static gboolean
___lambda6__gee_forall_func (gpointer g,
                             gpointer self)
{
	gboolean result;
	result = __lambda6_ ((FilesPluginsCTagsColorWidget*) self, (FilesPluginsCTagsColorButton*) g);
	return result;
}

static void
files_plugins_ctags_color_widget_clear_checks (FilesPluginsCTagsColorWidget* self)
{
	GeeArrayList* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->color_buttons;
	gee_abstract_collection_foreach ((GeeAbstractCollection*) _tmp0_, ___lambda6__gee_forall_func, self);
}

static void
files_plugins_ctags_color_widget_check_color (FilesPluginsCTagsColorWidget* self,
                                              gint color)
{
	gboolean _tmp0_ = FALSE;
	GeeArrayList* _tmp4_;
	gpointer _tmp5_;
	FilesPluginsCTagsColorButton* _tmp6_;
	g_return_if_fail (self != NULL);
	if (color == 0) {
		_tmp0_ = TRUE;
	} else {
		GeeArrayList* _tmp1_;
		gint _tmp2_;
		gint _tmp3_;
		_tmp1_ = self->priv->color_buttons;
		_tmp2_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp1_);
		_tmp3_ = _tmp2_;
		_tmp0_ = color > _tmp3_;
	}
	if (_tmp0_) {
		return;
	}
	_tmp4_ = self->priv->color_buttons;
	_tmp5_ = gee_abstract_list_get ((GeeAbstractList*) _tmp4_, color - 1);
	_tmp6_ = (FilesPluginsCTagsColorButton*) _tmp5_;
	gtk_toggle_button_set_active ((GtkToggleButton*) _tmp6_, TRUE);
	_g_object_unref0 (_tmp6_);
}

static gboolean
files_plugins_ctags_color_widget_button_pressed_cb (FilesPluginsCTagsColorWidget* self,
                                                    GdkEventButton* event)
{
	gint color_button_width = 0;
	GeeArrayList* _tmp0_;
	gpointer _tmp1_;
	FilesPluginsCTagsColorButton* _tmp2_;
	gint _tmp3_;
	gint y0 = 0;
	gint x0 = 0;
	gdouble ex = 0.0;
	gdouble ey = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gboolean _tmp6_ = FALSE;
	GtkStyleContext* _tmp7_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->color_buttons;
	_tmp1_ = gee_abstract_list_get ((GeeAbstractList*) _tmp0_, 0);
	_tmp2_ = (FilesPluginsCTagsColorButton*) _tmp1_;
	_tmp3_ = gtk_widget_get_allocated_width ((GtkWidget*) _tmp2_);
	_g_object_unref0 (_tmp2_);
	color_button_width = _tmp3_;
	y0 = (gtk_widget_get_allocated_height ((GtkWidget*) self) - color_button_width) / 2;
	x0 = FILES_PLUGINS_CTAGS_COLOR_WIDGET_COLORBOX_SPACING + color_button_width;
	gdk_event_get_coords ((GdkEvent*) event, &_tmp4_, &_tmp5_);
	ex = _tmp4_;
	ey = _tmp5_;
	if (ey < ((gdouble) y0)) {
		_tmp6_ = TRUE;
	} else {
		_tmp6_ = ey > ((gdouble) (y0 + color_button_width));
	}
	if (_tmp6_) {
		result = TRUE;
		return result;
	}
	_tmp7_ = gtk_widget_get_style_context ((GtkWidget*) self);
	if ((gtk_style_context_get_state (_tmp7_) & GTK_STATE_FLAG_DIR_RTL) == GTK_STATE_FLAG_DIR_RTL) {
		gint width = 0;
		gint x = 0;
		width = gtk_widget_get_allocated_width ((GtkWidget*) self);
		x = width - 27;
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp8_ = FALSE;
				_tmp8_ = TRUE;
				while (TRUE) {
					gboolean _tmp10_ = FALSE;
					if (!_tmp8_) {
						gint _tmp9_;
						_tmp9_ = i;
						i = _tmp9_ + 1;
					}
					_tmp8_ = FALSE;
					if (!(i < G_N_ELEMENTS (FILES_PREFERENCES_TAGS_COLORS))) {
						break;
					}
					if (ex <= ((gdouble) x)) {
						_tmp10_ = ex >= ((gdouble) (x - color_button_width));
					} else {
						_tmp10_ = FALSE;
					}
					if (_tmp10_) {
						g_signal_emit (self, files_plugins_ctags_color_widget_signals[FILES_PLUGINS_CTAGS_COLOR_WIDGET_COLOR_CHANGED_SIGNAL], 0, i);
						files_plugins_ctags_color_widget_clear_checks (self);
						files_plugins_ctags_color_widget_check_color (self, i);
						break;
					}
					x -= x0;
				}
			}
		}
	} else {
		gint x = 0;
		x = 27;
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp11_ = FALSE;
				_tmp11_ = TRUE;
				while (TRUE) {
					gboolean _tmp13_ = FALSE;
					if (!_tmp11_) {
						gint _tmp12_;
						_tmp12_ = i;
						i = _tmp12_ + 1;
					}
					_tmp11_ = FALSE;
					if (!(i < G_N_ELEMENTS (FILES_PREFERENCES_TAGS_COLORS))) {
						break;
					}
					if (ex >= ((gdouble) x)) {
						_tmp13_ = ex <= ((gdouble) (x + color_button_width));
					} else {
						_tmp13_ = FALSE;
					}
					if (_tmp13_) {
						g_signal_emit (self, files_plugins_ctags_color_widget_signals[FILES_PLUGINS_CTAGS_COLOR_WIDGET_COLOR_CHANGED_SIGNAL], 0, i);
						files_plugins_ctags_color_widget_clear_checks (self);
						files_plugins_ctags_color_widget_check_color (self, i);
						break;
					}
					x += x0;
				}
			}
		}
	}
	result = TRUE;
	return result;
}

static FilesPluginsCTagsColorWidget*
files_plugins_ctags_color_widget_construct (GType object_type)
{
	FilesPluginsCTagsColorWidget * self = NULL;
	self = (FilesPluginsCTagsColorWidget*) g_object_new (object_type, NULL);
	return self;
}

static FilesPluginsCTagsColorWidget*
files_plugins_ctags_color_widget_new (void)
{
	return files_plugins_ctags_color_widget_construct (FILES_PLUGINS_CTAGS_TYPE_COLOR_WIDGET);
}

static gboolean
_files_plugins_ctags_color_widget_button_pressed_cb_gtk_widget_button_press_event (GtkWidget* _sender,
                                                                                   GdkEventButton* event,
                                                                                   gpointer self)
{
	gboolean result;
	result = files_plugins_ctags_color_widget_button_pressed_cb ((FilesPluginsCTagsColorWidget*) self, event);
	return result;
}

static GObject *
files_plugins_ctags_color_widget_constructor (GType type,
                                              guint n_construct_properties,
                                              GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	FilesPluginsCTagsColorWidget * self;
	FilesPluginsCTagsColorButton* color_button_remove = NULL;
	FilesPluginsCTagsColorButton* _tmp0_;
	GeeArrayList* _tmp1_;
	GeeArrayList* _tmp2_;
	FilesPluginsCTagsColorButton* _tmp3_;
	FilesPluginsCTagsColorButton* _tmp4_;
	GeeArrayList* _tmp5_;
	FilesPluginsCTagsColorButton* _tmp6_;
	FilesPluginsCTagsColorButton* _tmp7_;
	GeeArrayList* _tmp8_;
	FilesPluginsCTagsColorButton* _tmp9_;
	FilesPluginsCTagsColorButton* _tmp10_;
	GeeArrayList* _tmp11_;
	FilesPluginsCTagsColorButton* _tmp12_;
	FilesPluginsCTagsColorButton* _tmp13_;
	GeeArrayList* _tmp14_;
	FilesPluginsCTagsColorButton* _tmp15_;
	FilesPluginsCTagsColorButton* _tmp16_;
	GeeArrayList* _tmp17_;
	FilesPluginsCTagsColorButton* _tmp18_;
	FilesPluginsCTagsColorButton* _tmp19_;
	GeeArrayList* _tmp20_;
	FilesPluginsCTagsColorButton* _tmp21_;
	FilesPluginsCTagsColorButton* _tmp22_;
	GeeArrayList* _tmp23_;
	FilesPluginsCTagsColorButton* _tmp24_;
	FilesPluginsCTagsColorButton* _tmp25_;
	GeeArrayList* _tmp26_;
	FilesPluginsCTagsColorButton* _tmp27_;
	FilesPluginsCTagsColorButton* _tmp28_;
	GeeArrayList* _tmp29_;
	FilesPluginsCTagsColorButton* _tmp30_;
	FilesPluginsCTagsColorButton* _tmp31_;
	GtkGrid* colorbox = NULL;
	GtkGrid* _tmp32_ = NULL;
	GtkGrid* _tmp33_;
	FilesPluginsCTagsColorButton* _tmp34_;
	GtkGrid* _tmp44_;
	GError* _inner_error0_ = NULL;
	parent_class = G_OBJECT_CLASS (files_plugins_ctags_color_widget_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_PLUGINS_CTAGS_TYPE_COLOR_WIDGET, FilesPluginsCTagsColorWidget);
	_tmp0_ = files_plugins_ctags_color_button_new ("none");
	g_object_ref_sink (_tmp0_);
	color_button_remove = _tmp0_;
	_tmp1_ = gee_array_list_new (FILES_PLUGINS_CTAGS_TYPE_COLOR_BUTTON, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->color_buttons);
	self->priv->color_buttons = _tmp1_;
	_tmp2_ = self->priv->color_buttons;
	_tmp3_ = files_plugins_ctags_color_button_new ("blue");
	g_object_ref_sink (_tmp3_);
	_tmp4_ = _tmp3_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp2_, _tmp4_);
	_g_object_unref0 (_tmp4_);
	_tmp5_ = self->priv->color_buttons;
	_tmp6_ = files_plugins_ctags_color_button_new ("mint");
	g_object_ref_sink (_tmp6_);
	_tmp7_ = _tmp6_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp5_, _tmp7_);
	_g_object_unref0 (_tmp7_);
	_tmp8_ = self->priv->color_buttons;
	_tmp9_ = files_plugins_ctags_color_button_new ("green");
	g_object_ref_sink (_tmp9_);
	_tmp10_ = _tmp9_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp8_, _tmp10_);
	_g_object_unref0 (_tmp10_);
	_tmp11_ = self->priv->color_buttons;
	_tmp12_ = files_plugins_ctags_color_button_new ("yellow");
	g_object_ref_sink (_tmp12_);
	_tmp13_ = _tmp12_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp11_, _tmp13_);
	_g_object_unref0 (_tmp13_);
	_tmp14_ = self->priv->color_buttons;
	_tmp15_ = files_plugins_ctags_color_button_new ("orange");
	g_object_ref_sink (_tmp15_);
	_tmp16_ = _tmp15_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp14_, _tmp16_);
	_g_object_unref0 (_tmp16_);
	_tmp17_ = self->priv->color_buttons;
	_tmp18_ = files_plugins_ctags_color_button_new ("red");
	g_object_ref_sink (_tmp18_);
	_tmp19_ = _tmp18_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp17_, _tmp19_);
	_g_object_unref0 (_tmp19_);
	_tmp20_ = self->priv->color_buttons;
	_tmp21_ = files_plugins_ctags_color_button_new ("pink");
	g_object_ref_sink (_tmp21_);
	_tmp22_ = _tmp21_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp20_, _tmp22_);
	_g_object_unref0 (_tmp22_);
	_tmp23_ = self->priv->color_buttons;
	_tmp24_ = files_plugins_ctags_color_button_new ("purple");
	g_object_ref_sink (_tmp24_);
	_tmp25_ = _tmp24_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp23_, _tmp25_);
	_g_object_unref0 (_tmp25_);
	_tmp26_ = self->priv->color_buttons;
	_tmp27_ = files_plugins_ctags_color_button_new ("brown");
	g_object_ref_sink (_tmp27_);
	_tmp28_ = _tmp27_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp26_, _tmp28_);
	_g_object_unref0 (_tmp28_);
	_tmp29_ = self->priv->color_buttons;
	_tmp30_ = files_plugins_ctags_color_button_new ("slate");
	g_object_ref_sink (_tmp30_);
	_tmp31_ = _tmp30_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp29_, _tmp31_);
	_g_object_unref0 (_tmp31_);
	_tmp32_ = (GtkGrid*) gtk_grid_new ();
	gtk_grid_set_column_spacing (_tmp32_, FILES_PLUGINS_CTAGS_COLOR_WIDGET_COLORBOX_SPACING);
	gtk_widget_set_margin_start ((GtkWidget*) _tmp32_, 3);
	gtk_widget_set_halign ((GtkWidget*) _tmp32_, GTK_ALIGN_START);
	g_object_ref_sink (_tmp32_);
	colorbox = _tmp32_;
	_tmp33_ = colorbox;
	_tmp34_ = color_button_remove;
	gtk_container_add ((GtkContainer*) _tmp33_, (GtkWidget*) _tmp34_);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp35_ = FALSE;
			_tmp35_ = TRUE;
			while (TRUE) {
				GeeArrayList* _tmp37_;
				gint _tmp38_;
				gint _tmp39_;
				GtkGrid* _tmp40_;
				GeeArrayList* _tmp41_;
				gpointer _tmp42_;
				FilesPluginsCTagsColorButton* _tmp43_;
				if (!_tmp35_) {
					gint _tmp36_;
					_tmp36_ = i;
					i = _tmp36_ + 1;
				}
				_tmp35_ = FALSE;
				_tmp37_ = self->priv->color_buttons;
				_tmp38_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp37_);
				_tmp39_ = _tmp38_;
				if (!(i < _tmp39_)) {
					break;
				}
				_tmp40_ = colorbox;
				_tmp41_ = self->priv->color_buttons;
				_tmp42_ = gee_abstract_list_get ((GeeAbstractList*) _tmp41_, i);
				_tmp43_ = (FilesPluginsCTagsColorButton*) _tmp42_;
				gtk_container_add ((GtkContainer*) _tmp40_, (GtkWidget*) _tmp43_);
				_g_object_unref0 (_tmp43_);
			}
		}
	}
	_tmp44_ = colorbox;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp44_);
	{
		gchar* css = NULL;
		gchar* _tmp45_;
		GtkCssProvider* css_provider = NULL;
		GtkCssProvider* _tmp46_;
		GtkCssProvider* _tmp47_;
		const gchar* _tmp48_;
		GtkStyleContext* style_context = NULL;
		GtkStyleContext* _tmp49_;
		GtkStyleContext* _tmp50_;
		GtkStyleContext* _tmp51_;
		GtkCssProvider* _tmp52_;
		GtkStyleContext* _tmp53_;
		_tmp45_ = g_strdup (".nohover { background: none; }");
		css = _tmp45_;
		_tmp46_ = gtk_css_provider_new ();
		css_provider = _tmp46_;
		_tmp47_ = css_provider;
		_tmp48_ = css;
		gtk_css_provider_load_from_data (_tmp47_, _tmp48_, (gssize) -1, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (css_provider);
			_g_free0 (css);
			goto __catch0_g_error;
		}
		_tmp49_ = gtk_widget_get_style_context ((GtkWidget*) self);
		_tmp50_ = _g_object_ref0 (_tmp49_);
		style_context = _tmp50_;
		_tmp51_ = style_context;
		_tmp52_ = css_provider;
		gtk_style_context_add_provider (_tmp51_, (GtkStyleProvider*) _tmp52_, (guint) GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
		_tmp53_ = style_context;
		gtk_style_context_add_class (_tmp53_, "nohover");
		_g_object_unref0 (style_context);
		_g_object_unref0 (css_provider);
		_g_free0 (css);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp54_;
		const gchar* _tmp55_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp54_ = e;
		_tmp55_ = _tmp54_->message;
		g_warning ("plugin.vala:388: Failed to parse css style : %s", _tmp55_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_object_unref0 (colorbox);
		_g_object_unref0 (color_button_remove);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
	}
	gtk_widget_show_all ((GtkWidget*) self);
	g_signal_connect_object ((GtkWidget*) self, "button-press-event", (GCallback) _files_plugins_ctags_color_widget_button_pressed_cb_gtk_widget_button_press_event, self, 0);
	_g_object_unref0 (colorbox);
	_g_object_unref0 (color_button_remove);
	return obj;
}

static void
files_plugins_ctags_color_widget_class_init (FilesPluginsCTagsColorWidgetClass * klass,
                                             gpointer klass_data)
{
	files_plugins_ctags_color_widget_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &FilesPluginsCTagsColorWidget_private_offset);
	G_OBJECT_CLASS (klass)->constructor = files_plugins_ctags_color_widget_constructor;
	G_OBJECT_CLASS (klass)->finalize = files_plugins_ctags_color_widget_finalize;
	files_plugins_ctags_color_widget_signals[FILES_PLUGINS_CTAGS_COLOR_WIDGET_COLOR_CHANGED_SIGNAL] = g_signal_new ("color-changed", FILES_PLUGINS_CTAGS_TYPE_COLOR_WIDGET, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
}

static void
files_plugins_ctags_color_widget_instance_init (FilesPluginsCTagsColorWidget * self,
                                                gpointer klass)
{
	self->priv = files_plugins_ctags_color_widget_get_instance_private (self);
}

static void
files_plugins_ctags_color_widget_finalize (GObject * obj)
{
	FilesPluginsCTagsColorWidget * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_PLUGINS_CTAGS_TYPE_COLOR_WIDGET, FilesPluginsCTagsColorWidget);
	_g_object_unref0 (self->priv->color_buttons);
	G_OBJECT_CLASS (files_plugins_ctags_color_widget_parent_class)->finalize (obj);
}

static GType
files_plugins_ctags_color_widget_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FilesPluginsCTagsColorWidgetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) files_plugins_ctags_color_widget_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FilesPluginsCTagsColorWidget), 0, (GInstanceInitFunc) files_plugins_ctags_color_widget_instance_init, NULL };
	GType files_plugins_ctags_color_widget_type_id;
	files_plugins_ctags_color_widget_type_id = g_type_register_static (gtk_menu_item_get_type (), "FilesPluginsCTagsColorWidget", &g_define_type_info, 0);
	FilesPluginsCTagsColorWidget_private_offset = g_type_add_instance_private (files_plugins_ctags_color_widget_type_id, sizeof (FilesPluginsCTagsColorWidgetPrivate));
	return files_plugins_ctags_color_widget_type_id;
}

static GType
files_plugins_ctags_color_widget_get_type (void)
{
	static volatile gsize files_plugins_ctags_color_widget_type_id__once = 0;
	if (g_once_init_enter (&files_plugins_ctags_color_widget_type_id__once)) {
		GType files_plugins_ctags_color_widget_type_id;
		files_plugins_ctags_color_widget_type_id = files_plugins_ctags_color_widget_get_type_once ();
		g_once_init_leave (&files_plugins_ctags_color_widget_type_id__once, files_plugins_ctags_color_widget_type_id);
	}
	return files_plugins_ctags_color_widget_type_id__once;
}

static void
files_plugins_ctags_class_init (FilesPluginsCTagsClass * klass,
                                gpointer klass_data)
{
	files_plugins_ctags_parent_class = g_type_class_peek_parent (klass);
	((FilesPluginsBaseClass *) klass)->finalize = files_plugins_ctags_finalize;
	g_type_class_adjust_private_offset (klass, &FilesPluginsCTags_private_offset);
	((FilesPluginsBaseClass *) klass)->directory_loaded = (void (*) (FilesPluginsBase*, GtkApplicationWindow*, FilesAbstractSlot*, FilesFile*)) files_plugins_ctags_real_directory_loaded;
	((FilesPluginsBaseClass *) klass)->update_file_info = (void (*) (FilesPluginsBase*, FilesFile*)) files_plugins_ctags_real_update_file_info;
	((FilesPluginsBaseClass *) klass)->context_menu = (void (*) (FilesPluginsBase*, GtkWidget*, GList*)) files_plugins_ctags_real_context_menu;
}

static void
files_plugins_ctags_instance_init (FilesPluginsCTags * self,
                                   gpointer klass)
{
	self->priv = files_plugins_ctags_get_instance_private (self);
	self->priv->idle_consume_unknowns = (guint) 0;
	self->priv->t_consume_knowns = (guint) 0;
}

static void
files_plugins_ctags_finalize (FilesPluginsBase * obj)
{
	FilesPluginsCTags * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_PLUGINS_TYPE_CTAGS, FilesPluginsCTags);
	_g_object_unref0 (self->priv->daemon);
	(self->priv->unknowns == NULL) ? NULL : (self->priv->unknowns = (_g_queue_free__g_object_unref0_ (self->priv->unknowns), NULL));
	(self->priv->knowns == NULL) ? NULL : (self->priv->knowns = (_g_queue_free__g_object_unref0_ (self->priv->knowns), NULL));
	_g_object_unref0 (self->priv->cancellable);
	(self->priv->current_selected_files == NULL) ? NULL : (self->priv->current_selected_files = (_g_list_free__g_object_unref0_ (self->priv->current_selected_files), NULL));
	FILES_PLUGINS_BASE_CLASS (files_plugins_ctags_parent_class)->finalize (obj);
}

static GType
files_plugins_ctags_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FilesPluginsCTagsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) files_plugins_ctags_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FilesPluginsCTags), 0, (GInstanceInitFunc) files_plugins_ctags_instance_init, NULL };
	GType files_plugins_ctags_type_id;
	files_plugins_ctags_type_id = g_type_register_static (FILES_PLUGINS_TYPE_BASE, "FilesPluginsCTags", &g_define_type_info, 0);
	FilesPluginsCTags_private_offset = g_type_add_instance_private (files_plugins_ctags_type_id, sizeof (FilesPluginsCTagsPrivate));
	return files_plugins_ctags_type_id;
}

GType
files_plugins_ctags_get_type (void)
{
	static volatile gsize files_plugins_ctags_type_id__once = 0;
	if (g_once_init_enter (&files_plugins_ctags_type_id__once)) {
		GType files_plugins_ctags_type_id;
		files_plugins_ctags_type_id = files_plugins_ctags_get_type_once ();
		g_once_init_leave (&files_plugins_ctags_type_id__once, files_plugins_ctags_type_id);
	}
	return files_plugins_ctags_type_id__once;
}

FilesPluginsBase*
module_init (void)
{
	FilesPluginsCTags* _tmp0_;
	FilesPluginsBase* result;
	_tmp0_ = files_plugins_ctags_new ();
	result = (FilesPluginsBase*) _tmp0_;
	return result;
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

