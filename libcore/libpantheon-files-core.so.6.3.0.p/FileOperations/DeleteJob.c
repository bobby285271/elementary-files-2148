/* DeleteJob.c generated by valac 0.56.3, the Vala compiler
 * generated from DeleteJob.vala, do not modify */

/* Copyright 2022 elementary LLC (https://elementary.io)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, Inc.,; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */

#include "pantheon-files-core.h"
#include <gtk/gtk.h>
#include <glib.h>
#include <gio/gio.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>

#define _g_free0(var) (var = (g_free (var), NULL))

static gpointer marlin_file_operations_delete_job_parent_class = NULL;

static void _g_object_unref0_ (gpointer var);
static inline void _g_list_free__g_object_unref0_ (GList* self);
static void marlin_file_operations_delete_job_finalize (FilesFileOperationsCommonJob * obj);
static GType marlin_file_operations_delete_job_get_type_once (void);
static inline gpointer _vala_memdup2 (gconstpointer mem,
                        gsize byte_size);

static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}

static inline void
_g_list_free__g_object_unref0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_object_unref0_);
}

FilesFileOperationsDeleteJob*
marlin_file_operations_delete_job_construct (GType object_type,
                                             GtkWindow* parent_window,
                                             GList* files,
                                             gboolean try_trash)
{
	FilesFileOperationsDeleteJob* self = NULL;
	GList* _tmp0_;
	self = (FilesFileOperationsDeleteJob*) marlin_file_operations_common_job_construct (object_type, parent_window);
	_tmp0_ = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);
	(self->files == NULL) ? NULL : (self->files = (_g_list_free__g_object_unref0_ (self->files), NULL));
	self->files = _tmp0_;
	self->try_trash = try_trash;
	self->user_cancel = FALSE;
	return self;
}

FilesFileOperationsDeleteJob*
marlin_file_operations_delete_job_new (GtkWindow* parent_window,
                                       GList* files,
                                       gboolean try_trash)
{
	return marlin_file_operations_delete_job_construct (MARLIN_FILE_OPERATIONS_TYPE_DELETE_JOB, parent_window, files, try_trash);
}

gboolean
marlin_file_operations_delete_job_confirm_delete_from_trash (FilesFileOperationsDeleteJob* self,
                                                             GList* to_delete_files)
{
	gchar* prompt = NULL;
	guint file_count = 0U;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	file_count = g_list_length (to_delete_files);
	if (file_count == ((guint) 1)) {
		gchar* basename = NULL;
		gconstpointer _tmp0_;
		gchar* _tmp1_;
		const gchar* _tmp2_;
		gchar* _tmp3_;
		_tmp0_ = to_delete_files->data;
		_tmp1_ = files_file_utils_custom_basename_from_file ((GFile*) _tmp0_);
		basename = _tmp1_;
		_tmp2_ = basename;
		_tmp3_ = g_strdup_printf (_ ("Are you sure you want to permanently delete \"%s\" from the trash?"), _tmp2_);
		_g_free0 (prompt);
		prompt = _tmp3_;
		_g_free0 (basename);
	} else {
		gchar* _tmp4_;
		_tmp4_ = g_strdup_printf (ngettext ("Are you sure you want to permanently delete the %'d selected item from" \
" the trash?", "Are you sure you want to permanently delete the %'d selected items fro" \
"m the trash?", (gulong) file_count), file_count);
		_g_free0 (prompt);
		prompt = _tmp4_;
	}
	_tmp5_ = prompt;
	_tmp6_ = g_strdup (_tmp5_);
	_tmp7_ = g_strdup (_ ("If you delete an item, it will be permanently lost."));
	result = marlin_file_operations_common_job_run_warning ((FilesFileOperationsCommonJob*) self, _tmp6_, _tmp7_, NULL, FALSE, CANCEL, DELETE, NULL) == 1;
	_g_free0 (prompt);
	return result;
}

gboolean
marlin_file_operations_delete_job_confirm_delete_directly (FilesFileOperationsDeleteJob* self,
                                                           GList* to_delete_files)
{
	gchar* prompt = NULL;
	guint file_count = 0U;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	file_count = g_list_length (to_delete_files);
	if (file_count == ((guint) 1)) {
		gchar* basename = NULL;
		gconstpointer _tmp0_;
		gchar* _tmp1_;
		const gchar* _tmp2_;
		gchar* _tmp3_;
		_tmp0_ = to_delete_files->data;
		_tmp1_ = files_file_utils_custom_basename_from_file ((GFile*) _tmp0_);
		basename = _tmp1_;
		_tmp2_ = basename;
		_tmp3_ = g_strdup_printf (_ ("Permanently delete “%s”?"), _tmp2_);
		_g_free0 (prompt);
		prompt = _tmp3_;
		_g_free0 (basename);
	} else {
		gchar* _tmp4_;
		_tmp4_ = g_strdup_printf (ngettext ("Are you sure you want to permanently delete the %'d selected item?", "Are you sure you want to permanently delete the %'d selected items?", (gulong) file_count), file_count);
		_g_free0 (prompt);
		prompt = _tmp4_;
	}
	_tmp5_ = prompt;
	_tmp6_ = g_strdup (_tmp5_);
	_tmp7_ = g_strdup (_ ("Deleted items are not sent to Trash and are not recoverable."));
	result = marlin_file_operations_common_job_run_warning ((FilesFileOperationsCommonJob*) self, _tmp6_, _tmp7_, NULL, FALSE, CANCEL, DELETE, NULL) == 1;
	_g_free0 (prompt);
	return result;
}

static void
marlin_file_operations_delete_job_class_init (FilesFileOperationsDeleteJobClass * klass,
                                              gpointer klass_data)
{
	marlin_file_operations_delete_job_parent_class = g_type_class_peek_parent (klass);
	((FilesFileOperationsCommonJobClass *) klass)->finalize = marlin_file_operations_delete_job_finalize;
}

static void
marlin_file_operations_delete_job_instance_init (FilesFileOperationsDeleteJob * self,
                                                 gpointer klass)
{
}

static void
marlin_file_operations_delete_job_finalize (FilesFileOperationsCommonJob * obj)
{
	FilesFileOperationsDeleteJob * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, MARLIN_FILE_OPERATIONS_TYPE_DELETE_JOB, FilesFileOperationsDeleteJob);
	files_file_changes_consume_changes (TRUE);
	(self->files == NULL) ? NULL : (self->files = (_g_list_free__g_object_unref0_ (self->files), NULL));
	MARLIN_FILE_OPERATIONS_COMMON_JOB_CLASS (marlin_file_operations_delete_job_parent_class)->finalize (obj);
}

static GType
marlin_file_operations_delete_job_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FilesFileOperationsDeleteJobClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) marlin_file_operations_delete_job_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FilesFileOperationsDeleteJob), 0, (GInstanceInitFunc) marlin_file_operations_delete_job_instance_init, NULL };
	GType marlin_file_operations_delete_job_type_id;
	marlin_file_operations_delete_job_type_id = g_type_register_static (MARLIN_FILE_OPERATIONS_TYPE_COMMON_JOB, "FilesFileOperationsDeleteJob", &g_define_type_info, 0);
	return marlin_file_operations_delete_job_type_id;
}

GType
marlin_file_operations_delete_job_get_type (void)
{
	static volatile gsize marlin_file_operations_delete_job_type_id__once = 0;
	if (g_once_init_enter (&marlin_file_operations_delete_job_type_id__once)) {
		GType marlin_file_operations_delete_job_type_id;
		marlin_file_operations_delete_job_type_id = marlin_file_operations_delete_job_get_type_once ();
		g_once_init_leave (&marlin_file_operations_delete_job_type_id__once, marlin_file_operations_delete_job_type_id);
	}
	return marlin_file_operations_delete_job_type_id__once;
}

static inline gpointer
_vala_memdup2 (gconstpointer mem,
               gsize byte_size)
{
	gpointer new_mem;
	if (mem && byte_size != 0) {
		new_mem = g_malloc (byte_size);
		memcpy (new_mem, mem, byte_size);
	} else {
		new_mem = NULL;
	}
	return new_mem;
}

