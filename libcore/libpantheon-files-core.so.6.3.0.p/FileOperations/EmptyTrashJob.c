/* EmptyTrashJob.c generated by valac 0.56.3, the Vala compiler
 * generated from EmptyTrashJob.vala, do not modify */

/* Copyright 2020 elementary LLC (https://elementary.io)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, Inc.,; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */

#include "pantheon-files-core.h"
#include <glib.h>
#include <gio/gio.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <granite.h>

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _marlin_file_operations_common_job_unref0(var) ((var == NULL) ? NULL : (var = (marlin_file_operations_common_job_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _MarlinFileOperationsEmptyTrashJobDeleteTrashFileData MarlinFileOperationsEmptyTrashJobDeleteTrashFileData;
typedef struct _MarlinFileOperationsEmptyTrashJobEmptyTrashData MarlinFileOperationsEmptyTrashJobEmptyTrashData;

struct _FilesFileOperationsEmptyTrashJobPrivate {
	GList* trash_dirs;
};

struct _MarlinFileOperationsEmptyTrashJobDeleteTrashFileData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	FilesFileOperationsEmptyTrashJob* self;
	GFile* file;
	gboolean delete_file;
	gboolean delete_children;
	GFileEnumerator* enumerator;
	GCancellable* _tmp0_;
	GFileEnumerator* _tmp1_;
	GList* infos;
	GFileEnumerator* _tmp2_;
	GCancellable* _tmp3_;
	GList* _tmp4_;
	GList* _tmp5_;
	gconstpointer _tmp6_;
	GList* _tmp7_;
	GList* info_collection;
	GList* info_it;
	GFileInfo* info;
	GFile* child;
	GFileInfo* _tmp8_;
	const gchar* _tmp9_;
	GFile* _tmp10_;
	GFile* _tmp11_;
	GFileInfo* _tmp12_;
	GList* _tmp13_;
	GFileEnumerator* _tmp14_;
	GCancellable* _tmp15_;
	GList* _tmp16_;
	GList* _tmp17_;
	GError* e;
	GError* _tmp18_;
	const gchar* _tmp19_;
	GCancellable* _tmp20_;
	GError* _vala1_e;
	GError* _tmp21_;
	const gchar* _tmp22_;
	GError* _inner_error0_;
};

struct _MarlinFileOperationsEmptyTrashJobEmptyTrashData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	FilesFileOperationsEmptyTrashJob* self;
	gboolean _tmp0_;
	FilesPreferences* _tmp1_;
	FilesPreferences* _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	PFProgressInfo* _tmp6_;
	GList* _tmp7_;
	GList* dir_collection;
	GList* dir_it;
	GFile* dir;
	GFile* _tmp8_;
	FilesUndoManager* _tmp9_;
	PFSoundManager* _tmp10_;
};

static gint FilesFileOperationsEmptyTrashJob_private_offset;
static gpointer marlin_file_operations_empty_trash_job_parent_class = NULL;

static void _g_object_unref0_ (gpointer var);
static inline void _g_list_free__g_object_unref0_ (GList* self);
static gboolean marlin_file_operations_empty_trash_job_confirm_empty_trash (FilesFileOperationsEmptyTrashJob* self);
static void marlin_file_operations_empty_trash_job_delete_trash_file_data_free (gpointer _data);
static void marlin_file_operations_empty_trash_job_delete_trash_file (FilesFileOperationsEmptyTrashJob* self,
                                                               GFile* file,
                                                               gboolean delete_file,
                                                               gboolean delete_children,
                                                               GAsyncReadyCallback _callback_,
                                                               gpointer _user_data_);
static void marlin_file_operations_empty_trash_job_delete_trash_file_finish (FilesFileOperationsEmptyTrashJob* self,
                                                                      GAsyncResult* _res_);
static gboolean marlin_file_operations_empty_trash_job_delete_trash_file_co (MarlinFileOperationsEmptyTrashJobDeleteTrashFileData* _data_);
static void marlin_file_operations_empty_trash_job_delete_trash_file_ready (GObject* source_object,
                                                                     GAsyncResult* _res_,
                                                                     gpointer _user_data_);
static void marlin_file_operations_empty_trash_job_empty_trash_data_free (gpointer _data);
static gboolean marlin_file_operations_empty_trash_job_empty_trash_co (MarlinFileOperationsEmptyTrashJobEmptyTrashData* _data_);
static void marlin_file_operations_empty_trash_job_empty_trash_ready (GObject* source_object,
                                                               GAsyncResult* _res_,
                                                               gpointer _user_data_);
static void marlin_file_operations_empty_trash_job_finalize (FilesFileOperationsCommonJob * obj);
static GType marlin_file_operations_empty_trash_job_get_type_once (void);
static inline gpointer _vala_memdup2 (gconstpointer mem,
                        gsize byte_size);

static inline gpointer
marlin_file_operations_empty_trash_job_get_instance_private (FilesFileOperationsEmptyTrashJob* self)
{
	return G_STRUCT_MEMBER_P (self, FilesFileOperationsEmptyTrashJob_private_offset);
}

static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}

static inline void
_g_list_free__g_object_unref0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_object_unref0_);
}

FilesFileOperationsEmptyTrashJob*
marlin_file_operations_empty_trash_job_construct (GType object_type,
                                                  GtkWindow* parent_window,
                                                  GList* trash_dirs)
{
	FilesFileOperationsEmptyTrashJob* self = NULL;
	self = (FilesFileOperationsEmptyTrashJob*) marlin_file_operations_common_job_construct (object_type, parent_window);
	if (trash_dirs != NULL) {
		GList* _tmp0_;
		_tmp0_ = trash_dirs;
		trash_dirs = NULL;
		(self->priv->trash_dirs == NULL) ? NULL : (self->priv->trash_dirs = (_g_list_free__g_object_unref0_ (self->priv->trash_dirs), NULL));
		self->priv->trash_dirs = _tmp0_;
	} else {
		GFile* _tmp1_;
		(self->priv->trash_dirs == NULL) ? NULL : (self->priv->trash_dirs = (_g_list_free__g_object_unref0_ (self->priv->trash_dirs), NULL));
		self->priv->trash_dirs = NULL;
		_tmp1_ = g_file_new_for_uri ("trash:");
		self->priv->trash_dirs = g_list_prepend (self->priv->trash_dirs, _tmp1_);
	}
	(trash_dirs == NULL) ? NULL : (trash_dirs = (_g_list_free__g_object_unref0_ (trash_dirs), NULL));
	return self;
}

FilesFileOperationsEmptyTrashJob*
marlin_file_operations_empty_trash_job_new (GtkWindow* parent_window,
                                            GList* trash_dirs)
{
	return marlin_file_operations_empty_trash_job_construct (MARLIN_FILE_OPERATIONS_TYPE_EMPTY_TRASH_JOB, parent_window, trash_dirs);
}

static gboolean
marlin_file_operations_empty_trash_job_confirm_empty_trash (FilesFileOperationsEmptyTrashJob* self)
{
	GFile* first_dir = NULL;
	GList* _tmp0_;
	gconstpointer _tmp1_;
	GFile* _tmp2_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->trash_dirs;
	_tmp1_ = g_list_nth_data (_tmp0_, (guint) 0);
	first_dir = (GFile*) _tmp1_;
	_tmp2_ = first_dir;
	if (_tmp2_ != NULL) {
		const gchar* primary = NULL;
		const gchar* secondary = NULL;
		GFile* _tmp3_;
		GraniteMessageDialog* message_dialog = NULL;
		const gchar* _tmp4_;
		const gchar* _tmp5_;
		GraniteMessageDialog* _tmp6_;
		GraniteMessageDialog* _tmp7_;
		GtkWindow* _tmp8_;
		GtkWidget* empty_button = NULL;
		GraniteMessageDialog* _tmp9_;
		GtkWidget* _tmp10_;
		GtkWidget* _tmp11_;
		GtkStyleContext* _tmp12_;
		GtkResponseType response = 0;
		GraniteMessageDialog* _tmp13_;
		GraniteMessageDialog* _tmp14_;
		primary = NULL;
		secondary = NULL;
		_tmp3_ = first_dir;
		if (g_file_has_uri_scheme (_tmp3_, "trash")) {
			primary = _ ("Permanently delete all items from Trash?");
			secondary = _ ("All items in all trash directories, including those on any mounted ext" \
"ernal drives, will be permanently deleted.");
		} else {
			primary = _ ("Permanently delete all items from Trash on this mount?");
			secondary = _ ("All items in the trash on this mount, will be permanently deleted.");
		}
		_tmp4_ = primary;
		_tmp5_ = secondary;
		_tmp6_ = granite_message_dialog_new_with_image_from_icon_name (_tmp4_, _tmp5_, "dialog-warning", GTK_BUTTONS_CANCEL);
		g_object_ref_sink (_tmp6_);
		message_dialog = _tmp6_;
		_tmp7_ = message_dialog;
		_tmp8_ = ((FilesFileOperationsCommonJob*) self)->parent_window;
		gtk_window_set_transient_for ((GtkWindow*) _tmp7_, _tmp8_);
		_tmp9_ = message_dialog;
		_tmp10_ = gtk_dialog_add_button ((GtkDialog*) _tmp9_, EMPTY_TRASH, (gint) GTK_RESPONSE_YES);
		empty_button = _tmp10_;
		_tmp11_ = empty_button;
		_tmp12_ = gtk_widget_get_style_context (_tmp11_);
		gtk_style_context_add_class (_tmp12_, GTK_STYLE_CLASS_DESTRUCTIVE_ACTION);
		_tmp13_ = message_dialog;
		response = (GtkResponseType) gtk_dialog_run ((GtkDialog*) _tmp13_);
		_tmp14_ = message_dialog;
		gtk_widget_destroy ((GtkWidget*) _tmp14_);
		result = response == GTK_RESPONSE_YES;
		_g_object_unref0 (message_dialog);
		return result;
	}
	result = TRUE;
	return result;
}

static void
marlin_file_operations_empty_trash_job_delete_trash_file_data_free (gpointer _data)
{
	MarlinFileOperationsEmptyTrashJobDeleteTrashFileData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->file);
	_marlin_file_operations_common_job_unref0 (_data_->self);
	g_slice_free (MarlinFileOperationsEmptyTrashJobDeleteTrashFileData, _data_);
}

static gpointer
_marlin_file_operations_common_job_ref0 (gpointer self)
{
	return self ? marlin_file_operations_common_job_ref (self) : NULL;
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static void
marlin_file_operations_empty_trash_job_delete_trash_file (FilesFileOperationsEmptyTrashJob* self,
                                                          GFile* file,
                                                          gboolean delete_file,
                                                          gboolean delete_children,
                                                          GAsyncReadyCallback _callback_,
                                                          gpointer _user_data_)
{
	MarlinFileOperationsEmptyTrashJobDeleteTrashFileData* _data_;
	FilesFileOperationsEmptyTrashJob* _tmp0_;
	GFile* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	_data_ = g_slice_new0 (MarlinFileOperationsEmptyTrashJobDeleteTrashFileData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, marlin_file_operations_empty_trash_job_delete_trash_file_data_free);
	_tmp0_ = _marlin_file_operations_common_job_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = _g_object_ref0 (file);
	_g_object_unref0 (_data_->file);
	_data_->file = _tmp1_;
	_data_->delete_file = delete_file;
	_data_->delete_children = delete_children;
	marlin_file_operations_empty_trash_job_delete_trash_file_co (_data_);
}

static void
marlin_file_operations_empty_trash_job_delete_trash_file_finish (FilesFileOperationsEmptyTrashJob* self,
                                                                 GAsyncResult* _res_)
{
	MarlinFileOperationsEmptyTrashJobDeleteTrashFileData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static void
marlin_file_operations_empty_trash_job_delete_trash_file_ready (GObject* source_object,
                                                                GAsyncResult* _res_,
                                                                gpointer _user_data_)
{
	MarlinFileOperationsEmptyTrashJobDeleteTrashFileData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	marlin_file_operations_empty_trash_job_delete_trash_file_co (_data_);
}

static gboolean
marlin_file_operations_empty_trash_job_delete_trash_file_co (MarlinFileOperationsEmptyTrashJobDeleteTrashFileData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		case 3:
		goto _state_3;
		case 4:
		goto _state_4;
		case 5:
		goto _state_5;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	if (marlin_file_operations_common_job_aborted ((FilesFileOperationsCommonJob*) _data_->self)) {
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (!g_task_get_completed (_data_->_async_result)) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	if (_data_->delete_children) {
		{
			static const char ATTRIBUTES[] = G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE;
			_data_->_tmp0_ = ((FilesFileOperationsCommonJob*) _data_->self)->cancellable;
			_data_->_state_ = 1;
			g_file_enumerate_children_async (_data_->file, ATTRIBUTES, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, G_PRIORITY_DEFAULT, _data_->_tmp0_, marlin_file_operations_empty_trash_job_delete_trash_file_ready, _data_);
			return FALSE;
			_state_1:
			_data_->_tmp1_ = g_file_enumerate_children_finish (_data_->file, _data_->_res_, &_data_->_inner_error0_);
			_data_->enumerator = _data_->_tmp1_;
			if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
				goto __catch0_g_error;
			}
			_data_->_tmp2_ = _data_->enumerator;
			_data_->_tmp3_ = ((FilesFileOperationsCommonJob*) _data_->self)->cancellable;
			_data_->_state_ = 2;
			g_file_enumerator_next_files_async (_data_->_tmp2_, 10, G_PRIORITY_DEFAULT, _data_->_tmp3_, marlin_file_operations_empty_trash_job_delete_trash_file_ready, _data_);
			return FALSE;
			_state_2:
			_data_->_tmp4_ = g_file_enumerator_next_files_finish (_data_->_tmp2_, _data_->_res_, &_data_->_inner_error0_);
			_data_->infos = _data_->_tmp4_;
			if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
				_g_object_unref0 (_data_->enumerator);
				goto __catch0_g_error;
			}
			while (TRUE) {
				_data_->_tmp5_ = _data_->infos;
				_data_->_tmp6_ = g_list_nth_data (_data_->_tmp5_, (guint) 0);
				if (!(((GFileInfo*) _data_->_tmp6_) != NULL)) {
					break;
				}
				_data_->_tmp7_ = _data_->infos;
				{
					_data_->info_collection = _data_->_tmp7_;
					for (_data_->info_it = _data_->info_collection; _data_->info_it != NULL; _data_->info_it = _data_->info_it->next) {
						_data_->info = (GFileInfo*) _data_->info_it->data;
						{
							_data_->_tmp8_ = _data_->info;
							_data_->_tmp9_ = g_file_info_get_name (_data_->_tmp8_);
							_data_->_tmp10_ = g_file_get_child (_data_->file, _data_->_tmp9_);
							_data_->child = _data_->_tmp10_;
							_data_->_tmp11_ = _data_->child;
							_data_->_tmp12_ = _data_->info;
							_data_->_state_ = 3;
							marlin_file_operations_empty_trash_job_delete_trash_file (_data_->self, _data_->_tmp11_, TRUE, g_file_info_get_file_type (_data_->_tmp12_) == G_FILE_TYPE_DIRECTORY, marlin_file_operations_empty_trash_job_delete_trash_file_ready, _data_);
							return FALSE;
							_state_3:
							marlin_file_operations_empty_trash_job_delete_trash_file_finish (_data_->self, _data_->_res_);
							_g_object_unref0 (_data_->child);
						}
					}
				}
				_data_->_tmp14_ = _data_->enumerator;
				_data_->_tmp15_ = ((FilesFileOperationsCommonJob*) _data_->self)->cancellable;
				_data_->_state_ = 4;
				g_file_enumerator_next_files_async (_data_->_tmp14_, 10, G_PRIORITY_DEFAULT, _data_->_tmp15_, marlin_file_operations_empty_trash_job_delete_trash_file_ready, _data_);
				return FALSE;
				_state_4:
				_data_->_tmp16_ = g_file_enumerator_next_files_finish (_data_->_tmp14_, _data_->_res_, &_data_->_inner_error0_);
				_data_->_tmp13_ = _data_->_tmp16_;
				if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
					(_data_->infos == NULL) ? NULL : (_data_->infos = (_g_list_free__g_object_unref0_ (_data_->infos), NULL));
					_g_object_unref0 (_data_->enumerator);
					goto __catch0_g_error;
				}
				_data_->_tmp17_ = _data_->_tmp13_;
				_data_->_tmp13_ = NULL;
				(_data_->infos == NULL) ? NULL : (_data_->infos = (_g_list_free__g_object_unref0_ (_data_->infos), NULL));
				_data_->infos = _data_->_tmp17_;
				(_data_->_tmp13_ == NULL) ? NULL : (_data_->_tmp13_ = (_g_list_free__g_object_unref0_ (_data_->_tmp13_), NULL));
			}
			(_data_->infos == NULL) ? NULL : (_data_->infos = (_g_list_free__g_object_unref0_ (_data_->infos), NULL));
			_g_object_unref0 (_data_->enumerator);
		}
		goto __finally0;
		__catch0_g_error:
		{
			_data_->e = _data_->_inner_error0_;
			_data_->_inner_error0_ = NULL;
			_data_->_tmp18_ = _data_->e;
			_data_->_tmp19_ = _data_->_tmp18_->message;
			g_debug ("EmptyTrashJob.vala:91: %s", _data_->_tmp19_);
			_g_error_free0 (_data_->e);
			g_task_return_pointer (_data_->_async_result, _data_, NULL);
			if (_data_->_state_ != 0) {
				while (!g_task_get_completed (_data_->_async_result)) {
					g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
				}
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		__finally0:
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
			g_clear_error (&_data_->_inner_error0_);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
	}
	if (marlin_file_operations_common_job_aborted ((FilesFileOperationsCommonJob*) _data_->self)) {
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (!g_task_get_completed (_data_->_async_result)) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	if (_data_->delete_file) {
		{
			_data_->_tmp20_ = ((FilesFileOperationsCommonJob*) _data_->self)->cancellable;
			_data_->_state_ = 5;
			g_file_delete_async (_data_->file, G_PRIORITY_DEFAULT, _data_->_tmp20_, marlin_file_operations_empty_trash_job_delete_trash_file_ready, _data_);
			return FALSE;
			_state_5:
			g_file_delete_finish (_data_->file, _data_->_res_, &_data_->_inner_error0_);
			if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
				goto __catch1_g_error;
			}
		}
		goto __finally1;
		__catch1_g_error:
		{
			_data_->_vala1_e = _data_->_inner_error0_;
			_data_->_inner_error0_ = NULL;
			_data_->_tmp21_ = _data_->_vala1_e;
			_data_->_tmp22_ = _data_->_tmp21_->message;
			g_debug ("EmptyTrashJob.vala:104: %s", _data_->_tmp22_);
			_g_error_free0 (_data_->_vala1_e);
			g_task_return_pointer (_data_->_async_result, _data_, NULL);
			if (_data_->_state_ != 0) {
				while (!g_task_get_completed (_data_->_async_result)) {
					g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
				}
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		__finally1:
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
			g_clear_error (&_data_->_inner_error0_);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
	}
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static void
marlin_file_operations_empty_trash_job_empty_trash_data_free (gpointer _data)
{
	MarlinFileOperationsEmptyTrashJobEmptyTrashData* _data_;
	_data_ = _data;
	_marlin_file_operations_common_job_unref0 (_data_->self);
	g_slice_free (MarlinFileOperationsEmptyTrashJobEmptyTrashData, _data_);
}

void
marlin_file_operations_empty_trash_job_empty_trash (FilesFileOperationsEmptyTrashJob* self,
                                                    GAsyncReadyCallback _callback_,
                                                    gpointer _user_data_)
{
	MarlinFileOperationsEmptyTrashJobEmptyTrashData* _data_;
	FilesFileOperationsEmptyTrashJob* _tmp0_;
	g_return_if_fail (self != NULL);
	_data_ = g_slice_new0 (MarlinFileOperationsEmptyTrashJobEmptyTrashData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, marlin_file_operations_empty_trash_job_empty_trash_data_free);
	_tmp0_ = _marlin_file_operations_common_job_ref0 (self);
	_data_->self = _tmp0_;
	marlin_file_operations_empty_trash_job_empty_trash_co (_data_);
}

void
marlin_file_operations_empty_trash_job_empty_trash_finish (FilesFileOperationsEmptyTrashJob* self,
                                                           GAsyncResult* _res_)
{
	MarlinFileOperationsEmptyTrashJobEmptyTrashData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static void
marlin_file_operations_empty_trash_job_empty_trash_ready (GObject* source_object,
                                                          GAsyncResult* _res_,
                                                          gpointer _user_data_)
{
	MarlinFileOperationsEmptyTrashJobEmptyTrashData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	marlin_file_operations_empty_trash_job_empty_trash_co (_data_);
}

static gboolean
marlin_file_operations_empty_trash_job_empty_trash_co (MarlinFileOperationsEmptyTrashJobEmptyTrashData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	marlin_file_operations_common_job_inhibit_power_manager ((FilesFileOperationsCommonJob*) _data_->self, _ ("Emptying Trash"));
	_data_->_tmp1_ = files_preferences_get_default ();
	_data_->_tmp2_ = _data_->_tmp1_;
	_data_->_tmp3_ = files_preferences_get_confirm_trash (_data_->_tmp2_);
	_data_->_tmp4_ = _data_->_tmp3_;
	_data_->_tmp5_ = !_data_->_tmp4_;
	_g_object_unref0 (_data_->_tmp2_);
	if (_data_->_tmp5_) {
		_data_->_tmp0_ = TRUE;
	} else {
		_data_->_tmp0_ = marlin_file_operations_empty_trash_job_confirm_empty_trash (_data_->self);
	}
	if (_data_->_tmp0_) {
		_data_->_tmp6_ = ((FilesFileOperationsCommonJob*) _data_->self)->progress;
		pf_progress_info_start (_data_->_tmp6_);
		_data_->_tmp7_ = _data_->self->priv->trash_dirs;
		{
			_data_->dir_collection = _data_->_tmp7_;
			for (_data_->dir_it = _data_->dir_collection; _data_->dir_it != NULL; _data_->dir_it = _data_->dir_it->next) {
				_data_->dir = (GFile*) _data_->dir_it->data;
				{
					if (marlin_file_operations_common_job_aborted ((FilesFileOperationsCommonJob*) _data_->self)) {
						break;
					}
					_data_->_tmp8_ = _data_->dir;
					_data_->_state_ = 1;
					marlin_file_operations_empty_trash_job_delete_trash_file (_data_->self, _data_->_tmp8_, FALSE, TRUE, marlin_file_operations_empty_trash_job_empty_trash_ready, _data_);
					return FALSE;
					_state_1:
					marlin_file_operations_empty_trash_job_delete_trash_file_finish (_data_->self, _data_->_res_);
				}
			}
		}
		_data_->_tmp9_ = files_undo_manager_instance ();
		files_undo_manager_trash_has_emptied (_data_->_tmp9_);
		_data_->_tmp10_ = pf_sound_manager_get_instance ();
		pf_sound_manager_play_empty_trash_sound (_data_->_tmp10_);
	}
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static void
marlin_file_operations_empty_trash_job_class_init (FilesFileOperationsEmptyTrashJobClass * klass,
                                                   gpointer klass_data)
{
	marlin_file_operations_empty_trash_job_parent_class = g_type_class_peek_parent (klass);
	((FilesFileOperationsCommonJobClass *) klass)->finalize = marlin_file_operations_empty_trash_job_finalize;
	g_type_class_adjust_private_offset (klass, &FilesFileOperationsEmptyTrashJob_private_offset);
}

static void
marlin_file_operations_empty_trash_job_instance_init (FilesFileOperationsEmptyTrashJob * self,
                                                      gpointer klass)
{
	self->priv = marlin_file_operations_empty_trash_job_get_instance_private (self);
}

static void
marlin_file_operations_empty_trash_job_finalize (FilesFileOperationsCommonJob * obj)
{
	FilesFileOperationsEmptyTrashJob * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, MARLIN_FILE_OPERATIONS_TYPE_EMPTY_TRASH_JOB, FilesFileOperationsEmptyTrashJob);
	(self->priv->trash_dirs == NULL) ? NULL : (self->priv->trash_dirs = (_g_list_free__g_object_unref0_ (self->priv->trash_dirs), NULL));
	MARLIN_FILE_OPERATIONS_COMMON_JOB_CLASS (marlin_file_operations_empty_trash_job_parent_class)->finalize (obj);
}

static GType
marlin_file_operations_empty_trash_job_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FilesFileOperationsEmptyTrashJobClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) marlin_file_operations_empty_trash_job_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FilesFileOperationsEmptyTrashJob), 0, (GInstanceInitFunc) marlin_file_operations_empty_trash_job_instance_init, NULL };
	GType marlin_file_operations_empty_trash_job_type_id;
	marlin_file_operations_empty_trash_job_type_id = g_type_register_static (MARLIN_FILE_OPERATIONS_TYPE_COMMON_JOB, "FilesFileOperationsEmptyTrashJob", &g_define_type_info, 0);
	FilesFileOperationsEmptyTrashJob_private_offset = g_type_add_instance_private (marlin_file_operations_empty_trash_job_type_id, sizeof (FilesFileOperationsEmptyTrashJobPrivate));
	return marlin_file_operations_empty_trash_job_type_id;
}

GType
marlin_file_operations_empty_trash_job_get_type (void)
{
	static volatile gsize marlin_file_operations_empty_trash_job_type_id__once = 0;
	if (g_once_init_enter (&marlin_file_operations_empty_trash_job_type_id__once)) {
		GType marlin_file_operations_empty_trash_job_type_id;
		marlin_file_operations_empty_trash_job_type_id = marlin_file_operations_empty_trash_job_get_type_once ();
		g_once_init_leave (&marlin_file_operations_empty_trash_job_type_id__once, marlin_file_operations_empty_trash_job_type_id);
	}
	return marlin_file_operations_empty_trash_job_type_id__once;
}

static inline gpointer
_vala_memdup2 (gconstpointer mem,
               gsize byte_size)
{
	gpointer new_mem;
	if (mem && byte_size != 0) {
		new_mem = g_malloc (byte_size);
		memcpy (new_mem, mem, byte_size);
	} else {
		new_mem = NULL;
	}
	return new_mem;
}

