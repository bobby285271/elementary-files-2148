/* CopyMoveJob.c generated by valac 0.56.3, the Vala compiler
 * generated from CopyMoveJob.vala, do not modify */

/* Copyright 2022 elementary LLC (https://elementary.io)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, Inc.,; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */

#include "pantheon-files-core.h"
#include <gio/gio.h>
#include <glib.h>
#include <gtk/gtk.h>
#include <glib-object.h>

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))

static gpointer marlin_file_operations_copy_move_job_parent_class = NULL;

static void _g_object_unref0_ (gpointer var);
static inline void _g_list_free__g_object_unref0_ (GList* self);
static guint _g_file_hash_ghash_func (gconstpointer key);
static gboolean _g_file_equal_gequal_func (gconstpointer a,
                                    gconstpointer b);
static void marlin_file_operations_copy_move_job_finalize (FilesFileOperationsCommonJob * obj);
static GType marlin_file_operations_copy_move_job_get_type_once (void);

static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}

static inline void
_g_list_free__g_object_unref0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_object_unref0_);
}

static guint
_g_file_hash_ghash_func (gconstpointer key)
{
	guint result;
	result = g_file_hash (key);
	return result;
}

static gboolean
_g_file_equal_gequal_func (gconstpointer a,
                           gconstpointer b)
{
	gboolean result;
	result = g_file_equal (a, (GFile*) b);
	return result;
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

FilesFileOperationsCopyMoveJob*
marlin_file_operations_copy_move_job_construct (GType object_type,
                                                GtkWindow* parent_window,
                                                GList* files,
                                                GFile* destination)
{
	FilesFileOperationsCopyMoveJob* self = NULL;
	GList* _tmp0_;
	GFile* _tmp1_;
	self = (FilesFileOperationsCopyMoveJob*) marlin_file_operations_common_job_construct (object_type, parent_window);
	_tmp0_ = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);
	(self->files == NULL) ? NULL : (self->files = (_g_list_free__g_object_unref0_ (self->files), NULL));
	self->files = _tmp0_;
	_tmp1_ = _g_object_ref0 (destination);
	_g_object_unref0 (self->destination);
	self->destination = _tmp1_;
	return self;
}

FilesFileOperationsCopyMoveJob*
marlin_file_operations_copy_move_job_new (GtkWindow* parent_window,
                                          GList* files,
                                          GFile* destination)
{
	return marlin_file_operations_copy_move_job_construct (MARLIN_FILE_OPERATIONS_TYPE_COPY_MOVE_JOB, parent_window, files, destination);
}

FilesFileOperationsCopyMoveJob*
marlin_file_operations_copy_move_job_construct_move (GType object_type,
                                                     GtkWindow* parent_window,
                                                     GList* files,
                                                     GFile* destination)
{
	FilesFileOperationsCopyMoveJob* self = NULL;
	GList* _tmp0_;
	GFile* _tmp1_;
	self = (FilesFileOperationsCopyMoveJob*) marlin_file_operations_common_job_construct (object_type, parent_window);
	_tmp0_ = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);
	(self->files == NULL) ? NULL : (self->files = (_g_list_free__g_object_unref0_ (self->files), NULL));
	self->files = _tmp0_;
	_tmp1_ = _g_object_ref0 (destination);
	_g_object_unref0 (self->destination);
	self->destination = _tmp1_;
	self->is_move = TRUE;
	return self;
}

FilesFileOperationsCopyMoveJob*
marlin_file_operations_copy_move_job_new_move (GtkWindow* parent_window,
                                               GList* files,
                                               GFile* destination)
{
	return marlin_file_operations_copy_move_job_construct_move (MARLIN_FILE_OPERATIONS_TYPE_COPY_MOVE_JOB, parent_window, files, destination);
}

static void
marlin_file_operations_copy_move_job_class_init (FilesFileOperationsCopyMoveJobClass * klass,
                                                 gpointer klass_data)
{
	marlin_file_operations_copy_move_job_parent_class = g_type_class_peek_parent (klass);
	((FilesFileOperationsCommonJobClass *) klass)->finalize = marlin_file_operations_copy_move_job_finalize;
}

static void
marlin_file_operations_copy_move_job_instance_init (FilesFileOperationsCopyMoveJob * self,
                                                    gpointer klass)
{
	GHashTable* _tmp0_;
	self->is_move = FALSE;
	_tmp0_ = g_hash_table_new_full (_g_file_hash_ghash_func, _g_file_equal_gequal_func, _g_object_unref0_, NULL);
	self->debuting_files = _tmp0_;
	self->replace_all = FALSE;
	self->merge_all = FALSE;
	self->keep_all_newest = FALSE;
	self->skip_all_conflict = FALSE;
}

static void
marlin_file_operations_copy_move_job_finalize (FilesFileOperationsCommonJob * obj)
{
	FilesFileOperationsCopyMoveJob * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, MARLIN_FILE_OPERATIONS_TYPE_COPY_MOVE_JOB, FilesFileOperationsCopyMoveJob);
	files_file_changes_consume_changes (TRUE);
	(self->files == NULL) ? NULL : (self->files = (_g_list_free__g_object_unref0_ (self->files), NULL));
	_g_object_unref0 (self->destination);
	_g_hash_table_unref0 (self->debuting_files);
	MARLIN_FILE_OPERATIONS_COMMON_JOB_CLASS (marlin_file_operations_copy_move_job_parent_class)->finalize (obj);
}

static GType
marlin_file_operations_copy_move_job_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FilesFileOperationsCopyMoveJobClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) marlin_file_operations_copy_move_job_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FilesFileOperationsCopyMoveJob), 0, (GInstanceInitFunc) marlin_file_operations_copy_move_job_instance_init, NULL };
	GType marlin_file_operations_copy_move_job_type_id;
	marlin_file_operations_copy_move_job_type_id = g_type_register_static (MARLIN_FILE_OPERATIONS_TYPE_COMMON_JOB, "FilesFileOperationsCopyMoveJob", &g_define_type_info, 0);
	return marlin_file_operations_copy_move_job_type_id;
}

GType
marlin_file_operations_copy_move_job_get_type (void)
{
	static volatile gsize marlin_file_operations_copy_move_job_type_id__once = 0;
	if (g_once_init_enter (&marlin_file_operations_copy_move_job_type_id__once)) {
		GType marlin_file_operations_copy_move_job_type_id;
		marlin_file_operations_copy_move_job_type_id = marlin_file_operations_copy_move_job_get_type_once ();
		g_once_init_leave (&marlin_file_operations_copy_move_job_type_id__once, marlin_file_operations_copy_move_job_type_id);
	}
	return marlin_file_operations_copy_move_job_type_id__once;
}

