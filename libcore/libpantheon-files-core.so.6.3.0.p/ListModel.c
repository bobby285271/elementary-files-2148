/* ListModel.c generated by valac 0.56.3, the Vala compiler
 * generated from ListModel.vala, do not modify */

/* Copyright 2021 elementary, Inc. (https://elementary.io)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, Inc.,; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */

#include "pantheon-files-core.h"
#include <glib.h>
#include <stdlib.h>
#include <string.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <gio/gio.h>

enum  {
	FILES_LIST_MODEL_0_PROPERTY,
	FILES_LIST_MODEL_SHOW_HIDDEN_FILES_PROPERTY,
	FILES_LIST_MODEL_ICON_SIZE_PROPERTY,
	FILES_LIST_MODEL_HAS_CHILD_PROPERTY,
	FILES_LIST_MODEL_NUM_PROPERTIES
};
static GParamSpec* files_list_model_properties[FILES_LIST_MODEL_NUM_PROPERTIES];
typedef enum  {
	FILES_LIST_MODEL_PRIV_COLUMN_ID_DUMMY = FILES_LIST_MODEL_COLUMN_ID_NUM_COLUMNS
} FilesListModelPrivColumnID;

#define FILES_LIST_MODEL_TYPE_PRIV_COLUMN_ID (files_list_model_priv_column_id_get_type ())
#define __vala_GtkTreeIter_free0(var) ((var == NULL) ? NULL : (var = (_vala_GtkTreeIter_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block14Data Block14Data;
typedef struct _Block15Data Block15Data;
enum  {
	FILES_LIST_MODEL_SUBDIRECTORY_UNLOADED_SIGNAL,
	FILES_LIST_MODEL_NUM_SIGNALS
};
static guint files_list_model_signals[FILES_LIST_MODEL_NUM_SIGNALS] = {0};

struct _FilesListModelPrivate {
	gboolean _show_hidden_files;
	gint _icon_size;
	gboolean _has_child;
	gboolean sort_directories_first;
};

struct _Block14Data {
	int _ref_count_;
	FilesListModel* self;
	GtkTreeIter* tmp_iter;
	FilesFile* file;
};

struct _Block15Data {
	int _ref_count_;
	FilesListModel* self;
	gboolean found;
	FilesFile* file;
};

static gint FilesListModel_private_offset;
static gpointer files_list_model_parent_class = NULL;
static GtkTreeModelIface * files_list_model_gtk_tree_model_parent_iface = NULL;

static GType files_list_model_priv_column_id_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
static void _vala_GtkTreeIter_free (GtkTreeIter* self);
static GtkTreeIter* _vala_GtkTreeIter_copy (GtkTreeIter* self);
static Block14Data* block14_data_ref (Block14Data* _data14_);
static void block14_data_unref (void * _userdata_);
static gboolean __lambda4_ (Block14Data* _data14_,
                     GtkTreeModel* model,
                     GtkTreePath* path,
                     GtkTreeIter* i_iter);
static gboolean ___lambda4__gtk_tree_model_foreach_func (GtkTreeModel* model,
                                                  GtkTreePath* path,
                                                  GtkTreeIter* iter,
                                                  gpointer self);
static void files_list_model_real_get_value (GtkTreeModel* base,
                                      GtkTreeIter* iter,
                                      gint column,
                                      GValue* value);
static Block15Data* block15_data_ref (Block15Data* _data15_);
static void block15_data_unref (void * _userdata_);
static gboolean __lambda7_ (Block15Data* _data15_,
                     GtkTreeModel* model,
                     GtkTreePath* path,
                     GtkTreeIter* iter);
static gboolean ___lambda7__gtk_tree_model_foreach_func (GtkTreeModel* model,
                                                  GtkTreePath* path,
                                                  GtkTreeIter* iter,
                                                  gpointer self);
static gint files_list_model_file_entry_compare_func (FilesListModel* self,
                                               GtkTreeIter* a,
                                               GtkTreeIter* b);
static GObject * files_list_model_constructor (GType type,
                                        guint n_construct_properties,
                                        GObjectConstructParam * construct_properties);
static void files_list_model_finalize (GObject * obj);
static GType files_list_model_get_type_once (void);
static void _vala_files_list_model_get_property (GObject * object,
                                          guint property_id,
                                          GValue * value,
                                          GParamSpec * pspec);
static void _vala_files_list_model_set_property (GObject * object,
                                          guint property_id,
                                          const GValue * value,
                                          GParamSpec * pspec);

VALA_EXTERN const gchar* FILES_PREFERENCES_TAGS_COLORS[12];

static inline gpointer
files_list_model_get_instance_private (FilesListModel* self)
{
	return G_STRUCT_MEMBER_P (self, FilesListModel_private_offset);
}

FilesListModelColumnID
files_list_model_column_id_from_string (const gchar* column_id)
{
	const gchar* _tmp0_;
	GQuark _tmp2_ = 0U;
	static GQuark _tmp1_label0 = 0;
	static GQuark _tmp1_label1 = 0;
	static GQuark _tmp1_label2 = 0;
	static GQuark _tmp1_label3 = 0;
	FilesListModelColumnID result;
	g_return_val_if_fail (column_id != NULL, 0);
	_tmp0_ = column_id;
	_tmp2_ = (NULL == _tmp0_) ? 0 : g_quark_from_string (_tmp0_);
	if (_tmp2_ == ((0 != _tmp1_label0) ? _tmp1_label0 : (_tmp1_label0 = g_quark_from_static_string ("name")))) {
		switch (0) {
			default:
			{
				result = FILES_LIST_MODEL_COLUMN_ID_FILENAME;
				return result;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label1) ? _tmp1_label1 : (_tmp1_label1 = g_quark_from_static_string ("size")))) {
		switch (0) {
			default:
			{
				result = FILES_LIST_MODEL_COLUMN_ID_SIZE;
				return result;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label2) ? _tmp1_label2 : (_tmp1_label2 = g_quark_from_static_string ("type")))) {
		switch (0) {
			default:
			{
				result = FILES_LIST_MODEL_COLUMN_ID_TYPE;
				return result;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label3) ? _tmp1_label3 : (_tmp1_label3 = g_quark_from_static_string ("modified")))) {
		switch (0) {
			default:
			{
				result = FILES_LIST_MODEL_COLUMN_ID_MODIFIED;
				return result;
			}
		}
	} else {
		switch (0) {
			default:
			{
				result = (FilesListModelColumnID) -1;
				return result;
			}
		}
	}
}

const gchar*
files_list_model_column_id_to_string (FilesListModelColumnID self)
{
	const gchar* result;
	switch (self) {
		case FILES_LIST_MODEL_COLUMN_ID_FILENAME:
		{
			result = "name";
			return result;
		}
		case FILES_LIST_MODEL_COLUMN_ID_SIZE:
		{
			result = "size";
			return result;
		}
		case FILES_LIST_MODEL_COLUMN_ID_TYPE:
		{
			result = "type";
			return result;
		}
		case FILES_LIST_MODEL_COLUMN_ID_MODIFIED:
		{
			result = "modified";
			return result;
		}
		default:
		{
			g_critical ("ListModel.vala:56: COLUMN id %u unsupported", (guint) self);
			result = "";
			return result;
		}
	}
}

static GType
files_list_model_column_id_get_type_once (void)
{
	static const GEnumValue values[] = {{FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN, "FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN", "file-column"}, {FILES_LIST_MODEL_COLUMN_ID_COLOR, "FILES_LIST_MODEL_COLUMN_ID_COLOR", "color"}, {FILES_LIST_MODEL_COLUMN_ID_PIXBUF, "FILES_LIST_MODEL_COLUMN_ID_PIXBUF", "pixbuf"}, {FILES_LIST_MODEL_COLUMN_ID_FILENAME, "FILES_LIST_MODEL_COLUMN_ID_FILENAME", "filename"}, {FILES_LIST_MODEL_COLUMN_ID_SIZE, "FILES_LIST_MODEL_COLUMN_ID_SIZE", "size"}, {FILES_LIST_MODEL_COLUMN_ID_TYPE, "FILES_LIST_MODEL_COLUMN_ID_TYPE", "type"}, {FILES_LIST_MODEL_COLUMN_ID_MODIFIED, "FILES_LIST_MODEL_COLUMN_ID_MODIFIED", "modified"}, {FILES_LIST_MODEL_COLUMN_ID_NUM_COLUMNS, "FILES_LIST_MODEL_COLUMN_ID_NUM_COLUMNS", "num-columns"}, {0, NULL, NULL}};
	GType files_list_model_column_id_type_id;
	files_list_model_column_id_type_id = g_enum_register_static ("FilesListModelColumnID", values);
	return files_list_model_column_id_type_id;
}

GType
files_list_model_column_id_get_type (void)
{
	static volatile gsize files_list_model_column_id_type_id__once = 0;
	if (g_once_init_enter (&files_list_model_column_id_type_id__once)) {
		GType files_list_model_column_id_type_id;
		files_list_model_column_id_type_id = files_list_model_column_id_get_type_once ();
		g_once_init_leave (&files_list_model_column_id_type_id__once, files_list_model_column_id_type_id);
	}
	return files_list_model_column_id_type_id__once;
}

static GType
files_list_model_priv_column_id_get_type_once (void)
{
	static const GEnumValue values[] = {{FILES_LIST_MODEL_PRIV_COLUMN_ID_DUMMY, "FILES_LIST_MODEL_PRIV_COLUMN_ID_DUMMY", "dummy"}, {0, NULL, NULL}};
	GType files_list_model_priv_column_id_type_id;
	files_list_model_priv_column_id_type_id = g_enum_register_static ("FilesListModelPrivColumnID", values);
	return files_list_model_priv_column_id_type_id;
}

static GType
files_list_model_priv_column_id_get_type (void)
{
	static volatile gsize files_list_model_priv_column_id_type_id__once = 0;
	if (g_once_init_enter (&files_list_model_priv_column_id_type_id__once)) {
		GType files_list_model_priv_column_id_type_id;
		files_list_model_priv_column_id_type_id = files_list_model_priv_column_id_get_type_once ();
		g_once_init_leave (&files_list_model_priv_column_id_type_id__once, files_list_model_priv_column_id_type_id);
	}
	return files_list_model_priv_column_id_type_id__once;
}

static void
_vala_GtkTreeIter_free (GtkTreeIter* self)
{
	g_boxed_free (gtk_tree_iter_get_type (), self);
}

static GtkTreeIter*
_vala_GtkTreeIter_copy (GtkTreeIter* self)
{
	return g_boxed_copy (gtk_tree_iter_get_type (), self);
}

static gpointer
__vala_GtkTreeIter_copy0 (gpointer self)
{
	return self ? _vala_GtkTreeIter_copy (self) : NULL;
}

FilesFile*
files_list_model_file_for_path (FilesListModel* self,
                                GtkTreePath* path)
{
	FilesFile* file = NULL;
	GtkTreeIter* iter = NULL;
	GtkTreeIter _tmp0_ = {0};
	gboolean _tmp1_;
	GtkTreeIter _tmp2_;
	GtkTreeIter* _tmp3_;
	FilesFile* result;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	file = NULL;
	_tmp1_ = gtk_tree_model_get_iter ((GtkTreeModel*) self, &_tmp0_, path);
	__vala_GtkTreeIter_free0 (iter);
	_tmp2_ = _tmp0_;
	_tmp3_ = __vala_GtkTreeIter_copy0 (&_tmp2_);
	iter = _tmp3_;
	if (_tmp1_) {
		GtkTreeIter* _tmp4_;
		GtkTreeIter _tmp5_;
		_tmp4_ = iter;
		_tmp5_ = *_tmp4_;
		gtk_tree_model_get ((GtkTreeModel*) self, &_tmp5_, FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN, &file, -1);
	}
	result = file;
	__vala_GtkTreeIter_free0 (iter);
	return result;
}

FilesFile*
files_list_model_file_for_iter (FilesListModel* self,
                                GtkTreeIter* iter)
{
	FilesFile* file = NULL;
	GtkTreeIter _tmp0_;
	FilesFile* result;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (iter != NULL, NULL);
	file = NULL;
	_tmp0_ = *iter;
	gtk_tree_model_get ((GtkTreeModel*) self, &_tmp0_, FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN, &file, -1);
	result = file;
	return result;
}

guint
files_list_model_get_length (FilesListModel* self)
{
	guint result;
	g_return_val_if_fail (self != NULL, 0U);
	result = (guint) gtk_tree_model_iter_n_children ((GtkTreeModel*) self, NULL);
	return result;
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static Block14Data*
block14_data_ref (Block14Data* _data14_)
{
	g_atomic_int_inc (&_data14_->_ref_count_);
	return _data14_;
}

static void
block14_data_unref (void * _userdata_)
{
	Block14Data* _data14_;
	_data14_ = (Block14Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data14_->_ref_count_)) {
		FilesListModel* self;
		self = _data14_->self;
		__vala_GtkTreeIter_free0 (_data14_->tmp_iter);
		_g_object_unref0 (_data14_->file);
		_g_object_unref0 (self);
		g_slice_free (Block14Data, _data14_);
	}
}

static gboolean
__lambda4_ (Block14Data* _data14_,
            GtkTreeModel* model,
            GtkTreePath* path,
            GtkTreeIter* i_iter)
{
	FilesListModel* self;
	FilesFile* iter_file = NULL;
	GtkTreeIter _tmp0_;
	FilesFile* _tmp1_;
	gboolean result;
	self = _data14_->self;
	g_return_val_if_fail (model != NULL, FALSE);
	g_return_val_if_fail (path != NULL, FALSE);
	g_return_val_if_fail (i_iter != NULL, FALSE);
	iter_file = NULL;
	_tmp0_ = *i_iter;
	gtk_tree_model_get ((GtkTreeModel*) self, &_tmp0_, FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN, &iter_file, -1);
	_tmp1_ = iter_file;
	if (_tmp1_ == _data14_->file) {
		GtkTreeIter _tmp2_;
		GtkTreeIter* _tmp3_;
		_tmp2_ = *i_iter;
		_tmp3_ = __vala_GtkTreeIter_copy0 (&_tmp2_);
		__vala_GtkTreeIter_free0 (_data14_->tmp_iter);
		_data14_->tmp_iter = _tmp3_;
		result = TRUE;
		_g_object_unref0 (iter_file);
		return result;
	}
	result = FALSE;
	_g_object_unref0 (iter_file);
	return result;
}

static gboolean
___lambda4__gtk_tree_model_foreach_func (GtkTreeModel* model,
                                         GtkTreePath* path,
                                         GtkTreeIter* iter,
                                         gpointer self)
{
	gboolean result;
	result = __lambda4_ (self, model, path, iter);
	return result;
}

gboolean
files_list_model_get_first_iter_for_file (FilesListModel* self,
                                          FilesFile* file,
                                          GtkTreeIter** iter)
{
	GtkTreeIter* _vala_iter = NULL;
	Block14Data* _data14_;
	FilesFile* _tmp0_;
	GtkTreeIter* _tmp1_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (file != NULL, FALSE);
	_data14_ = g_slice_new0 (Block14Data);
	_data14_->_ref_count_ = 1;
	_data14_->self = g_object_ref (self);
	_tmp0_ = _g_object_ref0 (file);
	_g_object_unref0 (_data14_->file);
	_data14_->file = _tmp0_;
	_data14_->tmp_iter = NULL;
	gtk_tree_model_foreach ((GtkTreeModel*) self, ___lambda4__gtk_tree_model_foreach_func, _data14_);
	_tmp1_ = __vala_GtkTreeIter_copy0 (_data14_->tmp_iter);
	__vala_GtkTreeIter_free0 (_vala_iter);
	_vala_iter = _tmp1_;
	result = _data14_->tmp_iter != NULL;
	block14_data_unref (_data14_);
	_data14_ = NULL;
	if (iter) {
		*iter = _vala_iter;
	} else {
		__vala_GtkTreeIter_free0 (_vala_iter);
	}
	return result;
}

static void
files_list_model_real_get_value (GtkTreeModel* base,
                                 GtkTreeIter* iter,
                                 gint column,
                                 GValue* value)
{
	FilesListModel * self;
	GValue _vala_value = {0};
	GValue file_value = {0};
	GtkTreeIter _tmp0_;
	GValue _tmp1_ = {0};
	FilesFile* file = NULL;
	GObject* _tmp2_;
	self = (FilesListModel*) base;
	g_return_if_fail (iter != NULL);
	_tmp0_ = *iter;
	files_list_model_gtk_tree_model_parent_iface->get_value ((GtkTreeModel*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_tree_store_get_type (), GtkTreeStore), &_tmp0_, (gint) FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN, &_tmp1_);
	G_IS_VALUE (&file_value) ? (g_value_unset (&file_value), NULL) : NULL;
	file_value = _tmp1_;
	_tmp2_ = g_value_get_object (&file_value);
	file = G_TYPE_CHECK_INSTANCE_CAST (_tmp2_, FILES_TYPE_FILE, FilesFile);
	switch (column) {
		case FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN:
		{
			GValue _tmp3_ = {0};
			FilesFile* _tmp4_;
			g_value_init (&_tmp3_, FILES_TYPE_FILE);
			G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
			_vala_value = _tmp3_;
			_tmp4_ = file;
			g_value_set_object (&_vala_value, (GObject*) _tmp4_);
			break;
		}
		case FILES_LIST_MODEL_COLUMN_ID_COLOR:
		{
			GValue _tmp5_ = {0};
			gboolean _tmp6_ = FALSE;
			FilesFile* _tmp7_;
			g_value_init (&_tmp5_, G_TYPE_STRING);
			G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
			_vala_value = _tmp5_;
			_tmp7_ = file;
			if (_tmp7_ != NULL) {
				FilesFile* _tmp8_;
				_tmp8_ = file;
				_tmp6_ = _tmp8_->color < G_N_ELEMENTS (FILES_PREFERENCES_TAGS_COLORS);
			} else {
				_tmp6_ = FALSE;
			}
			if (_tmp6_) {
				FilesFile* _tmp9_;
				const gchar* _tmp10_;
				_tmp9_ = file;
				_tmp10_ = FILES_PREFERENCES_TAGS_COLORS[_tmp9_->color];
				g_value_set_string (&_vala_value, _tmp10_);
			} else {
				const gchar* _tmp11_;
				_tmp11_ = FILES_PREFERENCES_TAGS_COLORS[0];
				g_value_set_string (&_vala_value, _tmp11_);
			}
			break;
		}
		case FILES_LIST_MODEL_COLUMN_ID_PIXBUF:
		{
			GValue _tmp12_ = {0};
			FilesFile* _tmp13_;
			g_value_init (&_tmp12_, gdk_pixbuf_get_type ());
			G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
			_vala_value = _tmp12_;
			_tmp13_ = file;
			if (_tmp13_ != NULL) {
				FilesFile* _tmp14_;
				gint _tmp15_;
				FilesFile* _tmp16_;
				FilesFile* _tmp17_;
				GdkPixbuf* _tmp18_;
				_tmp14_ = file;
				_tmp15_ = self->priv->_icon_size;
				_tmp16_ = file;
				files_file_update_icon (_tmp14_, _tmp15_, _tmp16_->pix_scale);
				_tmp17_ = file;
				_tmp18_ = _tmp17_->pix;
				if (_tmp18_ != NULL) {
					FilesFile* _tmp19_;
					GdkPixbuf* _tmp20_;
					_tmp19_ = file;
					_tmp20_ = _tmp19_->pix;
					g_value_set_object (&_vala_value, (GObject*) _tmp20_);
				}
			}
			break;
		}
		case FILES_LIST_MODEL_COLUMN_ID_FILENAME:
		{
			GValue _tmp21_ = {0};
			FilesFile* _tmp22_;
			g_value_init (&_tmp21_, G_TYPE_STRING);
			G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
			_vala_value = _tmp21_;
			_tmp22_ = file;
			if (_tmp22_ != NULL) {
				FilesFile* _tmp23_;
				const gchar* _tmp24_;
				_tmp23_ = file;
				_tmp24_ = files_file_get_display_name (_tmp23_);
				g_value_set_string (&_vala_value, _tmp24_);
			} else {
				g_value_set_static_string (&_vala_value, "");
			}
			break;
		}
		case FILES_LIST_MODEL_COLUMN_ID_SIZE:
		{
			GValue _tmp25_ = {0};
			FilesFile* _tmp26_;
			g_value_init (&_tmp25_, G_TYPE_STRING);
			G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
			_vala_value = _tmp25_;
			_tmp26_ = file;
			if (_tmp26_ != NULL) {
				FilesFile* _tmp27_;
				const gchar* _tmp28_;
				_tmp27_ = file;
				_tmp28_ = _tmp27_->format_size;
				g_value_set_string (&_vala_value, _tmp28_);
			} else {
				g_value_set_static_string (&_vala_value, "");
			}
			break;
		}
		case FILES_LIST_MODEL_COLUMN_ID_TYPE:
		{
			GValue _tmp29_ = {0};
			FilesFile* _tmp30_;
			g_value_init (&_tmp29_, G_TYPE_STRING);
			G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
			_vala_value = _tmp29_;
			_tmp30_ = file;
			if (_tmp30_ != NULL) {
				FilesFile* _tmp31_;
				const gchar* _tmp32_;
				_tmp31_ = file;
				_tmp32_ = _tmp31_->formated_type;
				g_value_set_string (&_vala_value, _tmp32_);
			} else {
				g_value_set_static_string (&_vala_value, "");
			}
			break;
		}
		case FILES_LIST_MODEL_COLUMN_ID_MODIFIED:
		{
			GValue _tmp33_ = {0};
			FilesFile* _tmp34_;
			g_value_init (&_tmp33_, G_TYPE_STRING);
			G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
			_vala_value = _tmp33_;
			_tmp34_ = file;
			if (_tmp34_ != NULL) {
				FilesFile* _tmp35_;
				const gchar* _tmp36_;
				_tmp35_ = file;
				_tmp36_ = _tmp35_->formated_modified;
				g_value_set_string (&_vala_value, _tmp36_);
			} else {
				g_value_set_static_string (&_vala_value, "");
			}
			break;
		}
		case FILES_LIST_MODEL_PRIV_COLUMN_ID_DUMMY:
		{
			GValue _tmp37_ = {0};
			FilesFile* _tmp38_;
			g_value_init (&_tmp37_, G_TYPE_BOOLEAN);
			G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
			_vala_value = _tmp37_;
			_tmp38_ = file;
			g_value_set_boolean (&_vala_value, _tmp38_ == NULL);
			break;
		}
		default:
		{
			GValue _tmp39_ = {0};
			g_value_init (&_tmp39_, G_TYPE_INVALID);
			G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
			_vala_value = _tmp39_;
			break;
		}
	}
	G_IS_VALUE (&file_value) ? (g_value_unset (&file_value), NULL) : NULL;
	if (value) {
		*value = _vala_value;
	} else {
		G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
	}
}

static Block15Data*
block15_data_ref (Block15Data* _data15_)
{
	g_atomic_int_inc (&_data15_->_ref_count_);
	return _data15_;
}

static void
block15_data_unref (void * _userdata_)
{
	Block15Data* _data15_;
	_data15_ = (Block15Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data15_->_ref_count_)) {
		FilesListModel* self;
		self = _data15_->self;
		_g_object_unref0 (_data15_->file);
		_g_object_unref0 (self);
		g_slice_free (Block15Data, _data15_);
	}
}

static gboolean
__lambda7_ (Block15Data* _data15_,
            GtkTreeModel* model,
            GtkTreePath* path,
            GtkTreeIter* iter)
{
	FilesListModel* self;
	FilesFile* iter_file = NULL;
	GtkTreeIter _tmp0_;
	FilesFile* _tmp1_;
	gboolean result;
	self = _data15_->self;
	g_return_val_if_fail (model != NULL, FALSE);
	g_return_val_if_fail (path != NULL, FALSE);
	g_return_val_if_fail (iter != NULL, FALSE);
	iter_file = NULL;
	_tmp0_ = *iter;
	gtk_tree_model_get ((GtkTreeModel*) self, &_tmp0_, FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN, &iter_file, -1);
	_tmp1_ = iter_file;
	if (_tmp1_ == _data15_->file) {
		GtkTreeIter _tmp2_;
		_tmp2_ = *iter;
		gtk_tree_model_row_changed (model, path, &_tmp2_);
		_data15_->found = TRUE;
		result = TRUE;
		_g_object_unref0 (iter_file);
		return result;
	}
	result = FALSE;
	_g_object_unref0 (iter_file);
	return result;
}

static gboolean
___lambda7__gtk_tree_model_foreach_func (GtkTreeModel* model,
                                         GtkTreePath* path,
                                         GtkTreeIter* iter,
                                         gpointer self)
{
	gboolean result;
	result = __lambda7_ (self, model, path, iter);
	return result;
}

void
files_list_model_file_changed (FilesListModel* self,
                               FilesFile* file,
                               FilesDirectory* dir)
{
	Block15Data* _data15_;
	FilesFile* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	g_return_if_fail (dir != NULL);
	_data15_ = g_slice_new0 (Block15Data);
	_data15_->_ref_count_ = 1;
	_data15_->self = g_object_ref (self);
	_tmp0_ = _g_object_ref0 (file);
	_g_object_unref0 (_data15_->file);
	_data15_->file = _tmp0_;
	_data15_->found = FALSE;
	gtk_tree_model_foreach ((GtkTreeModel*) self, ___lambda7__gtk_tree_model_foreach_func, _data15_);
	if (!_data15_->found) {
		files_list_model_add_file (self, _data15_->file, dir);
	}
	block15_data_unref (_data15_);
	_data15_ = NULL;
}

void
files_list_model_set_should_sort_directories_first (FilesListModel* self,
                                                    gboolean sort_directories_first)
{
	gint sort_column_id = 0;
	GtkSortType order = 0;
	gint _tmp0_ = 0;
	GtkSortType _tmp1_ = 0;
	gboolean _tmp2_;
	g_return_if_fail (self != NULL);
	if (self->priv->sort_directories_first == sort_directories_first) {
		return;
	}
	self->priv->sort_directories_first = sort_directories_first;
	_tmp2_ = gtk_tree_sortable_get_sort_column_id ((GtkTreeSortable*) self, &_tmp0_, &_tmp1_);
	sort_column_id = _tmp0_;
	order = _tmp1_;
	if (!_tmp2_) {
		sort_column_id = (gint) FILES_LIST_MODEL_COLUMN_ID_FILENAME;
		order = GTK_SORT_ASCENDING;
	}
	gtk_tree_sortable_set_sort_column_id ((GtkTreeSortable*) self, GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID, order);
	gtk_tree_sortable_set_sort_column_id ((GtkTreeSortable*) self, sort_column_id, order);
}

gboolean
files_list_model_get_subdirectory (FilesListModel* self,
                                   GtkTreePath* path,
                                   FilesDirectory** dir)
{
	FilesDirectory* _vala_dir = NULL;
	FilesFile* file = NULL;
	GtkTreeIter* iter = NULL;
	GtkTreeIter _tmp0_ = {0};
	gboolean _tmp1_;
	GtkTreeIter _tmp2_;
	GtkTreeIter* _tmp3_;
	FilesDirectory* _tmp10_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (path != NULL, FALSE);
	_g_object_unref0 (_vala_dir);
	_vala_dir = NULL;
	file = NULL;
	_tmp1_ = gtk_tree_model_get_iter ((GtkTreeModel*) self, &_tmp0_, path);
	__vala_GtkTreeIter_free0 (iter);
	_tmp2_ = _tmp0_;
	_tmp3_ = __vala_GtkTreeIter_copy0 (&_tmp2_);
	iter = _tmp3_;
	if (_tmp1_) {
		GtkTreeIter* _tmp4_;
		GtkTreeIter _tmp5_;
		FilesFile* _tmp6_ = NULL;
		FilesFile* _tmp7_;
		_tmp4_ = iter;
		_tmp5_ = *_tmp4_;
		gtk_tree_model_get ((GtkTreeModel*) self, &_tmp5_, FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN, &_tmp6_, -1);
		_g_object_unref0 (file);
		file = _tmp6_;
		_tmp7_ = file;
		if (_tmp7_ != NULL) {
			FilesFile* _tmp8_;
			FilesDirectory* _tmp9_;
			_tmp8_ = file;
			_tmp9_ = files_directory_from_file (_tmp8_);
			_g_object_unref0 (_vala_dir);
			_vala_dir = _tmp9_;
		}
	}
	_tmp10_ = _vala_dir;
	result = _tmp10_ != NULL;
	__vala_GtkTreeIter_free0 (iter);
	_g_object_unref0 (file);
	if (dir) {
		*dir = _vala_dir;
	} else {
		_g_object_unref0 (_vala_dir);
	}
	return result;
}

void
files_list_model_load_subdirectory (FilesListModel* self,
                                    FilesDirectory* dir)
{
	GtkTreeIter* parent_iter = NULL;
	GtkTreeIter* child_iter = NULL;
	gboolean change_dummy = FALSE;
	FilesFile* _tmp0_;
	FilesFile* _tmp1_;
	GtkTreeIter* _tmp2_ = NULL;
	gboolean _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	parent_iter = NULL;
	child_iter = NULL;
	change_dummy = TRUE;
	_tmp0_ = files_directory_get_file (dir);
	_tmp1_ = _tmp0_;
	_tmp3_ = files_list_model_get_first_iter_for_file (self, _tmp1_, &_tmp2_);
	__vala_GtkTreeIter_free0 (parent_iter);
	parent_iter = _tmp2_;
	if (_tmp3_) {
		GList* files = NULL;
		GList* _tmp4_;
		GtkTreeIter* _tmp5_;
		GtkTreeIter _tmp6_ = {0};
		gboolean _tmp7_;
		GtkTreeIter _tmp8_;
		GtkTreeIter* _tmp9_;
		GList* _tmp13_;
		_tmp4_ = files_directory_get_files (dir);
		files = _tmp4_;
		_tmp5_ = parent_iter;
		_tmp7_ = gtk_tree_model_iter_nth_child ((GtkTreeModel*) self, &_tmp6_, _tmp5_, 0);
		__vala_GtkTreeIter_free0 (child_iter);
		_tmp8_ = _tmp6_;
		_tmp9_ = __vala_GtkTreeIter_copy0 (&_tmp8_);
		child_iter = _tmp9_;
		if (_tmp7_) {
			GtkTreeIter* _tmp10_;
			GtkTreeIter _tmp11_;
			gboolean _tmp12_ = FALSE;
			_tmp10_ = child_iter;
			_tmp11_ = *_tmp10_;
			gtk_tree_model_get ((GtkTreeModel*) self, &_tmp11_, FILES_LIST_MODEL_PRIV_COLUMN_ID_DUMMY, &_tmp12_, -1);
			change_dummy = _tmp12_;
		} else {
			g_critical ("ListModel.vala:268: folder item with no child");
		}
		if (!change_dummy) {
			(files == NULL) ? NULL : (files = (g_list_free (files), NULL));
			__vala_GtkTreeIter_free0 (child_iter);
			__vala_GtkTreeIter_free0 (parent_iter);
			return;
		}
		_tmp13_ = files;
		{
			GList* file_collection = NULL;
			GList* file_it = NULL;
			file_collection = _tmp13_;
			for (file_it = file_collection; file_it != NULL; file_it = file_it->next) {
				FilesFile* file = NULL;
				file = (FilesFile*) file_it->data;
				{
					gboolean _tmp14_ = FALSE;
					gboolean _tmp15_;
					FilesFile* _tmp27_;
					_tmp15_ = self->priv->_show_hidden_files;
					if (!_tmp15_) {
						FilesFile* _tmp16_;
						_tmp16_ = file;
						_tmp14_ = _tmp16_->is_hidden;
					} else {
						_tmp14_ = FALSE;
					}
					if (_tmp14_) {
						continue;
					}
					if (change_dummy) {
						GtkTreeIter* _tmp17_;
						FilesFile* _tmp18_;
						GtkTreeIter _tmp19_;
						_tmp17_ = child_iter;
						_tmp18_ = file;
						_tmp19_ = *_tmp17_;
						gtk_tree_store_set ((GtkTreeStore*) self, &_tmp19_, FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN, _tmp18_, FILES_LIST_MODEL_PRIV_COLUMN_ID_DUMMY, FALSE, -1, -1);
						change_dummy = FALSE;
					} else {
						GtkTreeIter* _tmp20_;
						GtkTreeIter _tmp21_ = {0};
						GtkTreeIter _tmp22_;
						GtkTreeIter* _tmp23_;
						GtkTreeIter* _tmp24_;
						FilesFile* _tmp25_;
						GtkTreeIter _tmp26_;
						_tmp20_ = parent_iter;
						gtk_tree_store_insert ((GtkTreeStore*) self, &_tmp21_, _tmp20_, -1);
						__vala_GtkTreeIter_free0 (child_iter);
						_tmp22_ = _tmp21_;
						_tmp23_ = __vala_GtkTreeIter_copy0 (&_tmp22_);
						child_iter = _tmp23_;
						_tmp24_ = child_iter;
						_tmp25_ = file;
						_tmp26_ = *_tmp24_;
						gtk_tree_store_set ((GtkTreeStore*) self, &_tmp26_, FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN, _tmp25_, FILES_LIST_MODEL_PRIV_COLUMN_ID_DUMMY, FALSE, -1, -1);
					}
					_tmp27_ = file;
					if (files_file_is_folder (_tmp27_)) {
						GtkTreeIter* _tmp28_;
						GtkTreeIter _tmp29_ = {0};
						GtkTreeIter _tmp30_;
						GtkTreeIter* _tmp31_;
						_tmp28_ = child_iter;
						gtk_tree_store_insert_with_values ((GtkTreeStore*) self, &_tmp29_, _tmp28_, -1, FILES_LIST_MODEL_PRIV_COLUMN_ID_DUMMY, TRUE, -1);
						__vala_GtkTreeIter_free0 (child_iter);
						_tmp30_ = _tmp29_;
						_tmp31_ = __vala_GtkTreeIter_copy0 (&_tmp30_);
						child_iter = _tmp31_;
					}
				}
			}
		}
		(files == NULL) ? NULL : (files = (g_list_free (files), NULL));
	}
	__vala_GtkTreeIter_free0 (child_iter);
	__vala_GtkTreeIter_free0 (parent_iter);
}

gboolean
files_list_model_unload_subdirectory (FilesListModel* self,
                                      GtkTreeIter* parent_iter)
{
	FilesFile* file = NULL;
	GtkTreeIter _tmp0_;
	FilesFile* _tmp1_ = NULL;
	FilesFile* _tmp2_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (parent_iter != NULL, FALSE);
	file = NULL;
	_tmp0_ = *parent_iter;
	gtk_tree_model_get ((GtkTreeModel*) self, &_tmp0_, FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN, &_tmp1_, -1);
	_g_object_unref0 (file);
	file = _tmp1_;
	_tmp2_ = file;
	if (_tmp2_ != NULL) {
		FilesDirectory* dir = NULL;
		FilesFile* _tmp3_;
		FilesDirectory* _tmp4_;
		FilesDirectory* _tmp5_;
		GtkTreeIter* child_iter = NULL;
		GtkTreeIter _tmp6_;
		GtkTreeIter _tmp7_ = {0};
		gboolean _tmp8_;
		GtkTreeIter _tmp9_;
		GtkTreeIter* _tmp10_;
		GtkTreeIter _tmp12_;
		GtkTreeIter _tmp13_ = {0};
		GtkTreeIter _tmp14_;
		GtkTreeIter* _tmp15_;
		FilesDirectory* _tmp16_;
		_tmp3_ = file;
		_tmp4_ = files_directory_from_file (_tmp3_);
		dir = _tmp4_;
		_tmp5_ = dir;
		files_directory_cancel (_tmp5_);
		child_iter = NULL;
		_tmp6_ = *parent_iter;
		_tmp8_ = gtk_tree_model_iter_children ((GtkTreeModel*) self, &_tmp7_, &_tmp6_);
		__vala_GtkTreeIter_free0 (child_iter);
		_tmp9_ = _tmp7_;
		_tmp10_ = __vala_GtkTreeIter_copy0 (&_tmp9_);
		child_iter = _tmp10_;
		if (_tmp8_) {
			while (TRUE) {
				gboolean _tmp11_;
				_tmp11_ = gtk_tree_store_remove ((GtkTreeStore*) self, child_iter);
				if (!_tmp11_) {
					break;
				}
			}
		}
		_tmp12_ = *parent_iter;
		gtk_tree_store_insert_with_values ((GtkTreeStore*) self, &_tmp13_, &_tmp12_, -1, FILES_LIST_MODEL_PRIV_COLUMN_ID_DUMMY, TRUE, -1);
		__vala_GtkTreeIter_free0 (child_iter);
		_tmp14_ = _tmp13_;
		_tmp15_ = __vala_GtkTreeIter_copy0 (&_tmp14_);
		child_iter = _tmp15_;
		_tmp16_ = dir;
		g_signal_emit (self, files_list_model_signals[FILES_LIST_MODEL_SUBDIRECTORY_UNLOADED_SIGNAL], 0, _tmp16_);
		result = TRUE;
		__vala_GtkTreeIter_free0 (child_iter);
		_g_object_unref0 (dir);
		_g_object_unref0 (file);
		return result;
	}
	result = FALSE;
	_g_object_unref0 (file);
	return result;
}

gboolean
files_list_model_add_file (FilesListModel* self,
                           FilesFile* file,
                           FilesDirectory* dir)
{
	GtkTreeIter* parent_iter = NULL;
	GtkTreeIter* file_iter = NULL;
	GtkTreeIter* dummy_iter = NULL;
	gboolean change_dummy = FALSE;
	GtkTreeIter* _tmp0_ = NULL;
	gboolean _tmp1_;
	FilesFile* _tmp2_;
	FilesFile* _tmp3_;
	GtkTreeIter* _tmp4_ = NULL;
	gboolean _tmp5_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (file != NULL, FALSE);
	g_return_val_if_fail (dir != NULL, FALSE);
	change_dummy = FALSE;
	_tmp1_ = files_list_model_get_first_iter_for_file (self, file, &_tmp0_);
	__vala_GtkTreeIter_free0 (file_iter);
	file_iter = _tmp0_;
	if (_tmp1_) {
		result = FALSE;
		__vala_GtkTreeIter_free0 (dummy_iter);
		__vala_GtkTreeIter_free0 (file_iter);
		__vala_GtkTreeIter_free0 (parent_iter);
		return result;
	}
	_tmp2_ = files_directory_get_file (dir);
	_tmp3_ = _tmp2_;
	_tmp5_ = files_list_model_get_first_iter_for_file (self, _tmp3_, &_tmp4_);
	__vala_GtkTreeIter_free0 (parent_iter);
	parent_iter = _tmp4_;
	if (_tmp5_) {
		GtkTreeIter* _tmp6_;
		GtkTreeIter _tmp7_ = {0};
		gboolean _tmp8_;
		GtkTreeIter _tmp9_;
		GtkTreeIter* _tmp10_;
		_tmp6_ = parent_iter;
		_tmp8_ = gtk_tree_model_iter_nth_child ((GtkTreeModel*) self, &_tmp7_, _tmp6_, 0);
		__vala_GtkTreeIter_free0 (file_iter);
		_tmp9_ = _tmp7_;
		_tmp10_ = __vala_GtkTreeIter_copy0 (&_tmp9_);
		file_iter = _tmp10_;
		if (_tmp8_) {
			GtkTreeIter* _tmp11_;
			GtkTreeIter _tmp12_;
			gboolean _tmp13_ = FALSE;
			_tmp11_ = file_iter;
			_tmp12_ = *_tmp11_;
			gtk_tree_model_get ((GtkTreeModel*) self, &_tmp12_, FILES_LIST_MODEL_PRIV_COLUMN_ID_DUMMY, &_tmp13_, -1);
			change_dummy = _tmp13_;
			if (change_dummy) {
				GtkTreeIter* _tmp14_;
				GtkTreeIter _tmp15_;
				_tmp14_ = file_iter;
				_tmp15_ = *_tmp14_;
				gtk_tree_store_set ((GtkTreeStore*) self, &_tmp15_, FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN, file, FILES_LIST_MODEL_PRIV_COLUMN_ID_DUMMY, FALSE, -1, -1);
			}
		} else {
			g_critical ("ListModel.vala:338: folder item with no child");
		}
	} else {
		__vala_GtkTreeIter_free0 (parent_iter);
		parent_iter = NULL;
	}
	if (!change_dummy) {
		GtkTreeIter* _tmp16_;
		GtkTreeIter _tmp17_ = {0};
		GtkTreeIter _tmp18_;
		GtkTreeIter* _tmp19_;
		_tmp16_ = parent_iter;
		gtk_tree_store_insert_with_values ((GtkTreeStore*) self, &_tmp17_, _tmp16_, 0, FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN, file, FILES_LIST_MODEL_PRIV_COLUMN_ID_DUMMY, FALSE, -1);
		__vala_GtkTreeIter_free0 (file_iter);
		_tmp18_ = _tmp17_;
		_tmp19_ = __vala_GtkTreeIter_copy0 (&_tmp18_);
		file_iter = _tmp19_;
	}
	if (files_file_is_folder (file)) {
		GtkTreeIter* _tmp20_;
		GtkTreeIter _tmp21_ = {0};
		GtkTreeIter _tmp22_;
		GtkTreeIter* _tmp23_;
		_tmp20_ = file_iter;
		gtk_tree_store_insert_with_values ((GtkTreeStore*) self, &_tmp21_, _tmp20_, -1, FILES_LIST_MODEL_PRIV_COLUMN_ID_DUMMY, TRUE, -1);
		__vala_GtkTreeIter_free0 (dummy_iter);
		_tmp22_ = _tmp21_;
		_tmp23_ = __vala_GtkTreeIter_copy0 (&_tmp22_);
		dummy_iter = _tmp23_;
	}
	result = TRUE;
	__vala_GtkTreeIter_free0 (dummy_iter);
	__vala_GtkTreeIter_free0 (file_iter);
	__vala_GtkTreeIter_free0 (parent_iter);
	return result;
}

gboolean
files_list_model_remove_file (FilesListModel* self,
                              FilesFile* file,
                              FilesDirectory* dir)
{
	GtkTreeIter* parent_iter = NULL;
	GtkTreeIter* child_iter = NULL;
	GtkTreeIter* file_iter = NULL;
	GtkTreeIter* dummy_iter = NULL;
	GtkTreeIter* _tmp0_ = NULL;
	gboolean _tmp1_;
	GtkTreeIter* _tmp2_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (file != NULL, FALSE);
	g_return_val_if_fail (dir != NULL, FALSE);
	_tmp1_ = files_list_model_get_first_iter_for_file (self, file, &_tmp0_);
	__vala_GtkTreeIter_free0 (file_iter);
	file_iter = _tmp0_;
	if (!_tmp1_) {
		result = FALSE;
		__vala_GtkTreeIter_free0 (dummy_iter);
		__vala_GtkTreeIter_free0 (file_iter);
		__vala_GtkTreeIter_free0 (child_iter);
		__vala_GtkTreeIter_free0 (parent_iter);
		return result;
	}
	_tmp2_ = file_iter;
	if (_tmp2_ != NULL) {
		FilesFile* _tmp3_;
		FilesFile* _tmp4_;
		GtkTreeIter* _tmp5_ = NULL;
		gboolean _tmp6_;
		_tmp3_ = files_directory_get_file (dir);
		_tmp4_ = _tmp3_;
		_tmp6_ = files_list_model_get_first_iter_for_file (self, _tmp4_, &_tmp5_);
		__vala_GtkTreeIter_free0 (parent_iter);
		parent_iter = _tmp5_;
		if (_tmp6_) {
			GtkTreeIter* _tmp7_;
			GtkTreeIter _tmp8_ = {0};
			gboolean _tmp9_;
			GtkTreeIter _tmp10_;
			GtkTreeIter* _tmp11_;
			_tmp7_ = parent_iter;
			_tmp9_ = gtk_tree_model_iter_nth_child ((GtkTreeModel*) self, &_tmp8_, _tmp7_, 1);
			__vala_GtkTreeIter_free0 (child_iter);
			_tmp10_ = _tmp8_;
			_tmp11_ = __vala_GtkTreeIter_copy0 (&_tmp10_);
			child_iter = _tmp11_;
			if (!_tmp9_) {
				GtkTreeIter* _tmp12_;
				GtkTreeIter _tmp13_ = {0};
				GtkTreeIter _tmp14_;
				GtkTreeIter* _tmp15_;
				_tmp12_ = parent_iter;
				gtk_tree_store_insert_with_values ((GtkTreeStore*) self, &_tmp13_, _tmp12_, -1, FILES_LIST_MODEL_PRIV_COLUMN_ID_DUMMY, TRUE, -1);
				__vala_GtkTreeIter_free0 (dummy_iter);
				_tmp14_ = _tmp13_;
				_tmp15_ = __vala_GtkTreeIter_copy0 (&_tmp14_);
				dummy_iter = _tmp15_;
			}
		}
		gtk_tree_store_remove ((GtkTreeStore*) self, file_iter);
		result = TRUE;
		__vala_GtkTreeIter_free0 (dummy_iter);
		__vala_GtkTreeIter_free0 (file_iter);
		__vala_GtkTreeIter_free0 (child_iter);
		__vala_GtkTreeIter_free0 (parent_iter);
		return result;
	}
	result = FALSE;
	__vala_GtkTreeIter_free0 (dummy_iter);
	__vala_GtkTreeIter_free0 (file_iter);
	__vala_GtkTreeIter_free0 (child_iter);
	__vala_GtkTreeIter_free0 (parent_iter);
	return result;
}

static gint
files_list_model_file_entry_compare_func (FilesListModel* self,
                                          GtkTreeIter* a,
                                          GtkTreeIter* b)
{
	FilesFile* file_a = NULL;
	FilesFile* file_b = NULL;
	GtkTreeIter _tmp0_;
	FilesFile* _tmp1_ = NULL;
	GtkTreeIter _tmp2_;
	FilesFile* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	FilesFile* _tmp7_;
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	file_a = NULL;
	file_b = NULL;
	_tmp0_ = *a;
	gtk_tree_model_get ((GtkTreeModel*) self, &_tmp0_, FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN, &_tmp1_, -1);
	_g_object_unref0 (file_a);
	file_a = _tmp1_;
	_tmp2_ = *b;
	gtk_tree_model_get ((GtkTreeModel*) self, &_tmp2_, FILES_LIST_MODEL_COLUMN_ID_FILE_COLUMN, &_tmp3_, -1);
	_g_object_unref0 (file_b);
	file_b = _tmp3_;
	_tmp7_ = file_a;
	if (_tmp7_ != NULL) {
		FilesFile* _tmp8_;
		_tmp8_ = file_b;
		_tmp6_ = _tmp8_ != NULL;
	} else {
		_tmp6_ = FALSE;
	}
	if (_tmp6_) {
		FilesFile* _tmp9_;
		GFile* _tmp10_;
		GFile* _tmp11_;
		_tmp9_ = file_a;
		_tmp10_ = files_file_get_location (_tmp9_);
		_tmp11_ = _tmp10_;
		_tmp5_ = _tmp11_ != NULL;
	} else {
		_tmp5_ = FALSE;
	}
	if (_tmp5_) {
		FilesFile* _tmp12_;
		GFile* _tmp13_;
		GFile* _tmp14_;
		_tmp12_ = file_b;
		_tmp13_ = files_file_get_location (_tmp12_);
		_tmp14_ = _tmp13_;
		_tmp4_ = _tmp14_ != NULL;
	} else {
		_tmp4_ = FALSE;
	}
	if (_tmp4_) {
		gint sort_column_id = 0;
		GtkSortType order = 0;
		gint _tmp15_ = 0;
		GtkSortType _tmp16_ = 0;
		gboolean _tmp17_;
		FilesFile* _tmp18_;
		FilesFile* _tmp19_;
		_tmp17_ = gtk_tree_sortable_get_sort_column_id ((GtkTreeSortable*) self, &_tmp15_, &_tmp16_);
		sort_column_id = _tmp15_;
		order = _tmp16_;
		if (!_tmp17_) {
			sort_column_id = (gint) FILES_LIST_MODEL_COLUMN_ID_FILENAME;
			order = GTK_SORT_ASCENDING;
		}
		_tmp18_ = file_a;
		_tmp19_ = file_b;
		result = files_file_compare_for_sort (_tmp18_, _tmp19_, sort_column_id, self->priv->sort_directories_first, order == GTK_SORT_DESCENDING);
		_g_object_unref0 (file_b);
		_g_object_unref0 (file_a);
		return result;
	} else {
		gboolean _tmp20_ = FALSE;
		FilesFile* _tmp21_;
		_tmp21_ = file_a;
		if (_tmp21_ == NULL) {
			_tmp20_ = TRUE;
		} else {
			FilesFile* _tmp22_;
			GFile* _tmp23_;
			GFile* _tmp24_;
			_tmp22_ = file_a;
			_tmp23_ = files_file_get_location (_tmp22_);
			_tmp24_ = _tmp23_;
			_tmp20_ = _tmp24_ == NULL;
		}
		if (_tmp20_) {
			result = -1;
			_g_object_unref0 (file_b);
			_g_object_unref0 (file_a);
			return result;
		} else {
			result = 1;
			_g_object_unref0 (file_b);
			_g_object_unref0 (file_a);
			return result;
		}
	}
}

FilesListModel*
files_list_model_construct (GType object_type)
{
	FilesListModel * self = NULL;
	self = (FilesListModel*) g_object_new (object_type, NULL);
	return self;
}

FilesListModel*
files_list_model_new (void)
{
	return files_list_model_construct (FILES_TYPE_LIST_MODEL);
}

gboolean
files_list_model_get_show_hidden_files (FilesListModel* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_show_hidden_files;
	return result;
}

void
files_list_model_set_show_hidden_files (FilesListModel* self,
                                        gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = files_list_model_get_show_hidden_files (self);
	if (old_value != value) {
		self->priv->_show_hidden_files = value;
		g_object_notify_by_pspec ((GObject *) self, files_list_model_properties[FILES_LIST_MODEL_SHOW_HIDDEN_FILES_PROPERTY]);
	}
}

gint
files_list_model_get_icon_size (FilesListModel* self)
{
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_icon_size;
	return result;
}

void
files_list_model_set_icon_size (FilesListModel* self,
                                gint value)
{
	gint old_value;
	g_return_if_fail (self != NULL);
	old_value = files_list_model_get_icon_size (self);
	if (old_value != value) {
		self->priv->_icon_size = value;
		g_object_notify_by_pspec ((GObject *) self, files_list_model_properties[FILES_LIST_MODEL_ICON_SIZE_PROPERTY]);
	}
}

gboolean
files_list_model_get_has_child (FilesListModel* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_has_child;
	return result;
}

void
files_list_model_set_has_child (FilesListModel* self,
                                gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = files_list_model_get_has_child (self);
	if (old_value != value) {
		self->priv->_has_child = value;
		g_object_notify_by_pspec ((GObject *) self, files_list_model_properties[FILES_LIST_MODEL_HAS_CHILD_PROPERTY]);
	}
}

static GObject *
files_list_model_constructor (GType type,
                              guint n_construct_properties,
                              GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	FilesListModel * self;
	GType* _tmp0_;
	GType* _tmp1_;
	gint _tmp1__length1;
	parent_class = G_OBJECT_CLASS (files_list_model_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_TYPE_LIST_MODEL, FilesListModel);
	_tmp0_ = g_new0 (GType, 8);
	_tmp0_[0] = FILES_TYPE_FILE;
	_tmp0_[1] = G_TYPE_STRING;
	_tmp0_[2] = gdk_pixbuf_get_type ();
	_tmp0_[3] = G_TYPE_STRING;
	_tmp0_[4] = G_TYPE_STRING;
	_tmp0_[5] = G_TYPE_STRING;
	_tmp0_[6] = G_TYPE_STRING;
	_tmp0_[7] = G_TYPE_BOOLEAN;
	_tmp1_ = _tmp0_;
	_tmp1__length1 = 8;
	gtk_tree_store_set_column_types ((GtkTreeStore*) self, (gint) 8, _tmp1_);
	_tmp1_ = (g_free (_tmp1_), NULL);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				if (!(i < ((gint) FILES_LIST_MODEL_COLUMN_ID_NUM_COLUMNS))) {
					break;
				}
				gtk_tree_sortable_set_sort_func ((GtkTreeSortable*) self, i, (GtkTreeIterCompareFunc) files_list_model_file_entry_compare_func, g_object_ref (self), g_object_unref);
			}
		}
	}
	gtk_tree_sortable_set_sort_column_id ((GtkTreeSortable*) self, (gint) FILES_LIST_MODEL_COLUMN_ID_FILENAME, GTK_SORT_ASCENDING);
	return obj;
}

static void
files_list_model_class_init (FilesListModelClass * klass,
                             gpointer klass_data)
{
	files_list_model_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &FilesListModel_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_files_list_model_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_files_list_model_set_property;
	G_OBJECT_CLASS (klass)->constructor = files_list_model_constructor;
	G_OBJECT_CLASS (klass)->finalize = files_list_model_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_LIST_MODEL_SHOW_HIDDEN_FILES_PROPERTY, files_list_model_properties[FILES_LIST_MODEL_SHOW_HIDDEN_FILES_PROPERTY] = g_param_spec_boolean ("show-hidden-files", "show-hidden-files", "show-hidden-files", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_LIST_MODEL_ICON_SIZE_PROPERTY, files_list_model_properties[FILES_LIST_MODEL_ICON_SIZE_PROPERTY] = g_param_spec_int ("icon-size", "icon-size", "icon-size", G_MININT, G_MAXINT, 32, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FILES_LIST_MODEL_HAS_CHILD_PROPERTY, files_list_model_properties[FILES_LIST_MODEL_HAS_CHILD_PROPERTY] = g_param_spec_boolean ("has-child", "has-child", "has-child", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	files_list_model_signals[FILES_LIST_MODEL_SUBDIRECTORY_UNLOADED_SIGNAL] = g_signal_new ("subdirectory-unloaded", FILES_TYPE_LIST_MODEL, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, FILES_TYPE_DIRECTORY);
}

static void
files_list_model_gtk_tree_model_interface_init (GtkTreeModelIface * iface,
                                                gpointer iface_data)
{
	files_list_model_gtk_tree_model_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_value = (void (*) (GtkTreeModel*, GtkTreeIter*, gint, GValue*)) files_list_model_real_get_value;
}

static void
files_list_model_instance_init (FilesListModel * self,
                                gpointer klass)
{
	self->priv = files_list_model_get_instance_private (self);
	self->priv->_show_hidden_files = FALSE;
	self->priv->_icon_size = 32;
	self->priv->_has_child = FALSE;
	self->priv->sort_directories_first = TRUE;
}

static void
files_list_model_finalize (GObject * obj)
{
	FilesListModel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_TYPE_LIST_MODEL, FilesListModel);
	G_OBJECT_CLASS (files_list_model_parent_class)->finalize (obj);
}

static GType
files_list_model_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FilesListModelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) files_list_model_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FilesListModel), 0, (GInstanceInitFunc) files_list_model_instance_init, NULL };
	static const GInterfaceInfo gtk_tree_model_info = { (GInterfaceInitFunc) files_list_model_gtk_tree_model_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType files_list_model_type_id;
	files_list_model_type_id = g_type_register_static (gtk_tree_store_get_type (), "FilesListModel", &g_define_type_info, 0);
	g_type_add_interface_static (files_list_model_type_id, gtk_tree_model_get_type (), &gtk_tree_model_info);
	FilesListModel_private_offset = g_type_add_instance_private (files_list_model_type_id, sizeof (FilesListModelPrivate));
	return files_list_model_type_id;
}

GType
files_list_model_get_type (void)
{
	static volatile gsize files_list_model_type_id__once = 0;
	if (g_once_init_enter (&files_list_model_type_id__once)) {
		GType files_list_model_type_id;
		files_list_model_type_id = files_list_model_get_type_once ();
		g_once_init_leave (&files_list_model_type_id__once, files_list_model_type_id);
	}
	return files_list_model_type_id__once;
}

static void
_vala_files_list_model_get_property (GObject * object,
                                     guint property_id,
                                     GValue * value,
                                     GParamSpec * pspec)
{
	FilesListModel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FILES_TYPE_LIST_MODEL, FilesListModel);
	switch (property_id) {
		case FILES_LIST_MODEL_SHOW_HIDDEN_FILES_PROPERTY:
		g_value_set_boolean (value, files_list_model_get_show_hidden_files (self));
		break;
		case FILES_LIST_MODEL_ICON_SIZE_PROPERTY:
		g_value_set_int (value, files_list_model_get_icon_size (self));
		break;
		case FILES_LIST_MODEL_HAS_CHILD_PROPERTY:
		g_value_set_boolean (value, files_list_model_get_has_child (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_files_list_model_set_property (GObject * object,
                                     guint property_id,
                                     const GValue * value,
                                     GParamSpec * pspec)
{
	FilesListModel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FILES_TYPE_LIST_MODEL, FilesListModel);
	switch (property_id) {
		case FILES_LIST_MODEL_SHOW_HIDDEN_FILES_PROPERTY:
		files_list_model_set_show_hidden_files (self, g_value_get_boolean (value));
		break;
		case FILES_LIST_MODEL_ICON_SIZE_PROPERTY:
		files_list_model_set_icon_size (self, g_value_get_int (value));
		break;
		case FILES_LIST_MODEL_HAS_CHILD_PROPERTY:
		files_list_model_set_has_child (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

