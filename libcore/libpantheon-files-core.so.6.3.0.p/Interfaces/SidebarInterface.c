/* SidebarInterface.c generated by valac 0.56.3, the Vala compiler
 * generated from SidebarInterface.vala, do not modify */

#include "pantheon-files-core.h"
#include <glib.h>
#include <stdlib.h>
#include <string.h>

enum  {
	FILES_SIDEBAR_INTERFACE_REQUEST_UPDATE_SIGNAL,
	FILES_SIDEBAR_INTERFACE_REQUEST_FOCUS_SIGNAL,
	FILES_SIDEBAR_INTERFACE_SYNC_NEEDED_SIGNAL,
	FILES_SIDEBAR_INTERFACE_PATH_CHANGE_REQUEST_SIGNAL,
	FILES_SIDEBAR_INTERFACE_CONNECT_SERVER_REQUEST_SIGNAL,
	FILES_SIDEBAR_INTERFACE_NUM_SIGNALS
};
static guint files_sidebar_interface_signals[FILES_SIDEBAR_INTERFACE_NUM_SIGNALS] = {0};

static void g_cclosure_user_marshal_BOOLEAN__VOID (GClosure * closure,
                                            GValue * return_value,
                                            guint n_param_values,
                                            const GValue * param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__STRING_ENUM (GClosure * closure,
                                                GValue * return_value,
                                                guint n_param_values,
                                                const GValue * param_values,
                                                gpointer invocation_hint,
                                                gpointer marshal_data);
static GType files_sidebar_interface_get_type_once (void);
static inline gpointer _vala_memdup2 (gconstpointer mem,
                        gsize byte_size);

static GType
files_place_type_get_type_once (void)
{
	static const GEnumValue values[] = {{FILES_PLACE_TYPE_BUILT_IN, "FILES_PLACE_TYPE_BUILT_IN", "built-in"}, {FILES_PLACE_TYPE_MOUNTED_VOLUME, "FILES_PLACE_TYPE_MOUNTED_VOLUME", "mounted-volume"}, {FILES_PLACE_TYPE_BOOKMARK, "FILES_PLACE_TYPE_BOOKMARK", "bookmark"}, {FILES_PLACE_TYPE_BOOKMARKS_CATEGORY, "FILES_PLACE_TYPE_BOOKMARKS_CATEGORY", "bookmarks-category"}, {FILES_PLACE_TYPE_PERSONAL_CATEGORY, "FILES_PLACE_TYPE_PERSONAL_CATEGORY", "personal-category"}, {FILES_PLACE_TYPE_STORAGE_CATEGORY, "FILES_PLACE_TYPE_STORAGE_CATEGORY", "storage-category"}, {FILES_PLACE_TYPE_NETWORK_CATEGORY, "FILES_PLACE_TYPE_NETWORK_CATEGORY", "network-category"}, {FILES_PLACE_TYPE_PLUGIN_ITEM, "FILES_PLACE_TYPE_PLUGIN_ITEM", "plugin-item"}, {0, NULL, NULL}};
	GType files_place_type_type_id;
	files_place_type_type_id = g_enum_register_static ("FilesPlaceType", values);
	return files_place_type_type_id;
}

GType
files_place_type_get_type (void)
{
	static volatile gsize files_place_type_type_id__once = 0;
	if (g_once_init_enter (&files_place_type_type_id__once)) {
		GType files_place_type_type_id;
		files_place_type_type_id = files_place_type_get_type_once ();
		g_once_init_leave (&files_place_type_type_id__once, files_place_type_type_id);
	}
	return files_place_type_type_id__once;
}

guint32
files_sidebar_interface_add_plugin_item (FilesSidebarInterface* self,
                                         FilesSidebarPluginItem* item,
                                         FilesPlaceType category)
{
	FilesSidebarInterfaceIface* _iface_;
	g_return_val_if_fail (self != NULL, 0U);
	_iface_ = FILES_SIDEBAR_INTERFACE_GET_INTERFACE (self);
	if (_iface_->add_plugin_item) {
		return _iface_->add_plugin_item (self, item, category);
	}
	return 0U;
}

gboolean
files_sidebar_interface_update_plugin_item (FilesSidebarInterface* self,
                                            FilesSidebarPluginItem* item,
                                            guint32 item_id)
{
	FilesSidebarInterfaceIface* _iface_;
	g_return_val_if_fail (self != NULL, FALSE);
	_iface_ = FILES_SIDEBAR_INTERFACE_GET_INTERFACE (self);
	if (_iface_->update_plugin_item) {
		return _iface_->update_plugin_item (self, item, item_id);
	}
	return FALSE;
}

gboolean
files_sidebar_interface_remove_item_by_id (FilesSidebarInterface* self,
                                           guint32 item_id)
{
	FilesSidebarInterfaceIface* _iface_;
	g_return_val_if_fail (self != NULL, FALSE);
	_iface_ = FILES_SIDEBAR_INTERFACE_GET_INTERFACE (self);
	if (_iface_->remove_item_by_id) {
		return _iface_->remove_item_by_id (self, item_id);
	}
	return FALSE;
}

void
files_sidebar_interface_add_favorite_uri (FilesSidebarInterface* self,
                                          const gchar* uri,
                                          const gchar* custom_name)
{
	FilesSidebarInterfaceIface* _iface_;
	g_return_if_fail (self != NULL);
	_iface_ = FILES_SIDEBAR_INTERFACE_GET_INTERFACE (self);
	if (_iface_->add_favorite_uri) {
		_iface_->add_favorite_uri (self, uri, custom_name);
	}
}

gboolean
files_sidebar_interface_has_favorite_uri (FilesSidebarInterface* self,
                                          const gchar* uri)
{
	FilesSidebarInterfaceIface* _iface_;
	g_return_val_if_fail (self != NULL, FALSE);
	_iface_ = FILES_SIDEBAR_INTERFACE_GET_INTERFACE (self);
	if (_iface_->has_favorite_uri) {
		return _iface_->has_favorite_uri (self, uri);
	}
	return FALSE;
}

void
files_sidebar_interface_sync_uri (FilesSidebarInterface* self,
                                  const gchar* uri)
{
	FilesSidebarInterfaceIface* _iface_;
	g_return_if_fail (self != NULL);
	_iface_ = FILES_SIDEBAR_INTERFACE_GET_INTERFACE (self);
	if (_iface_->sync_uri) {
		_iface_->sync_uri (self, uri);
	}
}

void
files_sidebar_interface_reload (FilesSidebarInterface* self)
{
	FilesSidebarInterfaceIface* _iface_;
	g_return_if_fail (self != NULL);
	_iface_ = FILES_SIDEBAR_INTERFACE_GET_INTERFACE (self);
	if (_iface_->reload) {
		_iface_->reload (self);
	}
}

void
files_sidebar_interface_on_free_space_change (FilesSidebarInterface* self)
{
	FilesSidebarInterfaceIface* _iface_;
	g_return_if_fail (self != NULL);
	_iface_ = FILES_SIDEBAR_INTERFACE_GET_INTERFACE (self);
	if (_iface_->on_free_space_change) {
		_iface_->on_free_space_change (self);
	}
}

static void
g_cclosure_user_marshal_BOOLEAN__VOID (GClosure * closure,
                                       GValue * return_value,
                                       guint n_param_values,
                                       const GValue * param_values,
                                       gpointer invocation_hint,
                                       gpointer marshal_data)
{
	typedef gboolean (*GMarshalFunc_BOOLEAN__VOID) (gpointer data1, gpointer data2);
	register GMarshalFunc_BOOLEAN__VOID callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	gboolean v_return;
	cc = (GCClosure *) closure;
	g_return_if_fail (return_value != NULL);
	g_return_if_fail (n_param_values == 1);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_BOOLEAN__VOID) (marshal_data ? marshal_data : cc->callback);
	v_return = callback (data1, data2);
	g_value_set_boolean (return_value, v_return);
}

static void
g_cclosure_user_marshal_VOID__STRING_ENUM (GClosure * closure,
                                           GValue * return_value,
                                           guint n_param_values,
                                           const GValue * param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__STRING_ENUM) (gpointer data1, const char* arg_1, gint arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_ENUM callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_ENUM) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_enum (param_values + 2), data2);
}

static void
files_sidebar_interface_default_init (FilesSidebarInterfaceIface * iface,
                                      gpointer iface_data)
{
	files_sidebar_interface_signals[FILES_SIDEBAR_INTERFACE_REQUEST_UPDATE_SIGNAL] = g_signal_new ("request-update", FILES_TYPE_SIDEBAR_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	files_sidebar_interface_signals[FILES_SIDEBAR_INTERFACE_REQUEST_FOCUS_SIGNAL] = g_signal_new ("request-focus", FILES_TYPE_SIDEBAR_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_BOOLEAN__VOID, G_TYPE_BOOLEAN, 0);
	files_sidebar_interface_signals[FILES_SIDEBAR_INTERFACE_SYNC_NEEDED_SIGNAL] = g_signal_new ("sync-needed", FILES_TYPE_SIDEBAR_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	files_sidebar_interface_signals[FILES_SIDEBAR_INTERFACE_PATH_CHANGE_REQUEST_SIGNAL] = g_signal_new ("path-change-request", FILES_TYPE_SIDEBAR_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_ENUM, G_TYPE_NONE, 2, G_TYPE_STRING, FILES_TYPE_OPEN_FLAG);
	files_sidebar_interface_signals[FILES_SIDEBAR_INTERFACE_CONNECT_SERVER_REQUEST_SIGNAL] = g_signal_new ("connect-server-request", FILES_TYPE_SIDEBAR_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}

static GType
files_sidebar_interface_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FilesSidebarInterfaceIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) files_sidebar_interface_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
	GType files_sidebar_interface_type_id;
	files_sidebar_interface_type_id = g_type_register_static (G_TYPE_INTERFACE, "FilesSidebarInterface", &g_define_type_info, 0);
	g_type_interface_add_prerequisite (files_sidebar_interface_type_id, gtk_widget_get_type ());
	return files_sidebar_interface_type_id;
}

GType
files_sidebar_interface_get_type (void)
{
	static volatile gsize files_sidebar_interface_type_id__once = 0;
	if (g_once_init_enter (&files_sidebar_interface_type_id__once)) {
		GType files_sidebar_interface_type_id;
		files_sidebar_interface_type_id = files_sidebar_interface_get_type_once ();
		g_once_init_leave (&files_sidebar_interface_type_id__once, files_sidebar_interface_type_id);
	}
	return files_sidebar_interface_type_id__once;
}

static inline gpointer
_vala_memdup2 (gconstpointer mem,
               gsize byte_size)
{
	gpointer new_mem;
	if (mem && byte_size != 0) {
		new_mem = g_malloc (byte_size);
		memcpy (new_mem, mem, byte_size);
	} else {
		new_mem = NULL;
	}
	return new_mem;
}

