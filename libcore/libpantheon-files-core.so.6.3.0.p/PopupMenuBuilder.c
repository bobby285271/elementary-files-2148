/* PopupMenuBuilder.c generated by valac 0.56.3, the Vala compiler
 * generated from PopupMenuBuilder.vala, do not modify */

#include "pantheon-files-core.h"
#include <gtk/gtk.h>
#include <glib.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <glib-object.h>

enum  {
	POPUP_MENU_BUILDER_0_PROPERTY,
	POPUP_MENU_BUILDER_N_ITEMS_PROPERTY,
	POPUP_MENU_BUILDER_NUM_PROPERTIES
};
static GParamSpec* popup_menu_builder_properties[POPUP_MENU_BUILDER_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _Block16Data Block16Data;

struct _PopupMenuBuilderPrivate {
	GtkMenuItem** menu_items;
	gint menu_items_length1;
	gint _menu_items_size_;
};

struct _Block16Data {
	int _ref_count_;
	PopupMenuBuilder* self;
	PopupMenuBuilderMenuitemCallback cb;
	gpointer cb_target;
};

static gint PopupMenuBuilder_private_offset;
static gpointer popup_menu_builder_parent_class = NULL;

static void _g_object_unref0_ (gpointer var);
static inline void _g_list_free__g_object_unref0_ (GList* self);
static Block16Data* block16_data_ref (Block16Data* _data16_);
static void block16_data_unref (void * _userdata_);
static void ___lambda56_ (Block16Data* _data16_,
                   GtkMenuItem* menu_item);
static void ____lambda56__gtk_menu_item_activate (GtkMenuItem* _sender,
                                           gpointer self);
static void _vala_array_add3 (GtkMenuItem** * array,
                       gint* length,
                       gint* size,
                       GtkMenuItem* value);
static void popup_menu_builder_finalize (GObject * obj);
static GType popup_menu_builder_get_type_once (void);
static void _vala_popup_menu_builder_get_property (GObject * object,
                                            guint property_id,
                                            GValue * value,
                                            GParamSpec * pspec);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);

static inline gpointer
popup_menu_builder_get_instance_private (PopupMenuBuilder* self)
{
	return G_STRUCT_MEMBER_P (self, PopupMenuBuilder_private_offset);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

GtkMenu*
popup_menu_builder_build (PopupMenuBuilder* self)
{
	GtkMenu* popupmenu = NULL;
	GtkMenu* _tmp0_;
	GtkMenuItem** _tmp1_;
	gint _tmp1__length1;
	GtkMenu* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkMenu*) gtk_menu_new ();
	g_object_ref_sink (_tmp0_);
	popupmenu = _tmp0_;
	_tmp1_ = self->priv->menu_items;
	_tmp1__length1 = self->priv->menu_items_length1;
	{
		GtkMenuItem** menu_item_collection = NULL;
		gint menu_item_collection_length1 = 0;
		gint _menu_item_collection_size_ = 0;
		gint menu_item_it = 0;
		menu_item_collection = _tmp1_;
		menu_item_collection_length1 = _tmp1__length1;
		for (menu_item_it = 0; menu_item_it < menu_item_collection_length1; menu_item_it = menu_item_it + 1) {
			GtkMenuItem* _tmp2_;
			GtkMenuItem* menu_item = NULL;
			_tmp2_ = _g_object_ref0 (menu_item_collection[menu_item_it]);
			menu_item = _tmp2_;
			{
				GtkMenu* _tmp3_;
				GtkMenuItem* _tmp4_;
				_tmp3_ = popupmenu;
				_tmp4_ = menu_item;
				gtk_menu_shell_append ((GtkMenuShell*) _tmp3_, _tmp4_);
				_g_object_unref0 (menu_item);
			}
		}
	}
	result = popupmenu;
	return result;
}

GtkMenu*
popup_menu_builder_build_from_model (PopupMenuBuilder* self,
                                     GMenuModel* model,
                                     const gchar* action_group_namespace,
                                     GActionGroup* action_group)
{
	GtkMenu* menu = NULL;
	GtkMenu* _tmp0_;
	GtkMenu* _tmp1_;
	GtkMenu* result;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (model != NULL, NULL);
	_tmp0_ = (GtkMenu*) gtk_menu_new_from_model (model);
	g_object_ref_sink (_tmp0_);
	menu = _tmp0_;
	_tmp1_ = menu;
	gtk_widget_insert_action_group ((GtkWidget*) _tmp1_, action_group_namespace, action_group);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				GtkMenuItem** _tmp4_;
				gint _tmp4__length1;
				GtkMenu* _tmp5_;
				GtkMenuItem** _tmp6_;
				gint _tmp6__length1;
				GtkMenuItem* _tmp7_;
				GtkMenu* _tmp8_;
				GtkMenuItem** _tmp9_;
				gint _tmp9__length1;
				GtkMenuItem* _tmp10_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = self->priv->menu_items;
				_tmp4__length1 = self->priv->menu_items_length1;
				if (!(i < _tmp4__length1)) {
					break;
				}
				_tmp5_ = menu;
				_tmp6_ = self->priv->menu_items;
				_tmp6__length1 = self->priv->menu_items_length1;
				_tmp7_ = _tmp6_[i];
				gtk_menu_shell_append ((GtkMenuShell*) _tmp5_, _tmp7_);
				_tmp8_ = menu;
				_tmp9_ = self->priv->menu_items;
				_tmp9__length1 = self->priv->menu_items_length1;
				_tmp10_ = _tmp9_[i];
				gtk_menu_reorder_child (_tmp8_, (GtkWidget*) _tmp10_, i);
			}
		}
	}
	result = menu;
	return result;
}

PopupMenuBuilder*
popup_menu_builder_add_open (PopupMenuBuilder* self,
                             PopupMenuBuilderMenuitemCallback cb,
                             gpointer cb_target)
{
	GtkMenuItem* _tmp0_;
	GtkMenuItem* _tmp1_;
	PopupMenuBuilder* _tmp2_;
	PopupMenuBuilder* _tmp3_;
	PopupMenuBuilder* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkMenuItem*) gtk_menu_item_new_with_mnemonic (_ ("Open"));
	g_object_ref_sink (_tmp0_);
	_tmp1_ = _tmp0_;
	_tmp2_ = popup_menu_builder_add_item (self, _tmp1_, cb, cb_target);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (_tmp1_);
	result = _tmp3_;
	return result;
}

PopupMenuBuilder*
popup_menu_builder_add_open_tab (PopupMenuBuilder* self,
                                 PopupMenuBuilderMenuitemCallback cb,
                                 gpointer cb_target)
{
	GtkMenuItem* _tmp0_;
	GtkMenuItem* _tmp1_;
	PopupMenuBuilder* _tmp2_;
	PopupMenuBuilder* _tmp3_;
	PopupMenuBuilder* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkMenuItem*) gtk_menu_item_new_with_mnemonic (_ ("Open in New _Tab"));
	g_object_ref_sink (_tmp0_);
	_tmp1_ = _tmp0_;
	_tmp2_ = popup_menu_builder_add_item (self, _tmp1_, cb, cb_target);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (_tmp1_);
	result = _tmp3_;
	return result;
}

PopupMenuBuilder*
popup_menu_builder_add_open_window (PopupMenuBuilder* self,
                                    PopupMenuBuilderMenuitemCallback cb,
                                    gpointer cb_target)
{
	GtkMenuItem* _tmp0_;
	GtkMenuItem* _tmp1_;
	PopupMenuBuilder* _tmp2_;
	PopupMenuBuilder* _tmp3_;
	PopupMenuBuilder* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkMenuItem*) gtk_menu_item_new_with_mnemonic (_ ("Open in New _Window"));
	g_object_ref_sink (_tmp0_);
	_tmp1_ = _tmp0_;
	_tmp2_ = popup_menu_builder_add_item (self, _tmp1_, cb, cb_target);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (_tmp1_);
	result = _tmp3_;
	return result;
}

PopupMenuBuilder*
popup_menu_builder_add_remove (PopupMenuBuilder* self,
                               PopupMenuBuilderMenuitemCallback cb,
                               gpointer cb_target)
{
	GtkMenuItem* _tmp0_;
	GtkMenuItem* _tmp1_;
	PopupMenuBuilder* _tmp2_;
	PopupMenuBuilder* _tmp3_;
	PopupMenuBuilder* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_ ("Remove"));
	g_object_ref_sink (_tmp0_);
	_tmp1_ = _tmp0_;
	_tmp2_ = popup_menu_builder_add_item (self, _tmp1_, cb, cb_target);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (_tmp1_);
	result = _tmp3_;
	return result;
}

PopupMenuBuilder*
popup_menu_builder_add_rename (PopupMenuBuilder* self,
                               PopupMenuBuilderMenuitemCallback cb,
                               gpointer cb_target)
{
	GtkMenuItem* _tmp0_;
	GtkMenuItem* _tmp1_;
	PopupMenuBuilder* _tmp2_;
	PopupMenuBuilder* _tmp3_;
	PopupMenuBuilder* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_ ("Rename"));
	g_object_ref_sink (_tmp0_);
	_tmp1_ = _tmp0_;
	_tmp2_ = popup_menu_builder_add_item (self, _tmp1_, cb, cb_target);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (_tmp1_);
	result = _tmp3_;
	return result;
}

PopupMenuBuilder*
popup_menu_builder_add_mount (PopupMenuBuilder* self,
                              PopupMenuBuilderMenuitemCallback cb,
                              gpointer cb_target)
{
	GtkMenuItem* _tmp0_;
	GtkMenuItem* _tmp1_;
	PopupMenuBuilder* _tmp2_;
	PopupMenuBuilder* _tmp3_;
	PopupMenuBuilder* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkMenuItem*) gtk_menu_item_new_with_mnemonic (_ ("_Mount"));
	g_object_ref_sink (_tmp0_);
	_tmp1_ = _tmp0_;
	_tmp2_ = popup_menu_builder_add_item (self, _tmp1_, cb, cb_target);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (_tmp1_);
	result = _tmp3_;
	return result;
}

PopupMenuBuilder*
popup_menu_builder_add_unmount (PopupMenuBuilder* self,
                                PopupMenuBuilderMenuitemCallback cb,
                                gpointer cb_target)
{
	GtkMenuItem* _tmp0_;
	GtkMenuItem* _tmp1_;
	PopupMenuBuilder* _tmp2_;
	PopupMenuBuilder* _tmp3_;
	PopupMenuBuilder* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkMenuItem*) gtk_menu_item_new_with_mnemonic (_ ("_Unmount"));
	g_object_ref_sink (_tmp0_);
	_tmp1_ = _tmp0_;
	_tmp2_ = popup_menu_builder_add_item (self, _tmp1_, cb, cb_target);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (_tmp1_);
	result = _tmp3_;
	return result;
}

PopupMenuBuilder*
popup_menu_builder_add_drive_property (PopupMenuBuilder* self,
                                       PopupMenuBuilderMenuitemCallback cb,
                                       gpointer cb_target)
{
	GtkMenuItem* _tmp0_;
	GtkMenuItem* _tmp1_;
	PopupMenuBuilder* _tmp2_;
	PopupMenuBuilder* _tmp3_;
	PopupMenuBuilder* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkMenuItem*) gtk_menu_item_new_with_mnemonic (_ ("Properties"));
	g_object_ref_sink (_tmp0_);
	_tmp1_ = _tmp0_;
	_tmp2_ = popup_menu_builder_add_item (self, _tmp1_, cb, cb_target);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (_tmp1_);
	result = _tmp3_;
	return result;
}

PopupMenuBuilder*
popup_menu_builder_add_eject_drive (PopupMenuBuilder* self,
                                    PopupMenuBuilderMenuitemCallback cb,
                                    gpointer cb_target)
{
	GtkMenuItem* _tmp0_;
	GtkMenuItem* _tmp1_;
	PopupMenuBuilder* _tmp2_;
	PopupMenuBuilder* _tmp3_;
	PopupMenuBuilder* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkMenuItem*) gtk_menu_item_new_with_mnemonic (_ ("Eject Media"));
	g_object_ref_sink (_tmp0_);
	_tmp1_ = _tmp0_;
	_tmp2_ = popup_menu_builder_add_item (self, _tmp1_, cb, cb_target);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (_tmp1_);
	result = _tmp3_;
	return result;
}

PopupMenuBuilder*
popup_menu_builder_add_safely_remove (PopupMenuBuilder* self,
                                      PopupMenuBuilderMenuitemCallback cb,
                                      gpointer cb_target)
{
	GtkMenuItem* _tmp0_;
	GtkMenuItem* _tmp1_;
	PopupMenuBuilder* _tmp2_;
	PopupMenuBuilder* _tmp3_;
	PopupMenuBuilder* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkMenuItem*) gtk_menu_item_new_with_mnemonic (_ ("Safely Remove"));
	g_object_ref_sink (_tmp0_);
	_tmp1_ = _tmp0_;
	_tmp2_ = popup_menu_builder_add_item (self, _tmp1_, cb, cb_target);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (_tmp1_);
	result = _tmp3_;
	return result;
}

PopupMenuBuilder*
popup_menu_builder_add_bookmark (PopupMenuBuilder* self,
                                 PopupMenuBuilderMenuitemCallback cb,
                                 gpointer cb_target)
{
	GtkMenuItem* _tmp0_;
	GtkMenuItem* _tmp1_;
	PopupMenuBuilder* _tmp2_;
	PopupMenuBuilder* _tmp3_;
	PopupMenuBuilder* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkMenuItem*) gtk_menu_item_new_with_mnemonic (_ ("Add to Bookmarks"));
	g_object_ref_sink (_tmp0_);
	_tmp1_ = _tmp0_;
	_tmp2_ = popup_menu_builder_add_item (self, _tmp1_, cb, cb_target);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (_tmp1_);
	result = _tmp3_;
	return result;
}

static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}

static inline void
_g_list_free__g_object_unref0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_object_unref0_);
}

PopupMenuBuilder*
popup_menu_builder_add_empty_all_trash (PopupMenuBuilder* self,
                                        PopupMenuBuilderMenuitemCallback cb,
                                        gpointer cb_target)
{
	GVolumeMonitor* volume_monitor = NULL;
	GVolumeMonitor* _tmp0_;
	gint mounts_with_trash = 0;
	GVolumeMonitor* _tmp1_;
	GList* _tmp2_;
	const gchar* _tmp6_ = NULL;
	gchar* text = NULL;
	gchar* _tmp7_;
	GtkMenuItem* menu_item = NULL;
	const gchar* _tmp8_;
	GtkMenuItem* _tmp9_;
	FilesTrashMonitor* _tmp10_;
	gboolean _tmp11_;
	gboolean _tmp12_;
	GtkMenuItem* _tmp16_;
	PopupMenuBuilder* _tmp17_;
	PopupMenuBuilder* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_volume_monitor_get ();
	volume_monitor = _tmp0_;
	mounts_with_trash = 0;
	_tmp1_ = volume_monitor;
	_tmp2_ = g_volume_monitor_get_mounts (_tmp1_);
	{
		GList* mount_collection = NULL;
		GList* mount_it = NULL;
		mount_collection = _tmp2_;
		for (mount_it = mount_collection; mount_it != NULL; mount_it = mount_it->next) {
			GMount* _tmp3_;
			GMount* mount = NULL;
			_tmp3_ = _g_object_ref0 ((GMount*) mount_it->data);
			mount = _tmp3_;
			{
				GMount* _tmp4_;
				_tmp4_ = mount;
				if (marlin_file_operations_mount_has_trash (_tmp4_)) {
					gint _tmp5_;
					_tmp5_ = mounts_with_trash;
					mounts_with_trash = _tmp5_ + 1;
				}
				_g_object_unref0 (mount);
			}
		}
		(mount_collection == NULL) ? NULL : (mount_collection = (_g_list_free__g_object_unref0_ (mount_collection), NULL));
	}
	if (mounts_with_trash > 0) {
		_tmp6_ = _ ("Permanently Delete All Trash");
	} else {
		_tmp6_ = _ ("Permanently Delete Trash");
	}
	_tmp7_ = g_strdup (_tmp6_);
	text = _tmp7_;
	_tmp8_ = text;
	_tmp9_ = (GtkMenuItem*) gtk_menu_item_new_with_mnemonic (_tmp8_);
	g_object_ref_sink (_tmp9_);
	menu_item = _tmp9_;
	_tmp10_ = files_trash_monitor_get_default ();
	_tmp11_ = files_trash_monitor_get_is_empty (_tmp10_);
	_tmp12_ = _tmp11_;
	if (_tmp12_) {
		GtkMenuItem* _tmp13_;
		_tmp13_ = menu_item;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp13_, FALSE);
	} else {
		GtkMenuItem* _tmp14_;
		GtkStyleContext* _tmp15_;
		_tmp14_ = menu_item;
		_tmp15_ = gtk_widget_get_style_context ((GtkWidget*) _tmp14_);
		gtk_style_context_add_class (_tmp15_, GTK_STYLE_CLASS_DESTRUCTIVE_ACTION);
	}
	_tmp16_ = menu_item;
	_tmp17_ = popup_menu_builder_add_item (self, _tmp16_, cb, cb_target);
	result = _tmp17_;
	_g_object_unref0 (menu_item);
	_g_free0 (text);
	_g_object_unref0 (volume_monitor);
	return result;
}

PopupMenuBuilder*
popup_menu_builder_add_empty_mount_trash (PopupMenuBuilder* self,
                                          PopupMenuBuilderMenuitemCallback cb,
                                          gpointer cb_target)
{
	GtkMenuItem* menu_item = NULL;
	GtkMenuItem* _tmp0_;
	GtkStyleContext* _tmp1_;
	PopupMenuBuilder* _tmp2_;
	PopupMenuBuilder* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkMenuItem*) gtk_menu_item_new_with_mnemonic (_ ("Permanently Delete Trash on this Mount"));
	g_object_ref_sink (_tmp0_);
	menu_item = _tmp0_;
	_tmp1_ = gtk_widget_get_style_context ((GtkWidget*) menu_item);
	gtk_style_context_add_class (_tmp1_, GTK_STYLE_CLASS_DESTRUCTIVE_ACTION);
	_tmp2_ = popup_menu_builder_add_item (self, menu_item, cb, cb_target);
	result = _tmp2_;
	_g_object_unref0 (menu_item);
	return result;
}

PopupMenuBuilder*
popup_menu_builder_add_separator (PopupMenuBuilder* self)
{
	GtkSeparatorMenuItem* _tmp0_;
	GtkSeparatorMenuItem* _tmp1_;
	PopupMenuBuilder* _tmp2_;
	PopupMenuBuilder* _tmp3_;
	PopupMenuBuilder* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	g_object_ref_sink (_tmp0_);
	_tmp1_ = _tmp0_;
	_tmp2_ = popup_menu_builder_add_item (self, (GtkMenuItem*) _tmp1_, NULL, NULL);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (_tmp1_);
	result = _tmp3_;
	return result;
}

static Block16Data*
block16_data_ref (Block16Data* _data16_)
{
	g_atomic_int_inc (&_data16_->_ref_count_);
	return _data16_;
}

static void
block16_data_unref (void * _userdata_)
{
	Block16Data* _data16_;
	_data16_ = (Block16Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data16_->_ref_count_)) {
		PopupMenuBuilder* self;
		self = _data16_->self;
		_g_object_unref0 (self);
		g_slice_free (Block16Data, _data16_);
	}
}

static void
___lambda56_ (Block16Data* _data16_,
              GtkMenuItem* menu_item)
{
	PopupMenuBuilder* self;
	self = _data16_->self;
	g_return_if_fail (menu_item != NULL);
	_data16_->cb (menu_item, _data16_->cb_target);
}

static void
____lambda56__gtk_menu_item_activate (GtkMenuItem* _sender,
                                      gpointer self)
{
	___lambda56_ (self, _sender);
}

static void
_vala_array_add3 (GtkMenuItem** * array,
                  gint* length,
                  gint* size,
                  GtkMenuItem* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkMenuItem*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

PopupMenuBuilder*
popup_menu_builder_add_item (PopupMenuBuilder* self,
                             GtkMenuItem* menu_item,
                             PopupMenuBuilderMenuitemCallback cb,
                             gpointer cb_target)
{
	Block16Data* _data16_;
	GtkMenuItem* _tmp0_;
	PopupMenuBuilder* _tmp1_;
	PopupMenuBuilder* result;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (menu_item != NULL, NULL);
	_data16_ = g_slice_new0 (Block16Data);
	_data16_->_ref_count_ = 1;
	_data16_->self = g_object_ref (self);
	_data16_->cb = cb;
	_data16_->cb_target = cb_target;
	if (_data16_->cb != NULL) {
		g_signal_connect_data (menu_item, "activate", (GCallback) ____lambda56__gtk_menu_item_activate, block16_data_ref (_data16_), (GClosureNotify) block16_data_unref, 0);
	}
	gtk_widget_show ((GtkWidget*) menu_item);
	_tmp0_ = _g_object_ref0 (menu_item);
	_vala_array_add3 (&self->priv->menu_items, &self->priv->menu_items_length1, &self->priv->_menu_items_size_, _tmp0_);
	_tmp1_ = _g_object_ref0 (self);
	result = _tmp1_;
	block16_data_unref (_data16_);
	_data16_ = NULL;
	return result;
}

PopupMenuBuilder*
popup_menu_builder_construct (GType object_type)
{
	PopupMenuBuilder * self = NULL;
	self = (PopupMenuBuilder*) g_object_new (object_type, NULL);
	return self;
}

PopupMenuBuilder*
popup_menu_builder_new (void)
{
	return popup_menu_builder_construct (TYPE_POPUP_MENU_BUILDER);
}

guint
popup_menu_builder_get_n_items (PopupMenuBuilder* self)
{
	guint result;
	GtkMenuItem** _tmp0_;
	gint _tmp0__length1;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->menu_items;
	_tmp0__length1 = self->priv->menu_items_length1;
	result = (guint) _tmp0__length1;
	return result;
}

static void
popup_menu_builder_class_init (PopupMenuBuilderClass * klass,
                               gpointer klass_data)
{
	popup_menu_builder_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &PopupMenuBuilder_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_popup_menu_builder_get_property;
	G_OBJECT_CLASS (klass)->finalize = popup_menu_builder_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), POPUP_MENU_BUILDER_N_ITEMS_PROPERTY, popup_menu_builder_properties[POPUP_MENU_BUILDER_N_ITEMS_PROPERTY] = g_param_spec_uint ("n-items", "n-items", "n-items", 0, G_MAXUINT, 0U, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}

static void
popup_menu_builder_instance_init (PopupMenuBuilder * self,
                                  gpointer klass)
{
	GtkMenuItem** _tmp0_;
	self->priv = popup_menu_builder_get_instance_private (self);
	_tmp0_ = g_new0 (GtkMenuItem*, 0 + 1);
	self->priv->menu_items = _tmp0_;
	self->priv->menu_items_length1 = 0;
	self->priv->_menu_items_size_ = self->priv->menu_items_length1;
}

static void
popup_menu_builder_finalize (GObject * obj)
{
	PopupMenuBuilder * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_POPUP_MENU_BUILDER, PopupMenuBuilder);
	self->priv->menu_items = (_vala_array_free (self->priv->menu_items, self->priv->menu_items_length1, (GDestroyNotify) g_object_unref), NULL);
	G_OBJECT_CLASS (popup_menu_builder_parent_class)->finalize (obj);
}

/***
    Copyright (c) 2018 elementary LLC <https://elementary.io>

    Pantheon Files is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License as
    published by the Free Software Foundation; either version 2 of the
    License, or (at your option) any later version.

    Pantheon Files is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program.  If not, see <http://www.gnu.org/licenses/>.

    Author(s):  Fernando da Silva Sousa <wild.nando@gmail.com>
***/
static GType
popup_menu_builder_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PopupMenuBuilderClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) popup_menu_builder_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PopupMenuBuilder), 0, (GInstanceInitFunc) popup_menu_builder_instance_init, NULL };
	GType popup_menu_builder_type_id;
	popup_menu_builder_type_id = g_type_register_static (G_TYPE_OBJECT, "PopupMenuBuilder", &g_define_type_info, 0);
	PopupMenuBuilder_private_offset = g_type_add_instance_private (popup_menu_builder_type_id, sizeof (PopupMenuBuilderPrivate));
	return popup_menu_builder_type_id;
}

GType
popup_menu_builder_get_type (void)
{
	static volatile gsize popup_menu_builder_type_id__once = 0;
	if (g_once_init_enter (&popup_menu_builder_type_id__once)) {
		GType popup_menu_builder_type_id;
		popup_menu_builder_type_id = popup_menu_builder_get_type_once ();
		g_once_init_leave (&popup_menu_builder_type_id__once, popup_menu_builder_type_id);
	}
	return popup_menu_builder_type_id__once;
}

static void
_vala_popup_menu_builder_get_property (GObject * object,
                                       guint property_id,
                                       GValue * value,
                                       GParamSpec * pspec)
{
	PopupMenuBuilder * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_POPUP_MENU_BUILDER, PopupMenuBuilder);
	switch (property_id) {
		case POPUP_MENU_BUILDER_N_ITEMS_PROPERTY:
		g_value_set_uint (value, popup_menu_builder_get_n_items (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

