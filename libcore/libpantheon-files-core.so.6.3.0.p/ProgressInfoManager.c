/* ProgressInfoManager.c generated by valac 0.56.3, the Vala compiler
 * generated from ProgressInfoManager.vala, do not modify */

/* Copyright (c) 2018 elementary LLC (https://elementary.io)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, Inc.,; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */
/* Maintains a list of active infos and signals when a new one added */
/* Used by the ProgressUIHandler to update the progress window and launcher */

#include "pantheon-files-core.h"
#include <gee.h>
#include <glib-object.h>
#include <glib.h>

enum  {
	PF_PROGRESS_INFO_MANAGER_0_PROPERTY,
	PF_PROGRESS_INFO_MANAGER_NUM_PROPERTIES
};
static GParamSpec* pf_progress_info_manager_properties[PF_PROGRESS_INFO_MANAGER_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
enum  {
	PF_PROGRESS_INFO_MANAGER_NEW_PROGRESS_INFO_SIGNAL,
	PF_PROGRESS_INFO_MANAGER_NUM_SIGNALS
};
static guint pf_progress_info_manager_signals[PF_PROGRESS_INFO_MANAGER_NUM_SIGNALS] = {0};

struct _PFProgressInfoManagerPrivate {
	GeeLinkedList* progress_infos;
};

static gint PFProgressInfoManager_private_offset;
static gpointer pf_progress_info_manager_parent_class = NULL;
static PFProgressInfoManager* pf_progress_info_manager_progress_info_manager;
static PFProgressInfoManager* pf_progress_info_manager_progress_info_manager = NULL;

static GObject * pf_progress_info_manager_constructor (GType type,
                                                guint n_construct_properties,
                                                GObjectConstructParam * construct_properties);
static void pf_progress_info_manager_finalize (GObject * obj);
static GType pf_progress_info_manager_get_type_once (void);

static inline gpointer
pf_progress_info_manager_get_instance_private (PFProgressInfoManager* self)
{
	return G_STRUCT_MEMBER_P (self, PFProgressInfoManager_private_offset);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

PFProgressInfoManager*
pf_progress_info_manager_get_instance (void)
{
	PFProgressInfoManager* _tmp0_;
	PFProgressInfoManager* _tmp2_;
	PFProgressInfoManager* _tmp3_;
	PFProgressInfoManager* result;
	_tmp0_ = pf_progress_info_manager_progress_info_manager;
	if (_tmp0_ == NULL) {
		PFProgressInfoManager* _tmp1_;
		_tmp1_ = pf_progress_info_manager_new ();
		_g_object_unref0 (pf_progress_info_manager_progress_info_manager);
		pf_progress_info_manager_progress_info_manager = _tmp1_;
	}
	_tmp2_ = pf_progress_info_manager_progress_info_manager;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	result = _tmp3_;
	return result;
}

void
pf_progress_info_manager_add_new_info (PFProgressInfoManager* self,
                                       PFProgressInfo* info)
{
	GeeLinkedList* _tmp0_;
	GeeLinkedList* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (info != NULL);
	_tmp0_ = self->priv->progress_infos;
	if (gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp0_, info)) {
		g_warning ("ProgressInfoManager.vala:41: Adding two times the same progress info o" \
"bject to the manager");
		return;
	}
	_tmp1_ = self->priv->progress_infos;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp1_, info);
	g_signal_emit (self, pf_progress_info_manager_signals[PF_PROGRESS_INFO_MANAGER_NEW_PROGRESS_INFO_SIGNAL], 0, info);
}

void
pf_progress_info_manager_remove_finished_info (PFProgressInfoManager* self,
                                               PFProgressInfo* info)
{
	GeeLinkedList* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (info != NULL);
	_tmp0_ = self->priv->progress_infos;
	gee_abstract_collection_remove ((GeeAbstractCollection*) _tmp0_, info);
}

GeeLinkedList*
pf_progress_info_manager_get_all_infos (PFProgressInfoManager* self)
{
	GeeLinkedList* _tmp0_;
	GeeLinkedList* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->progress_infos;
	result = _tmp0_;
	return result;
}

PFProgressInfoManager*
pf_progress_info_manager_construct (GType object_type)
{
	PFProgressInfoManager * self = NULL;
	self = (PFProgressInfoManager*) g_object_new (object_type, NULL);
	return self;
}

PFProgressInfoManager*
pf_progress_info_manager_new (void)
{
	return pf_progress_info_manager_construct (PF_PROGRESS_TYPE_INFO_MANAGER);
}

static GObject *
pf_progress_info_manager_constructor (GType type,
                                      guint n_construct_properties,
                                      GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	PFProgressInfoManager * self;
	GeeLinkedList* _tmp0_;
	parent_class = G_OBJECT_CLASS (pf_progress_info_manager_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PF_PROGRESS_TYPE_INFO_MANAGER, PFProgressInfoManager);
	_tmp0_ = gee_linked_list_new (PF_PROGRESS_TYPE_INFO, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->progress_infos);
	self->priv->progress_infos = _tmp0_;
	return obj;
}

static void
pf_progress_info_manager_class_init (PFProgressInfoManagerClass * klass,
                                     gpointer klass_data)
{
	pf_progress_info_manager_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &PFProgressInfoManager_private_offset);
	G_OBJECT_CLASS (klass)->constructor = pf_progress_info_manager_constructor;
	G_OBJECT_CLASS (klass)->finalize = pf_progress_info_manager_finalize;
	pf_progress_info_manager_signals[PF_PROGRESS_INFO_MANAGER_NEW_PROGRESS_INFO_SIGNAL] = g_signal_new ("new-progress-info", PF_PROGRESS_TYPE_INFO_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, PF_PROGRESS_TYPE_INFO);
}

static void
pf_progress_info_manager_instance_init (PFProgressInfoManager * self,
                                        gpointer klass)
{
	self->priv = pf_progress_info_manager_get_instance_private (self);
}

static void
pf_progress_info_manager_finalize (GObject * obj)
{
	PFProgressInfoManager * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PF_PROGRESS_TYPE_INFO_MANAGER, PFProgressInfoManager);
	_g_object_unref0 (self->priv->progress_infos);
	G_OBJECT_CLASS (pf_progress_info_manager_parent_class)->finalize (obj);
}

static GType
pf_progress_info_manager_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PFProgressInfoManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) pf_progress_info_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PFProgressInfoManager), 0, (GInstanceInitFunc) pf_progress_info_manager_instance_init, NULL };
	GType pf_progress_info_manager_type_id;
	pf_progress_info_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "PFProgressInfoManager", &g_define_type_info, 0);
	PFProgressInfoManager_private_offset = g_type_add_instance_private (pf_progress_info_manager_type_id, sizeof (PFProgressInfoManagerPrivate));
	return pf_progress_info_manager_type_id;
}

GType
pf_progress_info_manager_get_type (void)
{
	static volatile gsize pf_progress_info_manager_type_id__once = 0;
	if (g_once_init_enter (&pf_progress_info_manager_type_id__once)) {
		GType pf_progress_info_manager_type_id;
		pf_progress_info_manager_type_id = pf_progress_info_manager_get_type_once ();
		g_once_init_leave (&pf_progress_info_manager_type_id__once, pf_progress_info_manager_type_id);
	}
	return pf_progress_info_manager_type_id__once;
}

