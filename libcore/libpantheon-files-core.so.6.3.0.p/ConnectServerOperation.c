/* ConnectServerOperation.c generated by valac 0.56.3, the Vala compiler
 * generated from ConnectServerOperation.vala, do not modify */

#include "pantheon-files-core.h"
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>

enum  {
	FILES_CONNECT_SERVER_OPERATION_0_PROPERTY,
	FILES_CONNECT_SERVER_OPERATION_NUM_PROPERTIES
};
static GParamSpec* files_connect_server_operation_properties[FILES_CONNECT_SERVER_OPERATION_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _FilesConnectServerOperationPrivate {
	PFConnectServerDialog* dialog;
};

static gint FilesConnectServerOperation_private_offset;
static gpointer files_connect_server_operation_parent_class = NULL;

static void __lambda27_ (FilesConnectServerOperation* self,
                  GMountOperationResult _result_);
static void ___lambda27__g_mount_operation_reply (GMountOperation* _sender,
                                           GMountOperationResult _result_,
                                           gpointer self);
static void files_connect_server_operation_real_ask_password (GMountOperation* base,
                                                       const gchar* message,
                                                       const gchar* default_user,
                                                       const gchar* default_domain,
                                                       GAskPasswordFlags flags);
static void __lambda28_ (FilesConnectServerOperation* self,
                  GObject* source,
                  GAsyncResult* _result_);
static void ___lambda28__gasync_ready_callback (GObject* source_object,
                                         GAsyncResult* res,
                                         gpointer self);
static void files_connect_server_operation_finalize (GObject * obj);
static GType files_connect_server_operation_get_type_once (void);

static inline gpointer
files_connect_server_operation_get_instance_private (FilesConnectServerOperation* self)
{
	return G_STRUCT_MEMBER_P (self, FilesConnectServerOperation_private_offset);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static void
__lambda27_ (FilesConnectServerOperation* self,
             GMountOperationResult _result_)
{
	PFConnectServerDialog* _tmp0_;
	_tmp0_ = self->priv->dialog;
	gtk_window_set_modal ((GtkWindow*) _tmp0_, TRUE);
}

static void
___lambda27__g_mount_operation_reply (GMountOperation* _sender,
                                      GMountOperationResult _result_,
                                      gpointer self)
{
	__lambda27_ ((FilesConnectServerOperation*) self, _result_);
}

FilesConnectServerOperation*
files_connect_server_operation_construct (GType object_type,
                                          PFConnectServerDialog* dialog)
{
	FilesConnectServerOperation * self = NULL;
	PFConnectServerDialog* _tmp0_;
	PFConnectServerDialog* _tmp1_;
	g_return_val_if_fail (dialog != NULL, NULL);
	self = (FilesConnectServerOperation*) g_object_new (object_type, NULL);
	_tmp0_ = _g_object_ref0 (dialog);
	_g_object_unref0 (self->priv->dialog);
	self->priv->dialog = _tmp0_;
	gtk_mount_operation_set_parent ((GtkMountOperation*) self, (GtkWindow*) dialog);
	_tmp1_ = self->priv->dialog;
	gtk_window_set_modal ((GtkWindow*) _tmp1_, FALSE);
	g_signal_connect_object ((GMountOperation*) self, "reply", (GCallback) ___lambda27__g_mount_operation_reply, self, 0);
	return self;
}

FilesConnectServerOperation*
files_connect_server_operation_new (PFConnectServerDialog* dialog)
{
	return files_connect_server_operation_construct (FILES_CONNECT_SERVER_TYPE_OPERATION, dialog);
}

static void
__lambda28_ (FilesConnectServerOperation* self,
             GObject* source,
             GAsyncResult* _result_)
{
	gboolean res = FALSE;
	PFConnectServerDialog* _tmp0_;
	g_return_if_fail (_result_ != NULL);
	_tmp0_ = self->priv->dialog;
	res = pf_connect_server_dialog_fill_details_finish (_tmp0_, _result_);
	if (res) {
		g_mount_operation_reply ((GMountOperation*) self, G_MOUNT_OPERATION_HANDLED);
	} else {
		g_mount_operation_reply ((GMountOperation*) self, G_MOUNT_OPERATION_ABORTED);
	}
}

static void
___lambda28__gasync_ready_callback (GObject* source_object,
                                    GAsyncResult* res,
                                    gpointer self)
{
	__lambda28_ ((FilesConnectServerOperation*) self, source_object, res);
	g_object_unref (self);
}

static void
files_connect_server_operation_real_ask_password (GMountOperation* base,
                                                  const gchar* message,
                                                  const gchar* default_user,
                                                  const gchar* default_domain,
                                                  GAskPasswordFlags flags)
{
	FilesConnectServerOperation * self;
	PFConnectServerDialog* _tmp0_;
	self = (FilesConnectServerOperation*) base;
	g_return_if_fail (message != NULL);
	g_return_if_fail (default_user != NULL);
	g_return_if_fail (default_domain != NULL);
	_tmp0_ = self->priv->dialog;
	pf_connect_server_dialog_fill_details_async (_tmp0_, (GMountOperation*) self, default_user, default_domain, flags, ___lambda28__gasync_ready_callback, g_object_ref (self));
}

static void
files_connect_server_operation_class_init (FilesConnectServerOperationClass * klass,
                                           gpointer klass_data)
{
	files_connect_server_operation_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &FilesConnectServerOperation_private_offset);
	((GMountOperationClass *) klass)->ask_password = (void (*) (GMountOperation*, const gchar*, const gchar*, const gchar*, GAskPasswordFlags)) files_connect_server_operation_real_ask_password;
	G_OBJECT_CLASS (klass)->finalize = files_connect_server_operation_finalize;
}

static void
files_connect_server_operation_instance_init (FilesConnectServerOperation * self,
                                              gpointer klass)
{
	self->priv = files_connect_server_operation_get_instance_private (self);
}

static void
files_connect_server_operation_finalize (GObject * obj)
{
	FilesConnectServerOperation * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_CONNECT_SERVER_TYPE_OPERATION, FilesConnectServerOperation);
	_g_object_unref0 (self->priv->dialog);
	G_OBJECT_CLASS (files_connect_server_operation_parent_class)->finalize (obj);
}

/***
    Copyright (c) 2010 Cosimo Cecchi <cosimoc@gnome.org>
    Copyright (c) 2015-2018 elementary LLC <https://elementary.io>

    This program is free software: you can redistribute it and/or modify it
    under the terms of the GNU Lesser General Public License version 3, as published
    by the Free Software Foundation.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranties of
    MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
    PURPOSE. See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program. If not, see <http://www.gnu.org/licenses/>.

    Authors: Cosimo Cecchi <cosimoc@gnome.org>
             Juli√°n Unrrein <junrrein@gmail.com>
***/
static GType
files_connect_server_operation_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FilesConnectServerOperationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) files_connect_server_operation_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FilesConnectServerOperation), 0, (GInstanceInitFunc) files_connect_server_operation_instance_init, NULL };
	GType files_connect_server_operation_type_id;
	files_connect_server_operation_type_id = g_type_register_static (gtk_mount_operation_get_type (), "FilesConnectServerOperation", &g_define_type_info, 0);
	FilesConnectServerOperation_private_offset = g_type_add_instance_private (files_connect_server_operation_type_id, sizeof (FilesConnectServerOperationPrivate));
	return files_connect_server_operation_type_id;
}

GType
files_connect_server_operation_get_type (void)
{
	static volatile gsize files_connect_server_operation_type_id__once = 0;
	if (g_once_init_enter (&files_connect_server_operation_type_id__once)) {
		GType files_connect_server_operation_type_id;
		files_connect_server_operation_type_id = files_connect_server_operation_get_type_once ();
		g_once_init_leave (&files_connect_server_operation_type_id__once, files_connect_server_operation_type_id);
	}
	return files_connect_server_operation_type_id__once;
}

