/* DndHandler.c generated by valac 0.56.3, the Vala compiler
 * generated from DndHandler.vala, do not modify */

#include "pantheon-files-core.h"
#include <gdk/gdk.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <glib.h>
#include <gio/gio.h>
#include "marlin-file-operations.h"
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <granite.h>

enum  {
	FILES_DND_HANDLER_0_PROPERTY,
	FILES_DND_HANDLER_NUM_PROPERTIES
};
static GParamSpec* files_dnd_handler_properties[FILES_DND_HANDLER_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Block7Data Block7Data;
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
typedef struct _Block8Data Block8Data;
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
typedef struct _Block9Data Block9Data;
typedef struct _Block10Data Block10Data;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _FilesDndHandlerPrivate {
	GdkDragAction chosen;
};

struct _Block7Data {
	int _ref_count_;
	FilesDndHandler* self;
	GMainLoop* loop;
	GtkApplicationWindow* win;
};

struct _Block8Data {
	int _ref_count_;
	FilesDndHandler* self;
	GdkDragAction* action;
};

struct _Block9Data {
	int _ref_count_;
	GString* sb;
	gboolean sanitize_path;
};

struct _Block10Data {
	int _ref_count_;
	Block9Data * _data9_;
	gboolean in_recent;
};

static gint FilesDndHandler_private_offset;
static gpointer files_dnd_handler_parent_class = NULL;

static Block7Data* block7_data_ref (Block7Data* _data7_);
static void block7_data_unref (void * _userdata_);
static void files_dnd_handler_add_action (FilesDndHandler* self,
                                   GtkApplicationWindow* win);
static GtkMenu* files_dnd_handler_build_menu (FilesDndHandler* self,
                                       GdkDragAction possible_actions);
static void __lambda31_ (Block7Data* _data7_);
static void files_dnd_handler_remove_action (FilesDndHandler* self,
                                      GtkApplicationWindow* win);
static void ___lambda31__gtk_menu_shell_deactivate (GtkMenuShell* _sender,
                                             gpointer self);
static GdkDragAction* _gdk_drag_action_dup (GdkDragAction* self);
static void _files_dnd_handler_on_choice_g_simple_action_activate (GSimpleAction* _sender,
                                                            GVariant* parameter,
                                                            gpointer self);
static void files_dnd_handler_build_and_append_menu_item (FilesDndHandler* self,
                                                   GtkMenu* menu,
                                                   const gchar* label,
                                                   GdkDragAction* action,
                                                   GdkDragAction possible_actions);
static Block8Data* block8_data_ref (Block8Data* _data8_);
static void block8_data_unref (void * _userdata_);
static void ___lambda30_ (Block8Data* _data8_);
static void ____lambda30__gtk_menu_item_activate (GtkMenuItem* _sender,
                                           gpointer self);
static void files_dnd_handler_set_stringbuilder_from_file_list (GString* sb,
                                                         GList* file_list,
                                                         const gchar* prefix,
                                                         gboolean sanitize_path);
static Block9Data* block9_data_ref (Block9Data* _data9_);
static void block9_data_unref (void * _userdata_);
static Block10Data* block10_data_ref (Block10Data* _data10_);
static void block10_data_unref (void * _userdata_);
static void ___lambda32_ (Block10Data* _data10_,
                   FilesFile* file);
static void ____lambda32__gfunc (gconstpointer data,
                          gpointer self);
static void files_dnd_handler_finalize (GObject * obj);
static GType files_dnd_handler_get_type_once (void);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);
static gssize _vala_array_length (gpointer array);

static inline gpointer
files_dnd_handler_get_instance_private (FilesDndHandler* self)
{
	return G_STRUCT_MEMBER_P (self, FilesDndHandler_private_offset);
}

FilesDndHandler*
files_dnd_handler_construct (GType object_type)
{
	FilesDndHandler * self = NULL;
	self = (FilesDndHandler*) g_object_new (object_type, NULL);
	return self;
}

FilesDndHandler*
files_dnd_handler_new (void)
{
	return files_dnd_handler_construct (FILES_TYPE_DND_HANDLER);
}

gboolean
files_dnd_handler_dnd_perform (FilesDndHandler* self,
                               GtkWidget* widget,
                               FilesFile* drop_target,
                               GList* drop_file_list,
                               GdkDragAction action)
{
	GError* _inner_error0_ = NULL;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (widget != NULL, FALSE);
	g_return_val_if_fail (drop_target != NULL, FALSE);
	_vala_return_val_if_fail ((drop_target != NULL) && (drop_file_list != NULL), "drop_target != null && drop_file_list != null", FALSE);
	if (files_file_is_folder (drop_target)) {
		GFile* _tmp0_;
		_tmp0_ = files_file_get_target_location (drop_target);
		marlin_file_operations_copy_move_link (drop_file_list, _tmp0_, action, widget, NULL, NULL, NULL);
		result = TRUE;
		return result;
	} else {
		if (files_file_is_executable (drop_target)) {
			gboolean _tmp9_ = FALSE;
			{
				files_file_execute (drop_target, drop_file_list, &_inner_error0_);
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					goto __catch0_g_error;
				}
				result = TRUE;
				return result;
			}
			goto __finally0;
			__catch0_g_error:
			{
				GError* e = NULL;
				const gchar* target_name = NULL;
				const gchar* _tmp1_;
				const gchar* _tmp2_;
				gchar* _tmp3_;
				gchar* _tmp4_;
				GError* _tmp5_;
				const gchar* _tmp6_;
				GraniteMessageDialog* _tmp7_;
				GraniteMessageDialog* _tmp8_;
				e = _inner_error0_;
				_inner_error0_ = NULL;
				_tmp1_ = files_file_get_display_name (drop_target);
				target_name = _tmp1_;
				_tmp2_ = target_name;
				_tmp3_ = g_strdup_printf (_ ("Failed to execute \"%s\""), _tmp2_);
				_tmp4_ = _tmp3_;
				_tmp5_ = e;
				_tmp6_ = _tmp5_->message;
				_tmp7_ = pf_dialogs_show_error_dialog (_tmp4_, _tmp6_, NULL);
				_tmp8_ = _tmp7_;
				_g_object_unref0 (_tmp8_);
				_g_free0 (_tmp4_);
				result = FALSE;
				_g_error_free0 (e);
				return result;
			}
			__finally0:
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return _tmp9_;
		}
	}
	result = FALSE;
	return result;
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static Block7Data*
block7_data_ref (Block7Data* _data7_)
{
	g_atomic_int_inc (&_data7_->_ref_count_);
	return _data7_;
}

static void
block7_data_unref (void * _userdata_)
{
	Block7Data* _data7_;
	_data7_ = (Block7Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data7_->_ref_count_)) {
		FilesDndHandler* self;
		self = _data7_->self;
		_g_main_loop_unref0 (_data7_->loop);
		_g_object_unref0 (_data7_->win);
		_g_object_unref0 (self);
		g_slice_free (Block7Data, _data7_);
	}
}

static void
__lambda31_ (Block7Data* _data7_)
{
	FilesDndHandler* self;
	self = _data7_->self;
	if (g_main_loop_is_running (_data7_->loop)) {
		g_main_loop_quit (_data7_->loop);
	}
	files_dnd_handler_remove_action (self, G_TYPE_CHECK_INSTANCE_CAST (_data7_->win, gtk_application_window_get_type (), GtkApplicationWindow));
}

static void
___lambda31__gtk_menu_shell_deactivate (GtkMenuShell* _sender,
                                        gpointer self)
{
	__lambda31_ (self);
}

static GdkDragAction*
_gdk_drag_action_dup (GdkDragAction* self)
{
	GdkDragAction* dup;
	dup = g_new0 (GdkDragAction, 1);
	memcpy (dup, self, sizeof (GdkDragAction));
	return dup;
}

static gpointer
__gdk_drag_action_dup0 (gpointer self)
{
	return self ? _gdk_drag_action_dup (self) : NULL;
}

GdkDragAction*
files_dnd_handler_drag_drop_action_ask (FilesDndHandler* self,
                                        GtkWidget* dest_widget,
                                        GtkApplicationWindow* win,
                                        GdkDragAction possible_actions)
{
	Block7Data* _data7_;
	GtkApplicationWindow* _tmp0_;
	GtkMenu* ask_menu = NULL;
	GtkMenu* _tmp1_;
	GdkScreen* _tmp2_;
	GMainLoop* _tmp3_;
	GdkDragAction* _tmp4_;
	GdkDragAction* result;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (dest_widget != NULL, NULL);
	g_return_val_if_fail (win != NULL, NULL);
	_data7_ = g_slice_new0 (Block7Data);
	_data7_->_ref_count_ = 1;
	_data7_->self = g_object_ref (self);
	_tmp0_ = _g_object_ref0 (win);
	_g_object_unref0 (_data7_->win);
	_data7_->win = _tmp0_;
	self->priv->chosen = GDK_ACTION_DEFAULT;
	files_dnd_handler_add_action (self, _data7_->win);
	_tmp1_ = files_dnd_handler_build_menu (self, possible_actions);
	ask_menu = _tmp1_;
	_tmp2_ = gtk_widget_get_screen (dest_widget);
	gtk_menu_set_screen (ask_menu, _tmp2_);
	gtk_widget_show_all ((GtkWidget*) ask_menu);
	_tmp3_ = g_main_loop_new (NULL, FALSE);
	_data7_->loop = _tmp3_;
	g_signal_connect_data ((GtkMenuShell*) ask_menu, "deactivate", (GCallback) ___lambda31__gtk_menu_shell_deactivate, block7_data_ref (_data7_), (GClosureNotify) block7_data_unref, 0);
	gtk_menu_popup_at_pointer (ask_menu, NULL);
	g_main_loop_run (_data7_->loop);
	gtk_grab_remove ((GtkWidget*) ask_menu);
	_tmp4_ = __gdk_drag_action_dup0 (&self->priv->chosen);
	result = _tmp4_;
	_g_object_unref0 (ask_menu);
	block7_data_unref (_data7_);
	_data7_ = NULL;
	return result;
}

static void
_files_dnd_handler_on_choice_g_simple_action_activate (GSimpleAction* _sender,
                                                       GVariant* parameter,
                                                       gpointer self)
{
	files_dnd_handler_on_choice ((FilesDndHandler*) self, parameter);
}

static void
files_dnd_handler_add_action (FilesDndHandler* self,
                              GtkApplicationWindow* win)
{
	GSimpleAction* action = NULL;
	const GVariantType* _tmp0_;
	GSimpleAction* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (win != NULL);
	_tmp0_ = G_VARIANT_TYPE_STRING;
	_tmp1_ = g_simple_action_new ("choice", _tmp0_);
	action = _tmp1_;
	g_signal_connect_object (action, "activate", (GCallback) _files_dnd_handler_on_choice_g_simple_action_activate, self, 0);
	g_action_map_add_action ((GActionMap*) win, (GAction*) action);
	_g_object_unref0 (action);
}

static void
files_dnd_handler_remove_action (FilesDndHandler* self,
                                 GtkApplicationWindow* win)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (win != NULL);
	g_action_map_remove_action ((GActionMap*) win, "choice");
}

static GtkMenu*
files_dnd_handler_build_menu (FilesDndHandler* self,
                              GdkDragAction possible_actions)
{
	GtkMenu* menu = NULL;
	GtkMenu* _tmp0_;
	GdkDragAction _tmp1_;
	GdkDragAction _tmp2_;
	GdkDragAction _tmp3_;
	GtkSeparatorMenuItem* _tmp4_;
	GtkSeparatorMenuItem* _tmp5_;
	GtkMenuItem* _tmp6_;
	GtkMenuItem* _tmp7_;
	GtkMenu* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkMenu*) gtk_menu_new ();
	g_object_ref_sink (_tmp0_);
	menu = _tmp0_;
	_tmp1_ = GDK_ACTION_MOVE;
	files_dnd_handler_build_and_append_menu_item (self, menu, _ ("Move Here"), &_tmp1_, possible_actions);
	_tmp2_ = GDK_ACTION_COPY;
	files_dnd_handler_build_and_append_menu_item (self, menu, _ ("Copy Here"), &_tmp2_, possible_actions);
	_tmp3_ = GDK_ACTION_LINK;
	files_dnd_handler_build_and_append_menu_item (self, menu, _ ("Link Here"), &_tmp3_, possible_actions);
	_tmp4_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	g_object_ref_sink (_tmp4_);
	_tmp5_ = _tmp4_;
	gtk_menu_shell_append ((GtkMenuShell*) menu, (GtkMenuItem*) _tmp5_);
	_g_object_unref0 (_tmp5_);
	_tmp6_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_ ("Cancel"));
	g_object_ref_sink (_tmp6_);
	_tmp7_ = _tmp6_;
	gtk_menu_shell_append ((GtkMenuShell*) menu, _tmp7_);
	_g_object_unref0 (_tmp7_);
	result = menu;
	return result;
}

static Block8Data*
block8_data_ref (Block8Data* _data8_)
{
	g_atomic_int_inc (&_data8_->_ref_count_);
	return _data8_;
}

static void
block8_data_unref (void * _userdata_)
{
	Block8Data* _data8_;
	_data8_ = (Block8Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data8_->_ref_count_)) {
		FilesDndHandler* self;
		self = _data8_->self;
		_g_free0 (_data8_->action);
		_g_object_unref0 (self);
		g_slice_free (Block8Data, _data8_);
	}
}

static void
___lambda30_ (Block8Data* _data8_)
{
	FilesDndHandler* self;
	self = _data8_->self;
	self->priv->chosen = *_data8_->action;
}

static void
____lambda30__gtk_menu_item_activate (GtkMenuItem* _sender,
                                      gpointer self)
{
	___lambda30_ (self);
}

static void
files_dnd_handler_build_and_append_menu_item (FilesDndHandler* self,
                                              GtkMenu* menu,
                                              const gchar* label,
                                              GdkDragAction* action,
                                              GdkDragAction possible_actions)
{
	Block8Data* _data8_;
	GdkDragAction* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (menu != NULL);
	g_return_if_fail (label != NULL);
	_data8_ = g_slice_new0 (Block8Data);
	_data8_->_ref_count_ = 1;
	_data8_->self = g_object_ref (self);
	_tmp0_ = __gdk_drag_action_dup0 (action);
	_g_free0 (_data8_->action);
	_data8_->action = _tmp0_;
	if ((possible_actions & (*_data8_->action)) != 0) {
		GtkMenuItem* item = NULL;
		GtkMenuItem* _tmp1_;
		GtkMenuItem* _tmp2_;
		GtkMenuItem* _tmp3_;
		_tmp1_ = (GtkMenuItem*) gtk_menu_item_new_with_label (label);
		g_object_ref_sink (_tmp1_);
		item = _tmp1_;
		_tmp2_ = item;
		g_signal_connect_data (_tmp2_, "activate", (GCallback) ____lambda30__gtk_menu_item_activate, block8_data_ref (_data8_), (GClosureNotify) block8_data_unref, 0);
		_tmp3_ = item;
		gtk_menu_shell_append ((GtkMenuShell*) menu, _tmp3_);
		_g_object_unref0 (item);
	}
	block8_data_unref (_data8_);
	_data8_ = NULL;
}

void
files_dnd_handler_on_choice (FilesDndHandler* self,
                             GVariant* param)
{
	gboolean _tmp0_ = FALSE;
	gchar* choice = NULL;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	GQuark _tmp7_ = 0U;
	static GQuark _tmp6_label0 = 0;
	static GQuark _tmp6_label1 = 0;
	static GQuark _tmp6_label2 = 0;
	g_return_if_fail (self != NULL);
	if (param == NULL) {
		_tmp0_ = TRUE;
	} else {
		const GVariantType* _tmp1_;
		_tmp1_ = G_VARIANT_TYPE_STRING;
		_tmp0_ = !g_variant_is_of_type (param, _tmp1_);
	}
	if (_tmp0_) {
		g_critical ("DndHandler.vala:126: Invalid variant type in DndHandler Menu");
		return;
	}
	_tmp2_ = g_variant_get_string (param, NULL);
	_tmp3_ = g_strdup (_tmp2_);
	choice = _tmp3_;
	_tmp4_ = choice;
	_tmp5_ = _tmp4_;
	_tmp7_ = (NULL == _tmp5_) ? 0 : g_quark_from_string (_tmp5_);
	if (_tmp7_ == ((0 != _tmp6_label0) ? _tmp6_label0 : (_tmp6_label0 = g_quark_from_static_string ("move")))) {
		switch (0) {
			default:
			{
				self->priv->chosen = GDK_ACTION_MOVE;
				break;
			}
		}
	} else if (_tmp7_ == ((0 != _tmp6_label1) ? _tmp6_label1 : (_tmp6_label1 = g_quark_from_static_string ("copy")))) {
		switch (0) {
			default:
			{
				self->priv->chosen = GDK_ACTION_COPY;
				break;
			}
		}
	} else if (_tmp7_ == ((0 != _tmp6_label2) ? _tmp6_label2 : (_tmp6_label2 = g_quark_from_static_string ("link")))) {
		switch (0) {
			default:
			{
				self->priv->chosen = GDK_ACTION_LINK;
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				self->priv->chosen = GDK_ACTION_DEFAULT;
				break;
			}
		}
	}
	_g_free0 (choice);
}

static gboolean
string_contains (const gchar* self,
                 const gchar* needle)
{
	gchar* _tmp0_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}

gchar*
files_dnd_handler_get_source_filename (FilesDndHandler* self,
                                       GdkDragContext* context)
{
	guchar* data = NULL;
	gint data_length1;
	gint _data_size_;
	GdkAtom property_name = (GdkAtom) 0U;
	GdkAtom property_type = (GdkAtom) 0U;
	gboolean exists = FALSE;
	GdkWindow* _tmp0_;
	guint8* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	gboolean _tmp3_;
	gboolean _tmp4_ = FALSE;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (context != NULL, NULL);
	data = NULL;
	data_length1 = 0;
	_data_size_ = data_length1;
	property_name = gdk_atom_intern_static_string ("XdndDirectSave0");
	property_type = gdk_atom_intern_static_string ("text/plain");
	_tmp0_ = gdk_drag_context_get_source_window (context);
	_tmp3_ = gdk_property_get (_tmp0_, property_name, property_type, (gulong) 0, (gulong) 1024, 0, NULL, NULL, &_tmp2_, &_tmp1_);
	data = (g_free (data), NULL);
	data = _tmp1_;
	data_length1 = _tmp2_;
	_data_size_ = data_length1;
	exists = _tmp3_;
	if (exists) {
		guchar* _tmp5_;
		gint _tmp5__length1;
		_tmp5_ = data;
		_tmp5__length1 = data_length1;
		_tmp4_ = _tmp5_ != NULL;
	} else {
		_tmp4_ = FALSE;
	}
	if (_tmp4_) {
		gchar* name = NULL;
		guchar* _tmp6_;
		gint _tmp6__length1;
		gchar* _tmp7_;
		const gchar* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		gboolean _tmp11_;
		_tmp6_ = data;
		_tmp6__length1 = data_length1;
		_tmp7_ = files_dnd_handler_data_to_string (_tmp6_, (gint) _tmp6__length1);
		name = _tmp7_;
		_tmp8_ = name;
		_tmp9_ = g_strdup_printf ("%c", G_DIR_SEPARATOR);
		_tmp10_ = _tmp9_;
		_tmp11_ = string_contains (_tmp8_, _tmp10_);
		_g_free0 (_tmp10_);
		if (_tmp11_) {
			g_warning ("DndHandler.vala:168: invalid source filename");
			result = NULL;
			_g_free0 (name);
			data = (g_free (data), NULL);
			return result;
		} else {
			result = name;
			data = (g_free (data), NULL);
			return result;
		}
		_g_free0 (name);
	} else {
		g_warning ("DndHandler.vala:174: source file does not exist");
		result = NULL;
		data = (g_free (data), NULL);
		return result;
	}
}

static guint8*
string_get_data (const gchar* self,
                 gint* result_length1)
{
	guint8* result;
	guint8* res = NULL;
	gint res_length1;
	gint _res_size_;
	gint _tmp0_;
	gint _tmp1_;
	guint8* _tmp2_;
	gint _tmp2__length1;
	g_return_val_if_fail (self != NULL, NULL);
	res = (guint8*) self;
	res_length1 = -1;
	_res_size_ = res_length1;
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	res_length1 = (gint) _tmp1_;
	_tmp2_ = res;
	_tmp2__length1 = res_length1;
	if (result_length1) {
		*result_length1 = _tmp2__length1;
	}
	result = _tmp2_;
	return result;
}

void
files_dnd_handler_set_source_uri (FilesDndHandler* self,
                                  GdkDragContext* context,
                                  const gchar* uri)
{
	GdkAtom property_name = (GdkAtom) 0U;
	GdkAtom property_type = (GdkAtom) 0U;
	GdkWindow* _tmp0_;
	guint8* _tmp1_;
	gint _tmp1__length1;
	gint _tmp2_ = 0;
	guint8* _tmp3_;
	gint _tmp3__length1;
	gint _tmp4_;
	gint _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	g_return_if_fail (uri != NULL);
	g_debug ("DndHandler.vala:180: DNDHANDLER: set source uri to %s", uri);
	property_name = gdk_atom_intern_static_string ("XdndDirectSave0");
	property_type = gdk_atom_intern_static_string ("text/plain");
	_tmp0_ = gdk_drag_context_get_source_window (context);
	_tmp1_ = string_get_data (uri, &_tmp2_);
	_tmp1__length1 = _tmp2_;
	_tmp3_ = _tmp1_;
	_tmp3__length1 = _tmp1__length1;
	_tmp4_ = strlen (uri);
	_tmp5_ = _tmp4_;
	gdk_property_change (_tmp0_, property_name, property_type, 8, GDK_PROP_MODE_REPLACE, (const guchar*) _tmp3_, _tmp5_);
}

gboolean
files_dnd_handler_handle_xdnddirectsave (FilesDndHandler* self,
                                         GdkDragContext* context,
                                         FilesFile* drop_target,
                                         GtkSelectionData* selection)
{
	gboolean success = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (context != NULL, FALSE);
	g_return_val_if_fail (drop_target != NULL, FALSE);
	g_return_val_if_fail (selection != NULL, FALSE);
	success = FALSE;
	if (selection != NULL) {
		_tmp1_ = gtk_selection_data_get_length (selection) == 1;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = gtk_selection_data_get_format (selection) == 8;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		guchar _result_ = '\0';
		guint8* _tmp2_;
		guint8 _tmp3_;
		_tmp2_ = gtk_selection_data_get_data (selection);
		_tmp3_ = _tmp2_[0];
		_result_ = (guchar) _tmp3_;
		switch (_result_) {
			case 'F':
			{
				break;
			}
			case 'E':
			{
				success = TRUE;
				break;
			}
			case 'S':
			{
				success = TRUE;
				break;
			}
			default:
			{
				gchar* _tmp4_;
				gchar* _tmp5_;
				_tmp4_ = g_strdup_printf ("%hhu", _result_);
				_tmp5_ = _tmp4_;
				g_warning ("DndHandler.vala:216: Unhandled XdndDirectSave result %s", _tmp5_);
				_g_free0 (_tmp5_);
				break;
			}
		}
	}
	if (!success) {
		files_dnd_handler_set_source_uri (self, context, "");
	}
	result = success;
	return result;
}

gboolean
files_dnd_handler_handle_netscape_url (FilesDndHandler* self,
                                       GdkDragContext* context,
                                       FilesFile* drop_target,
                                       GtkSelectionData* selection)
{
	gchar** parts = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar** _tmp2_;
	gchar** _tmp3_;
	gchar** _tmp4_;
	gint _tmp4__length1;
	gint parts_length1;
	gint _parts_size_;
	gchar** _tmp5_;
	gint _tmp5__length1;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (context != NULL, FALSE);
	g_return_val_if_fail (drop_target != NULL, FALSE);
	g_return_val_if_fail (selection != NULL, FALSE);
	_tmp0_ = gtk_selection_data_get_text (selection);
	_tmp1_ = _tmp0_;
	_tmp3_ = _tmp2_ = g_strsplit (_tmp1_, "\n", 0);
	_tmp4_ = _tmp3_;
	_tmp4__length1 = _vala_array_length (_tmp2_);
	_g_free0 (_tmp1_);
	parts = _tmp4_;
	parts_length1 = _tmp4__length1;
	_parts_size_ = parts_length1;
	_tmp5_ = parts;
	_tmp5__length1 = parts_length1;
	if (_tmp5__length1 != 2) {
		result = FALSE;
		parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	result = FALSE;
	parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
	return result;
}

gboolean
files_dnd_handler_handle_file_drag_actions (FilesDndHandler* self,
                                            GtkWidget* dest_widget,
                                            GdkDragContext* context,
                                            FilesFile* drop_target,
                                            GList* drop_file_list,
                                            GdkDragAction possible_actions,
                                            GdkDragAction suggested_action,
                                            GtkApplicationWindow* win,
                                            guint32 timestamp)
{
	gboolean success = FALSE;
	GdkDragAction action = 0U;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (dest_widget != NULL, FALSE);
	g_return_val_if_fail (context != NULL, FALSE);
	g_return_val_if_fail (drop_target != NULL, FALSE);
	g_return_val_if_fail (win != NULL, FALSE);
	success = FALSE;
	action = suggested_action;
	if (drop_file_list != NULL) {
		if ((possible_actions & GDK_ACTION_ASK) != 0) {
			GdkDragAction* _tmp0_;
			GdkDragAction* _tmp1_;
			_tmp0_ = files_dnd_handler_drag_drop_action_ask (self, dest_widget, win, possible_actions);
			_tmp1_ = _tmp0_;
			action = *_tmp1_;
			_g_free0 (_tmp1_);
		}
		if (action != GDK_ACTION_DEFAULT) {
			success = files_dnd_handler_dnd_perform (self, dest_widget, drop_target, drop_file_list, action);
		}
	} else {
		g_critical ("DndHandler.vala:265: Attempt to drop null file list");
	}
	result = success;
	return result;
}

static gchar*
bool_to_string (gboolean self)
{
	gchar* result;
	if (self) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup ("true");
		result = _tmp0_;
		return result;
	} else {
		gchar* _tmp1_;
		_tmp1_ = g_strdup ("false");
		result = _tmp1_;
		return result;
	}
}

gboolean
files_dnd_handler_selection_data_is_uri_list (GtkSelectionData* selection_data,
                                              guint info,
                                              gchar** text)
{
	gchar* _vala_text = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	const gchar* _tmp9_;
	gboolean result;
	g_return_val_if_fail (selection_data != NULL, FALSE);
	_g_free0 (_vala_text);
	_vala_text = NULL;
	if (info == ((guint) FILES_TARGET_TYPE_TEXT_URI_LIST)) {
		_tmp2_ = selection_data != NULL;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		_tmp1_ = gtk_selection_data_get_length (selection_data) > 0;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = gtk_selection_data_get_format (selection_data) == 8;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gint _tmp3_ = 0;
		guint8* _tmp4_;
		gchar* _tmp5_;
		_tmp4_ = gtk_selection_data_get_data_with_length (selection_data, &_tmp3_);
		_tmp5_ = files_dnd_handler_data_to_string (_tmp4_, (gint) _tmp3_);
		_g_free0 (_vala_text);
		_vala_text = _tmp5_;
	}
	_tmp6_ = _vala_text;
	_tmp7_ = bool_to_string (_tmp6_ != NULL);
	_tmp8_ = _tmp7_;
	g_debug ("DndHandler.vala:284: DNDHANDLER selection data is uri list returning %" \
"s", _tmp8_);
	_g_free0 (_tmp8_);
	_tmp9_ = _vala_text;
	result = _tmp9_ != NULL;
	if (text) {
		*text = _vala_text;
	} else {
		_g_free0 (_vala_text);
	}
	return result;
}

gchar*
files_dnd_handler_data_to_string (guchar* cdata,
                                  gint cdata_length1)
{
	GString* sb = NULL;
	GString* _tmp0_;
	GString* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* result;
	_tmp0_ = g_string_new ("");
	sb = _tmp0_;
	{
		guchar* u_collection = NULL;
		gint u_collection_length1 = 0;
		gint _u_collection_size_ = 0;
		gint u_it = 0;
		u_collection = cdata;
		u_collection_length1 = cdata_length1;
		for (u_it = 0; u_it < u_collection_length1; u_it = u_it + 1) {
			guchar u = '\0';
			u = u_collection[u_it];
			{
				GString* _tmp1_;
				_tmp1_ = sb;
				g_string_append_c (_tmp1_, (gchar) u);
			}
		}
	}
	_tmp2_ = sb;
	_tmp3_ = _tmp2_->str;
	_tmp4_ = g_strdup (_tmp3_);
	result = _tmp4_;
	_g_string_free0 (sb);
	return result;
}

static guint8*
g_string_get_data (GString* self,
                   gint* result_length1)
{
	guint8* result;
	guint8* res = NULL;
	const gchar* _tmp0_;
	gint res_length1;
	gint _res_size_;
	guint8* _tmp1_;
	gint _tmp1__length1;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->str;
	res = (guint8*) _tmp0_;
	res_length1 = -1;
	_res_size_ = res_length1;
	res_length1 = (gint) self->len;
	_tmp1_ = res;
	_tmp1__length1 = res_length1;
	if (result_length1) {
		*result_length1 = _tmp1__length1;
	}
	result = _tmp1_;
	return result;
}

void
files_dnd_handler_set_selection_data_from_file_list (GtkSelectionData* selection_data,
                                                     GList* file_list,
                                                     const gchar* prefix)
{
	GString* sb = NULL;
	GString* _tmp0_;
	guint8* _tmp1_;
	gint _tmp1__length1;
	gint _tmp2_ = 0;
	guint8* _tmp3_;
	gint _tmp3__length1;
	g_return_if_fail (selection_data != NULL);
	g_return_if_fail (prefix != NULL);
	_tmp0_ = g_string_new (prefix);
	sb = _tmp0_;
	files_dnd_handler_set_stringbuilder_from_file_list (sb, file_list, prefix, FALSE);
	_tmp1_ = g_string_get_data (sb, &_tmp2_);
	_tmp1__length1 = _tmp2_;
	_tmp3_ = _tmp1_;
	_tmp3__length1 = _tmp1__length1;
	gtk_selection_data_set (selection_data, gtk_selection_data_get_target (selection_data), 8, _tmp3_, (gint) _tmp3__length1);
	_g_string_free0 (sb);
}

void
files_dnd_handler_set_selection_text_from_file_list (GtkSelectionData* selection_data,
                                                     GList* file_list,
                                                     const gchar* prefix)
{
	GString* sb = NULL;
	GString* _tmp0_;
	const gchar* _tmp1_;
	g_return_if_fail (selection_data != NULL);
	g_return_if_fail (prefix != NULL);
	_tmp0_ = g_string_new (prefix);
	sb = _tmp0_;
	files_dnd_handler_set_stringbuilder_from_file_list (sb, file_list, prefix, TRUE);
	g_string_truncate (sb, (gsize) (sb->len - 2));
	_tmp1_ = sb->str;
	gtk_selection_data_set_text (selection_data, _tmp1_, (gint) sb->len);
	_g_string_free0 (sb);
}

static Block9Data*
block9_data_ref (Block9Data* _data9_)
{
	g_atomic_int_inc (&_data9_->_ref_count_);
	return _data9_;
}

static void
block9_data_unref (void * _userdata_)
{
	Block9Data* _data9_;
	_data9_ = (Block9Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data9_->_ref_count_)) {
		g_slice_free (Block9Data, _data9_);
	}
}

static Block10Data*
block10_data_ref (Block10Data* _data10_)
{
	g_atomic_int_inc (&_data10_->_ref_count_);
	return _data10_;
}

static void
block10_data_unref (void * _userdata_)
{
	Block10Data* _data10_;
	_data10_ = (Block10Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data10_->_ref_count_)) {
		block9_data_unref (_data10_->_data9_);
		_data10_->_data9_ = NULL;
		g_slice_free (Block10Data, _data10_);
	}
}

static void
___lambda32_ (Block10Data* _data10_,
              FilesFile* file)
{
	Block9Data* _data9_;
	gchar* _tmp0_ = NULL;
	gchar* target = NULL;
	gchar* _tmp4_;
	const gchar* _tmp7_;
	_data9_ = _data10_->_data9_;
	g_return_if_fail (file != NULL);
	if (_data10_->in_recent) {
		gchar* _tmp1_;
		_tmp1_ = files_file_get_display_target_uri (file);
		_g_free0 (_tmp0_);
		_tmp0_ = _tmp1_;
	} else {
		GFile* _tmp2_;
		gchar* _tmp3_;
		_tmp2_ = files_file_get_target_location (file);
		_tmp3_ = g_file_get_uri (_tmp2_);
		_g_free0 (_tmp0_);
		_tmp0_ = _tmp3_;
	}
	_tmp4_ = g_strdup (_tmp0_);
	target = _tmp4_;
	if (_data9_->sanitize_path) {
		const gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = target;
		_tmp6_ = files_file_utils_sanitize_path (_tmp5_, NULL, FALSE);
		_g_free0 (target);
		target = _tmp6_;
	}
	_tmp7_ = target;
	g_string_append (_data9_->sb, _tmp7_);
	g_string_append (_data9_->sb, "\r\n");
	_g_free0 (target);
	_g_free0 (_tmp0_);
}

static void
____lambda32__gfunc (gconstpointer data,
                     gpointer self)
{
	___lambda32_ (self, (FilesFile*) data);
}

static void
files_dnd_handler_set_stringbuilder_from_file_list (GString* sb,
                                                    GList* file_list,
                                                    const gchar* prefix,
                                                    gboolean sanitize_path)
{
	Block9Data* _data9_;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (sb != NULL);
	g_return_if_fail (prefix != NULL);
	_data9_ = g_slice_new0 (Block9Data);
	_data9_->_ref_count_ = 1;
	_data9_->sb = sb;
	_data9_->sanitize_path = sanitize_path;
	if (file_list != NULL) {
		gconstpointer _tmp2_;
		_tmp2_ = file_list->data;
		_tmp1_ = ((FilesFile*) _tmp2_) != NULL;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		gconstpointer _tmp3_;
		_tmp3_ = file_list->data;
		_tmp0_ = FILES_IS_FILE ((FilesFile*) _tmp3_);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		Block10Data* _data10_;
		gconstpointer _tmp4_;
		_data10_ = g_slice_new0 (Block10Data);
		_data10_->_ref_count_ = 1;
		_data10_->_data9_ = block9_data_ref (_data9_);
		_tmp4_ = file_list->data;
		_data10_->in_recent = files_file_is_recent_uri_scheme ((FilesFile*) _tmp4_);
		g_list_foreach (file_list, ____lambda32__gfunc, _data10_);
		block10_data_unref (_data10_);
		_data10_ = NULL;
	} else {
		g_warning ("DndHandler.vala:338: Invalid file list for drag and drop ignored");
	}
	block9_data_unref (_data9_);
	_data9_ = NULL;
}

static void
files_dnd_handler_class_init (FilesDndHandlerClass * klass,
                              gpointer klass_data)
{
	files_dnd_handler_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &FilesDndHandler_private_offset);
	G_OBJECT_CLASS (klass)->finalize = files_dnd_handler_finalize;
}

static void
files_dnd_handler_instance_init (FilesDndHandler * self,
                                 gpointer klass)
{
	self->priv = files_dnd_handler_get_instance_private (self);
	self->priv->chosen = GDK_ACTION_DEFAULT;
}

static void
files_dnd_handler_finalize (GObject * obj)
{
	FilesDndHandler * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILES_TYPE_DND_HANDLER, FilesDndHandler);
	G_OBJECT_CLASS (files_dnd_handler_parent_class)->finalize (obj);
}

static GType
files_dnd_handler_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FilesDndHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) files_dnd_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FilesDndHandler), 0, (GInstanceInitFunc) files_dnd_handler_instance_init, NULL };
	GType files_dnd_handler_type_id;
	files_dnd_handler_type_id = g_type_register_static (G_TYPE_OBJECT, "FilesDndHandler", &g_define_type_info, 0);
	FilesDndHandler_private_offset = g_type_add_instance_private (files_dnd_handler_type_id, sizeof (FilesDndHandlerPrivate));
	return files_dnd_handler_type_id;
}

GType
files_dnd_handler_get_type (void)
{
	static volatile gsize files_dnd_handler_type_id__once = 0;
	if (g_once_init_enter (&files_dnd_handler_type_id__once)) {
		GType files_dnd_handler_type_id;
		files_dnd_handler_type_id = files_dnd_handler_get_type_once ();
		g_once_init_leave (&files_dnd_handler_type_id__once, files_dnd_handler_type_id);
	}
	return files_dnd_handler_type_id__once;
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gssize
_vala_array_length (gpointer array)
{
	gssize length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

