/* GOFFileTests.c generated by valac 0.56.3, the Vala compiler
 * generated from GOFFileTests.vala, do not modify */

#include <glib.h>
#include <stdlib.h>
#include <string.h>
#include "pantheon-files-core.h"
#include <gio/gio.h>
#include <glib-object.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

VALA_EXTERN void add_gof_file_tests (void);
VALA_EXTERN void existing_local_folder_test (void);
static void _existing_local_folder_test_gtest_func (void);
VALA_EXTERN void gof_file_cache_test (void);
static void _gof_file_cache_test_gtest_func (void);
VALA_EXTERN void new_non_existent_local_test (void);
static void _new_non_existent_local_test_gtest_func (void);
VALA_EXTERN void new_hidden_local_test (void);
static void _new_hidden_local_test_gtest_func (void);
VALA_EXTERN void new_symlink_local_test (void);
static void _new_symlink_local_test_gtest_func (void);
static gint _vala_main (gchar** args,
                 gint args_length1);

/***
    Copyright (c) 2017-2018 elementary LLC <https://elementary.io>

    This file is part of Pantheon Files.

    Pantheon Files is free software: you can redistribute it and/or modify it
    under the terms of the GNU Lesser General Public License version 3, as published
    by the Free Software Foundation.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranties of
    MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
    PURPOSE. See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with Pantheon Files. If not, see <http://www.gnu.org/licenses/>.

    Authored by: Jeremy Wootten <jeremy@elementaryos.org>
***/
static void
_existing_local_folder_test_gtest_func (void)
{
	existing_local_folder_test ();
}

static void
_gof_file_cache_test_gtest_func (void)
{
	gof_file_cache_test ();
}

static void
_new_non_existent_local_test_gtest_func (void)
{
	new_non_existent_local_test ();
}

static void
_new_hidden_local_test_gtest_func (void)
{
	new_hidden_local_test ();
}

static void
_new_symlink_local_test_gtest_func (void)
{
	new_symlink_local_test ();
}

void
add_gof_file_tests (void)
{
	g_test_add_func ("/GOFFile/new_existing_local_folder", _existing_local_folder_test_gtest_func);
	g_test_add_func ("/GOFFile/gof_file_cache", _gof_file_cache_test_gtest_func);
	g_test_add_func ("/GOFFile/new_non_existent_local", _new_non_existent_local_test_gtest_func);
	g_test_add_func ("/GOFFile/new_hidden_local", _new_hidden_local_test_gtest_func);
	g_test_add_func ("/GOFFile/new_symlink_local", _new_symlink_local_test_gtest_func);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

void
existing_local_folder_test (void)
{
	gchar* parent_path = NULL;
	gchar* _tmp0_;
	gchar* basename = NULL;
	gchar* _tmp1_;
	gchar* path = NULL;
	gchar* _tmp2_;
	gchar* uri = NULL;
	gchar* _tmp3_;
	FilesFile* file = NULL;
	FilesFile* _tmp4_;
	GFile* _tmp5_;
	GFile* _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	GFile* _tmp10_;
	GFile* _tmp11_;
	gchar* _tmp12_;
	gchar* _tmp13_;
	const gchar* _tmp14_;
	const gchar* _tmp15_;
	GFileInfo* _tmp16_;
	GFileInfo* info = NULL;
	GFileInfo* _tmp17_;
	GFileInfo* _tmp18_;
	const gchar* _tmp19_;
	const gchar* _tmp20_;
	_tmp0_ = g_strdup ("/usr");
	parent_path = _tmp0_;
	_tmp1_ = g_strdup ("share");
	basename = _tmp1_;
	_tmp2_ = g_build_filename (parent_path, basename, NULL);
	path = _tmp2_;
	_tmp3_ = g_strconcat ("file://", path, NULL);
	uri = _tmp3_;
	_tmp4_ = files_file_get_by_uri (path);
	file = _tmp4_;
	_vala_assert (file != NULL, "file != null");
	_tmp5_ = files_file_get_location (file);
	_tmp6_ = _tmp5_;
	_vala_assert (_tmp6_ != NULL, "file.location != null");
	_vala_assert (file->exists, "file.exists");
	_vala_assert (file->is_connected, "file.is_connected");
	_vala_assert (file->is_mounted, "file.is_mounted");
	files_file_query_update (file);
	_vala_assert (file->exists, "file.exists");
	_vala_assert (file->is_connected, "file.is_connected");
	_vala_assert (!file->is_mounted, "!file.is_mounted");
	_tmp7_ = files_file_get_basename (file);
	_tmp8_ = _tmp7_;
	_vala_assert (g_strcmp0 (_tmp8_, basename) == 0, "file.basename == basename");
	_vala_assert (file->is_directory, "file.is_directory");
	_vala_assert (!file->is_hidden, "!file.is_hidden");
	_tmp9_ = files_file_get_ftype (file);
	_vala_assert (g_strcmp0 (_tmp9_, "inode/directory") == 0, "file.get_ftype () == \"inode/directory\"");
	_vala_assert (!files_file_is_symlink (file), "!file.is_symlink ()");
	_tmp10_ = files_file_get_location (file);
	_tmp11_ = _tmp10_;
	_tmp12_ = g_file_get_uri (_tmp11_);
	_tmp13_ = _tmp12_;
	_vala_assert (g_strcmp0 (_tmp13_, uri) == 0, "file.location.get_uri () == uri");
	_g_free0 (_tmp13_);
	_tmp14_ = files_file_get_uri (file);
	_tmp15_ = _tmp14_;
	_vala_assert (g_strcmp0 (_tmp15_, uri) == 0, "file.uri == uri");
	_tmp16_ = file->info;
	_vala_assert (_tmp16_ != NULL, "file.info != null");
	_tmp17_ = file->info;
	_tmp18_ = _g_object_ref0 (_tmp17_);
	info = _tmp18_;
	_tmp19_ = g_file_info_get_name (info);
	_vala_assert (g_strcmp0 (_tmp19_, basename) == 0, "info.get_name () == basename");
	_tmp20_ = g_file_info_get_display_name (info);
	_vala_assert (g_strcmp0 (_tmp20_, basename) == 0, "info.get_display_name () == basename");
	_g_object_unref0 (info);
	_g_object_unref0 (file);
	_g_free0 (uri);
	_g_free0 (path);
	_g_free0 (basename);
	_g_free0 (parent_path);
}

void
gof_file_cache_test (void)
{
	gchar* parent_path = NULL;
	gchar* _tmp0_;
	gchar* basename = NULL;
	gchar* _tmp1_;
	gchar* path = NULL;
	gchar* _tmp2_;
	gchar* uri = NULL;
	gchar* _tmp3_;
	FilesFile* file = NULL;
	FilesFile* _tmp4_;
	FilesFile* file2 = NULL;
	FilesFile* _tmp5_;
	FilesFile* file3 = NULL;
	FilesFile* _tmp6_;
	_tmp0_ = g_strdup ("/usr");
	parent_path = _tmp0_;
	_tmp1_ = g_strdup ("share");
	basename = _tmp1_;
	_tmp2_ = g_build_filename (parent_path, basename, NULL);
	path = _tmp2_;
	_tmp3_ = g_strconcat ("file://", path, NULL);
	uri = _tmp3_;
	_tmp4_ = files_file_get_by_commandline_arg (path);
	file = _tmp4_;
	_vala_assert (((GObject*) file)->ref_count == ((guint) 2), "file.ref_count == 2");
	_tmp5_ = files_file_get_by_uri (uri);
	file2 = _tmp5_;
	_vala_assert (file == file2, "file == file2");
	_vala_assert (((GObject*) file)->ref_count == ((guint) 3), "file.ref_count == 3");
	_vala_assert (((GObject*) file2)->ref_count == ((guint) 3), "file2.ref_count == 3");
	files_file_remove_from_caches (file);
	_vala_assert (((GObject*) file)->ref_count == ((guint) 2), "file.ref_count == 2");
	_vala_assert (((GObject*) file2)->ref_count == ((guint) 2), "file2.ref_count == 2");
	files_file_remove_from_caches (file2);
	_vala_assert (((GObject*) file)->ref_count == ((guint) 2), "file.ref_count == 2");
	_vala_assert (((GObject*) file2)->ref_count == ((guint) 2), "file2.ref_count == 2");
	_tmp6_ = files_file_get_by_uri (uri);
	file3 = _tmp6_;
	_vala_assert (file != file3, "file != file3");
	_vala_assert (((GObject*) file)->ref_count == ((guint) 2), "file.ref_count == 2");
	_vala_assert (((GObject*) file3)->ref_count == ((guint) 2), "file3.ref_count == 2");
	files_file_remove_from_caches (file3);
	_vala_assert (((GObject*) file3)->ref_count == ((guint) 1), "file3.ref_count == 1");
	_g_object_unref0 (file3);
	_g_object_unref0 (file2);
	_g_object_unref0 (file);
	_g_free0 (uri);
	_g_free0 (path);
	_g_free0 (basename);
	_g_free0 (parent_path);
}

void
new_non_existent_local_test (void)
{
	gchar* basename = NULL;
	gchar* _tmp0_;
	gchar* path = NULL;
	gchar* _tmp1_;
	FilesFile* file = NULL;
	FilesFile* _tmp2_;
	GFile* _tmp3_;
	GFile* _tmp4_;
	GFileInfo* _tmp5_;
	_tmp0_ = g_strdup_printf ("%" G_GINT64_FORMAT, g_get_real_time ());
	basename = _tmp0_;
	_tmp1_ = g_build_filename ("/", "tmp", "marlin-test", basename, NULL);
	path = _tmp1_;
	_tmp2_ = files_file_get_by_commandline_arg (path);
	file = _tmp2_;
	_vala_assert (file != NULL, "file != null");
	_tmp3_ = files_file_get_location (file);
	_tmp4_ = _tmp3_;
	_vala_assert (_tmp4_ != NULL, "file.location != null");
	_vala_assert (file->exists, "file.exists");
	files_file_query_update (file);
	_tmp5_ = file->info;
	_vala_assert (_tmp5_ == NULL, "file.info == null");
	_vala_assert (!file->exists, "!file.exists");
	_g_object_unref0 (file);
	_g_free0 (path);
	_g_free0 (basename);
}

void
new_hidden_local_test (void)
{
	gchar* basename = NULL;
	gchar* _tmp0_;
	gchar* parent_path = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* path = NULL;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	FilesFile* file = NULL;
	FilesFile* _tmp12_;
	GFile* _tmp13_;
	GFile* _tmp14_;
	GFileInfo* _tmp15_;
	gchar* _tmp16_;
	gchar* _tmp17_;
	_tmp0_ = g_strdup (".hidden_test");
	basename = _tmp0_;
	_tmp1_ = g_strdup_printf ("%" G_GINT64_FORMAT, g_get_real_time ());
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat ("marlin-test", _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_build_filename ("/", "tmp", _tmp4_, NULL);
	_tmp6_ = _tmp5_;
	_g_free0 (_tmp4_);
	_g_free0 (_tmp2_);
	parent_path = _tmp6_;
	_tmp7_ = g_build_filename (parent_path, basename, NULL);
	path = _tmp7_;
	_tmp8_ = g_strconcat ("mkdir ", parent_path, NULL);
	_tmp9_ = _tmp8_;
	system (_tmp9_);
	_g_free0 (_tmp9_);
	_tmp10_ = g_strconcat ("touch ", path, NULL);
	_tmp11_ = _tmp10_;
	system (_tmp11_);
	_g_free0 (_tmp11_);
	_tmp12_ = files_file_get_by_commandline_arg (path);
	file = _tmp12_;
	_vala_assert (file != NULL, "file != null");
	_tmp13_ = files_file_get_location (file);
	_tmp14_ = _tmp13_;
	_vala_assert (_tmp14_ != NULL, "file.location != null");
	_vala_assert (file->exists == TRUE, "file.exists == true");
	_vala_assert (file->is_connected == TRUE, "file.is_connected == true");
	_vala_assert (file->is_mounted, "file.is_mounted");
	files_file_query_update (file);
	_tmp15_ = file->info;
	_vala_assert (_tmp15_ != NULL, "file.info != null");
	_vala_assert (file->exists, "file.exists");
	_vala_assert (file->is_connected, "file.is_connected");
	_vala_assert (!file->is_mounted, "!file.is_mounted");
	_vala_assert (!file->is_directory, "!file.is_directory");
	_vala_assert (file->is_hidden, "file.is_hidden");
	_vala_assert (file->size == ((guint64) 0), "file.size == 0");
	_tmp16_ = g_strconcat ("rm -rf ", parent_path, NULL);
	_tmp17_ = _tmp16_;
	system (_tmp17_);
	_g_free0 (_tmp17_);
	_g_object_unref0 (file);
	_g_free0 (path);
	_g_free0 (parent_path);
	_g_free0 (basename);
}

void
new_symlink_local_test (void)
{
	gchar* basename = NULL;
	gchar* _tmp0_;
	gchar* linkname = NULL;
	gchar* _tmp1_;
	gchar* parent_path = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* path = NULL;
	gchar* _tmp8_;
	gchar* link_path = NULL;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	gchar* _tmp15_;
	gchar* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_;
	gchar* _tmp19_;
	FilesFile* file = NULL;
	FilesFile* _tmp20_;
	GFile* _tmp21_;
	GFile* _tmp22_;
	GFileInfo* _tmp23_;
	const gchar* _tmp24_;
	gchar* _tmp25_;
	gchar* _tmp26_;
	_tmp0_ = g_strdup ("target");
	basename = _tmp0_;
	_tmp1_ = g_strdup ("link");
	linkname = _tmp1_;
	_tmp2_ = g_strdup_printf ("%" G_GINT64_FORMAT, g_get_real_time ());
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strconcat ("marlin-test", _tmp3_, NULL);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_build_filename ("/", "tmp", _tmp5_, NULL);
	_tmp7_ = _tmp6_;
	_g_free0 (_tmp5_);
	_g_free0 (_tmp3_);
	parent_path = _tmp7_;
	_tmp8_ = g_build_filename (parent_path, basename, NULL);
	path = _tmp8_;
	_tmp9_ = g_build_filename (parent_path, linkname, NULL);
	link_path = _tmp9_;
	_tmp10_ = g_strconcat ("mkdir ", parent_path, NULL);
	_tmp11_ = _tmp10_;
	system (_tmp11_);
	_g_free0 (_tmp11_);
	_tmp12_ = g_strconcat ("touch ", path, NULL);
	_tmp13_ = _tmp12_;
	system (_tmp13_);
	_g_free0 (_tmp13_);
	_tmp14_ = g_strconcat ("ln -s ", path, NULL);
	_tmp15_ = _tmp14_;
	_tmp16_ = g_strconcat (_tmp15_, " ", NULL);
	_tmp17_ = _tmp16_;
	_tmp18_ = g_strconcat (_tmp17_, link_path, NULL);
	_tmp19_ = _tmp18_;
	system (_tmp19_);
	_g_free0 (_tmp19_);
	_g_free0 (_tmp17_);
	_g_free0 (_tmp15_);
	_tmp20_ = files_file_get_by_commandline_arg (link_path);
	file = _tmp20_;
	_vala_assert (file != NULL, "file != null");
	_tmp21_ = files_file_get_location (file);
	_tmp22_ = _tmp21_;
	_vala_assert (_tmp22_ != NULL, "file.location != null");
	_vala_assert (file->exists, "file.exists");
	files_file_query_update (file);
	_tmp23_ = file->info;
	_vala_assert (_tmp23_ != NULL, "file.info != null");
	_tmp24_ = files_file_get_symlink_target (file);
	_vala_assert (g_strcmp0 (_tmp24_, path) == 0, "file.get_symlink_target () == path");
	_vala_assert (files_file_is_symlink (file), "file.is_symlink ()");
	_vala_assert (!file->is_directory, "!file.is_directory");
	_vala_assert (!file->is_hidden, "!file.is_hidden");
	_tmp25_ = g_strconcat ("rm -rf ", parent_path, NULL);
	_tmp26_ = _tmp25_;
	system (_tmp26_);
	_g_free0 (_tmp26_);
	_g_object_unref0 (file);
	_g_free0 (link_path);
	_g_free0 (path);
	_g_free0 (parent_path);
	_g_free0 (linkname);
	_g_free0 (basename);
}

static gint
_vala_main (gchar** args,
            gint args_length1)
{
	gint result;
	g_test_init ((gint*) (&args_length1), &args, NULL);
	add_gof_file_tests ();
	result = g_test_run ();
	return result;
}

int
main (int argc,
      char ** argv)
{
	return _vala_main (argv, argc);
}

