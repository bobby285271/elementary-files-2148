/* GOFDirectoryAsyncTests.c generated by valac 0.56.3, the Vala compiler
 * generated from GOFDirectoryAsyncTests.vala, do not modify */

#include <glib.h>
#include "pantheon-files-core.h"
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <glib-object.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

typedef FilesDirectory* (*FilesDirectoryTestLoadFolderTest) (const gchar* path, GMainLoop* loop, gpointer user_data);
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
typedef struct _Block1Data Block1Data;
typedef struct _Block2Data Block2Data;
typedef struct _Block3Data Block3Data;
typedef struct _Block4Data Block4Data;
typedef struct _Block5Data Block5Data;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _Block1Data {
	int _ref_count_;
	FilesDirectory* dir;
	GMainLoop* loop;
};

struct _Block2Data {
	int _ref_count_;
	FilesDirectory* dir;
	GMainLoop* loop;
};

struct _Block3Data {
	int _ref_count_;
	guint n_files;
	guint file_loaded_signal_count;
	FilesDirectory* dir;
	GMainLoop* loop;
};

struct _Block4Data {
	int _ref_count_;
	guint n_files;
	gboolean first_load;
	guint file_loaded_signal_count;
	FilesDirectory* dir;
	GMainLoop* loop;
};

struct _Block5Data {
	int _ref_count_;
	guint n_files;
	guint n_loads;
	guint loads;
	guint ref_count_before_reload;
	gchar* tmp_pth;
	FilesDirectory* dir;
	GMainLoop* loop;
};

VALA_EXTERN void files_directory_test_add_gof_directory_async_tests (void);
static void __lambda4_ (void);
VALA_EXTERN void files_directory_test_run_load_folder_test (FilesDirectoryTestLoadFolderTest test,
                                                gpointer test_target);
VALA_EXTERN FilesDirectory* files_directory_test_load_non_existent_local_test (const gchar* test_dir_path,
                                                                   GMainLoop* loop);
static FilesDirectory* _files_directory_test_load_non_existent_local_test_files_directory_test_load_folder_test (const gchar* path,
                                                                                                          GMainLoop* loop,
                                                                                                          gpointer self);
static void ___lambda4__gtest_func (void);
static void __lambda6_ (void);
VALA_EXTERN FilesDirectory* files_directory_test_load_empty_local_test (const gchar* test_dir_path,
                                                            GMainLoop* loop);
static FilesDirectory* _files_directory_test_load_empty_local_test_files_directory_test_load_folder_test (const gchar* path,
                                                                                                   GMainLoop* loop,
                                                                                                   gpointer self);
static void ___lambda6__gtest_func (void);
static void __lambda8_ (void);
VALA_EXTERN FilesDirectory* files_directory_test_load_populated_local_test (const gchar* test_dir_path,
                                                                GMainLoop* loop);
static FilesDirectory* _files_directory_test_load_populated_local_test_files_directory_test_load_folder_test (const gchar* path,
                                                                                                       GMainLoop* loop,
                                                                                                       gpointer self);
static void ___lambda8__gtest_func (void);
static void __lambda11_ (void);
VALA_EXTERN FilesDirectory* files_directory_test_load_cached_local_test (const gchar* test_dir_path,
                                                             GMainLoop* loop);
static FilesDirectory* _files_directory_test_load_cached_local_test_files_directory_test_load_folder_test (const gchar* path,
                                                                                                    GMainLoop* loop,
                                                                                                    gpointer self);
static void ___lambda11__gtest_func (void);
static void __lambda14_ (void);
VALA_EXTERN FilesDirectory* files_directory_test_reload_populated_local_test (const gchar* test_dir_path,
                                                                  GMainLoop* loop);
static FilesDirectory* _files_directory_test_reload_populated_local_test_files_directory_test_load_folder_test (const gchar* path,
                                                                                                         GMainLoop* loop,
                                                                                                         gpointer self);
static void ___lambda14__gtest_func (void);
VALA_EXTERN void files_directory_test_tear_down_folder (const gchar* path);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void __lambda5_ (Block1Data* _data1_);
static void ___lambda5__files_directory_done_loading (FilesDirectory* _sender,
                                               gpointer self);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
VALA_EXTERN FilesDirectory* files_directory_test_setup_temp_async (const gchar* path,
                                                       guint n_files,
                                                       const gchar* extension,
                                                       const gchar* path_to_template);
static void __lambda7_ (Block2Data* _data2_);
static void ___lambda7__files_directory_done_loading (FilesDirectory* _sender,
                                               gpointer self);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
static void __lambda9_ (Block3Data* _data3_);
static void ___lambda9__files_directory_file_loaded (FilesDirectory* _sender,
                                              FilesFile* file,
                                              gpointer self);
static void __lambda10_ (Block3Data* _data3_);
static void ___lambda10__files_directory_done_loading (FilesDirectory* _sender,
                                                gpointer self);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (void * _userdata_);
static void __lambda12_ (Block4Data* _data4_);
static void ___lambda13_ (Block4Data* _data4_);
static void ____lambda13__files_directory_file_loaded (FilesDirectory* _sender,
                                                FilesFile* file,
                                                gpointer self);
static void ___lambda12__files_directory_done_loading (FilesDirectory* _sender,
                                                gpointer self);
static Block5Data* block5_data_ref (Block5Data* _data5_);
static void block5_data_unref (void * _userdata_);
VALA_EXTERN gchar* files_directory_test_get_text_template_path (void);
static void __lambda15_ (Block5Data* _data5_);
VALA_EXTERN void files_directory_test_tear_down_file (const gchar* path);
static void ___lambda15__files_directory_done_loading (FilesDirectory* _sender,
                                                gpointer self);
static gint _vala_main (gchar** args,
                 gint args_length1);

static FilesDirectory*
_files_directory_test_load_non_existent_local_test_files_directory_test_load_folder_test (const gchar* path,
                                                                                          GMainLoop* loop,
                                                                                          gpointer self)
{
	FilesDirectory* result;
	result = files_directory_test_load_non_existent_local_test (path, loop);
	return result;
}

static void
__lambda4_ (void)
{
	files_directory_test_run_load_folder_test (_files_directory_test_load_non_existent_local_test_files_directory_test_load_folder_test, NULL);
}

static void
___lambda4__gtest_func (void)
{
	__lambda4_ ();
}

static FilesDirectory*
_files_directory_test_load_empty_local_test_files_directory_test_load_folder_test (const gchar* path,
                                                                                   GMainLoop* loop,
                                                                                   gpointer self)
{
	FilesDirectory* result;
	result = files_directory_test_load_empty_local_test (path, loop);
	return result;
}

static void
__lambda6_ (void)
{
	files_directory_test_run_load_folder_test (_files_directory_test_load_empty_local_test_files_directory_test_load_folder_test, NULL);
}

static void
___lambda6__gtest_func (void)
{
	__lambda6_ ();
}

static FilesDirectory*
_files_directory_test_load_populated_local_test_files_directory_test_load_folder_test (const gchar* path,
                                                                                       GMainLoop* loop,
                                                                                       gpointer self)
{
	FilesDirectory* result;
	result = files_directory_test_load_populated_local_test (path, loop);
	return result;
}

static void
__lambda8_ (void)
{
	files_directory_test_run_load_folder_test (_files_directory_test_load_populated_local_test_files_directory_test_load_folder_test, NULL);
}

static void
___lambda8__gtest_func (void)
{
	__lambda8_ ();
}

static FilesDirectory*
_files_directory_test_load_cached_local_test_files_directory_test_load_folder_test (const gchar* path,
                                                                                    GMainLoop* loop,
                                                                                    gpointer self)
{
	FilesDirectory* result;
	result = files_directory_test_load_cached_local_test (path, loop);
	return result;
}

static void
__lambda11_ (void)
{
	files_directory_test_run_load_folder_test (_files_directory_test_load_cached_local_test_files_directory_test_load_folder_test, NULL);
}

static void
___lambda11__gtest_func (void)
{
	__lambda11_ ();
}

static FilesDirectory*
_files_directory_test_reload_populated_local_test_files_directory_test_load_folder_test (const gchar* path,
                                                                                         GMainLoop* loop,
                                                                                         gpointer self)
{
	FilesDirectory* result;
	result = files_directory_test_reload_populated_local_test (path, loop);
	return result;
}

static void
__lambda14_ (void)
{
	files_directory_test_run_load_folder_test (_files_directory_test_reload_populated_local_test_files_directory_test_load_folder_test, NULL);
}

static void
___lambda14__gtest_func (void)
{
	__lambda14_ ();
}

void
files_directory_test_add_gof_directory_async_tests (void)
{
	g_test_add_func ("/FilesDirectory/load_non_existent_local", ___lambda4__gtest_func);
	g_test_add_func ("/FilesDirectory/load_empty_local", ___lambda6__gtest_func);
	g_test_add_func ("/FilesDirectory/load_populated_local", ___lambda8__gtest_func);
	g_test_add_func ("/FilesDirectory/load_cached_local", ___lambda11__gtest_func);
	g_test_add_func ("/FilesDirectory/reload_populated_local", ___lambda14__gtest_func);
}

void
files_directory_test_run_load_folder_test (FilesDirectoryTestLoadFolderTest test,
                                           gpointer test_target)
{
	GMainLoop* loop = NULL;
	GMainLoop* _tmp0_;
	gchar* test_dir_path = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	FilesDirectory* dir = NULL;
	FilesDirectory* _tmp5_;
	FilesDirectoryState _tmp6_;
	FilesDirectoryState _tmp7_;
	_tmp0_ = g_main_loop_new (NULL, FALSE);
	loop = _tmp0_;
	_tmp1_ = g_strdup_printf ("%" G_GINT64_FORMAT, g_get_real_time ());
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat ("/tmp/marlin-test-", _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	test_dir_path = _tmp4_;
	_tmp5_ = test (test_dir_path, loop, test_target);
	dir = _tmp5_;
	files_directory_set_allow_user_interaction (dir, FALSE);
	_tmp6_ = files_directory_get_state (dir);
	_tmp7_ = _tmp6_;
	_vala_assert (_tmp7_ == FILES_DIRECTORY_STATE_NOT_LOADED, "dir.state == Directory.State.NOT_LOADED");
	files_directory_init (dir, NULL, NULL, NULL, NULL);
	g_main_loop_run (loop);
	files_directory_test_tear_down_folder (test_dir_path);
	_g_object_unref0 (dir);
	_g_free0 (test_dir_path);
	_g_main_loop_unref0 (loop);
}

/*** Test functions ***/
static gpointer
_g_main_loop_ref0 (gpointer self)
{
	return self ? g_main_loop_ref (self) : NULL;
}

static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}

static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_object_unref0 (_data1_->dir);
		_g_main_loop_unref0 (_data1_->loop);
		g_slice_free (Block1Data, _data1_);
	}
}

static void
__lambda5_ (Block1Data* _data1_)
{
	guint _tmp0_;
	guint _tmp1_;
	gboolean _tmp2_;
	gboolean _tmp3_;
	FilesFile* _tmp4_;
	FilesFile* _tmp5_;
	FilesFile* _tmp6_;
	FilesFile* _tmp7_;
	FilesFile* _tmp8_;
	FilesFile* _tmp9_;
	FilesDirectoryState _tmp10_;
	FilesDirectoryState _tmp11_;
	_tmp0_ = files_directory_get_displayed_files_count (_data1_->dir);
	_tmp1_ = _tmp0_;
	_vala_assert (_tmp1_ == ((guint) 0), "dir.displayed_files_count == 0");
	_tmp2_ = files_directory_get_can_load (_data1_->dir);
	_tmp3_ = _tmp2_;
	_vala_assert (!_tmp3_, "!dir.can_load");
	_tmp4_ = files_directory_get_file (_data1_->dir);
	_tmp5_ = _tmp4_;
	_vala_assert (!_tmp5_->is_connected, "!dir.file.is_connected");
	_tmp6_ = files_directory_get_file (_data1_->dir);
	_tmp7_ = _tmp6_;
	_vala_assert (!_tmp7_->is_mounted, "!dir.file.is_mounted");
	_tmp8_ = files_directory_get_file (_data1_->dir);
	_tmp9_ = _tmp8_;
	_vala_assert (!_tmp9_->exists, "!dir.file.exists");
	_tmp10_ = files_directory_get_state (_data1_->dir);
	_tmp11_ = _tmp10_;
	_vala_assert (_tmp11_ == FILES_DIRECTORY_STATE_NOT_LOADED, "dir.state == Directory.State.NOT_LOADED");
	g_main_loop_quit (_data1_->loop);
}

static void
___lambda5__files_directory_done_loading (FilesDirectory* _sender,
                                          gpointer self)
{
	__lambda5_ (self);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

FilesDirectory*
files_directory_test_load_non_existent_local_test (const gchar* test_dir_path,
                                                   GMainLoop* loop)
{
	Block1Data* _data1_;
	GMainLoop* _tmp0_;
	GFile* gfile = NULL;
	GFile* _tmp1_;
	FilesDirectory* _tmp2_;
	FilesDirectory* _tmp3_;
	FilesDirectory* result;
	g_return_val_if_fail (test_dir_path != NULL, NULL);
	g_return_val_if_fail (loop != NULL, NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_tmp0_ = _g_main_loop_ref0 (loop);
	_g_main_loop_unref0 (_data1_->loop);
	_data1_->loop = _tmp0_;
	_tmp1_ = g_file_new_for_commandline_arg (test_dir_path);
	gfile = _tmp1_;
	_vala_assert (!g_file_query_exists (gfile, NULL), "!gfile.query_exists (null)");
	_tmp2_ = files_directory_from_gfile (gfile);
	_data1_->dir = _tmp2_;
	g_signal_connect_data (_data1_->dir, "done-loading", (GCallback) ___lambda5__files_directory_done_loading, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp3_ = _g_object_ref0 (_data1_->dir);
	result = _tmp3_;
	_g_object_unref0 (gfile);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return result;
}

static Block2Data*
block2_data_ref (Block2Data* _data2_)
{
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}

static void
block2_data_unref (void * _userdata_)
{
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		_g_object_unref0 (_data2_->dir);
		_g_main_loop_unref0 (_data2_->loop);
		g_slice_free (Block2Data, _data2_);
	}
}

static void
__lambda7_ (Block2Data* _data2_)
{
	guint _tmp0_;
	guint _tmp1_;
	gboolean _tmp2_;
	gboolean _tmp3_;
	FilesFile* _tmp4_;
	FilesFile* _tmp5_;
	FilesFile* _tmp6_;
	FilesFile* _tmp7_;
	FilesFile* _tmp8_;
	FilesFile* _tmp9_;
	FilesDirectoryState _tmp10_;
	FilesDirectoryState _tmp11_;
	_tmp0_ = files_directory_get_displayed_files_count (_data2_->dir);
	_tmp1_ = _tmp0_;
	_vala_assert (_tmp1_ == ((guint) 0), "dir.displayed_files_count == 0");
	_tmp2_ = files_directory_get_can_load (_data2_->dir);
	_tmp3_ = _tmp2_;
	_vala_assert (_tmp3_, "dir.can_load");
	_tmp4_ = files_directory_get_file (_data2_->dir);
	_tmp5_ = _tmp4_;
	_vala_assert (_tmp5_->is_connected, "dir.file.is_connected");
	_tmp6_ = files_directory_get_file (_data2_->dir);
	_tmp7_ = _tmp6_;
	_vala_assert (!_tmp7_->is_mounted, "!dir.file.is_mounted");
	_tmp8_ = files_directory_get_file (_data2_->dir);
	_tmp9_ = _tmp8_;
	_vala_assert (_tmp9_->exists, "dir.file.exists");
	_tmp10_ = files_directory_get_state (_data2_->dir);
	_tmp11_ = _tmp10_;
	_vala_assert (_tmp11_ == FILES_DIRECTORY_STATE_LOADED, "dir.state == Directory.State.LOADED");
	g_main_loop_quit (_data2_->loop);
}

static void
___lambda7__files_directory_done_loading (FilesDirectory* _sender,
                                          gpointer self)
{
	__lambda7_ (self);
}

FilesDirectory*
files_directory_test_load_empty_local_test (const gchar* test_dir_path,
                                            GMainLoop* loop)
{
	Block2Data* _data2_;
	GMainLoop* _tmp0_;
	FilesDirectory* _tmp1_;
	FilesDirectory* _tmp2_;
	FilesDirectory* result;
	g_return_val_if_fail (test_dir_path != NULL, NULL);
	g_return_val_if_fail (loop != NULL, NULL);
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	_tmp0_ = _g_main_loop_ref0 (loop);
	_g_main_loop_unref0 (_data2_->loop);
	_data2_->loop = _tmp0_;
	_tmp1_ = files_directory_test_setup_temp_async (test_dir_path, (guint) 0, NULL, NULL);
	_data2_->dir = _tmp1_;
	g_signal_connect_data (_data2_->dir, "done-loading", (GCallback) ___lambda7__files_directory_done_loading, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
	_tmp2_ = _g_object_ref0 (_data2_->dir);
	result = _tmp2_;
	block2_data_unref (_data2_);
	_data2_ = NULL;
	return result;
}

static Block3Data*
block3_data_ref (Block3Data* _data3_)
{
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}

static void
block3_data_unref (void * _userdata_)
{
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		_g_object_unref0 (_data3_->dir);
		_g_main_loop_unref0 (_data3_->loop);
		g_slice_free (Block3Data, _data3_);
	}
}

static void
__lambda9_ (Block3Data* _data3_)
{
	guint _tmp0_;
	_tmp0_ = _data3_->file_loaded_signal_count;
	_data3_->file_loaded_signal_count = _tmp0_ + 1;
}

static void
___lambda9__files_directory_file_loaded (FilesDirectory* _sender,
                                         FilesFile* file,
                                         gpointer self)
{
	__lambda9_ (self);
}

static void
__lambda10_ (Block3Data* _data3_)
{
	guint _tmp0_;
	guint _tmp1_;
	gboolean _tmp2_;
	gboolean _tmp3_;
	FilesDirectoryState _tmp4_;
	FilesDirectoryState _tmp5_;
	_tmp0_ = files_directory_get_displayed_files_count (_data3_->dir);
	_tmp1_ = _tmp0_;
	_vala_assert (_tmp1_ == _data3_->n_files, "dir.displayed_files_count == n_files");
	_tmp2_ = files_directory_get_can_load (_data3_->dir);
	_tmp3_ = _tmp2_;
	_vala_assert (_tmp3_, "dir.can_load");
	_tmp4_ = files_directory_get_state (_data3_->dir);
	_tmp5_ = _tmp4_;
	_vala_assert (_tmp5_ == FILES_DIRECTORY_STATE_LOADED, "dir.state == Directory.State.LOADED");
	_vala_assert (_data3_->file_loaded_signal_count == _data3_->n_files, "file_loaded_signal_count == n_files");
	g_main_loop_quit (_data3_->loop);
}

static void
___lambda10__files_directory_done_loading (FilesDirectory* _sender,
                                           gpointer self)
{
	__lambda10_ (self);
}

FilesDirectory*
files_directory_test_load_populated_local_test (const gchar* test_dir_path,
                                                GMainLoop* loop)
{
	Block3Data* _data3_;
	GMainLoop* _tmp0_;
	FilesDirectory* _tmp1_;
	FilesDirectory* _tmp2_;
	FilesDirectory* result;
	g_return_val_if_fail (test_dir_path != NULL, NULL);
	g_return_val_if_fail (loop != NULL, NULL);
	_data3_ = g_slice_new0 (Block3Data);
	_data3_->_ref_count_ = 1;
	_tmp0_ = _g_main_loop_ref0 (loop);
	_g_main_loop_unref0 (_data3_->loop);
	_data3_->loop = _tmp0_;
	_data3_->n_files = (guint) 5;
	_data3_->file_loaded_signal_count = (guint) 0;
	_tmp1_ = files_directory_test_setup_temp_async (test_dir_path, _data3_->n_files, NULL, NULL);
	_data3_->dir = _tmp1_;
	_vala_assert (((GObject*) _data3_->dir)->ref_count == ((guint) 1), "dir.ref_count == 1");
	g_signal_connect_data (_data3_->dir, "file-loaded", (GCallback) ___lambda9__files_directory_file_loaded, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
	g_signal_connect_data (_data3_->dir, "done-loading", (GCallback) ___lambda10__files_directory_done_loading, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
	_tmp2_ = _g_object_ref0 (_data3_->dir);
	result = _tmp2_;
	block3_data_unref (_data3_);
	_data3_ = NULL;
	return result;
}

static Block4Data*
block4_data_ref (Block4Data* _data4_)
{
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}

static void
block4_data_unref (void * _userdata_)
{
	Block4Data* _data4_;
	_data4_ = (Block4Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		_g_object_unref0 (_data4_->dir);
		_g_main_loop_unref0 (_data4_->loop);
		g_slice_free (Block4Data, _data4_);
	}
}

static void
___lambda13_ (Block4Data* _data4_)
{
	guint _tmp0_;
	_tmp0_ = _data4_->file_loaded_signal_count;
	_data4_->file_loaded_signal_count = _tmp0_ + 1;
}

static void
____lambda13__files_directory_file_loaded (FilesDirectory* _sender,
                                           FilesFile* file,
                                           gpointer self)
{
	___lambda13_ (self);
}

static void
__lambda12_ (Block4Data* _data4_)
{
	if (_data4_->first_load) {
		gboolean _tmp0_;
		gboolean _tmp1_;
		_data4_->first_load = FALSE;
		g_signal_connect_data (_data4_->dir, "file-loaded", (GCallback) ____lambda13__files_directory_file_loaded, block4_data_ref (_data4_), (GClosureNotify) block4_data_unref, 0);
		_tmp0_ = files_directory_get_loaded_from_cache (_data4_->dir);
		_tmp1_ = _tmp0_;
		_vala_assert (!_tmp1_, "!dir.loaded_from_cache");
		files_directory_init (_data4_->dir, NULL, NULL, NULL, NULL);
	} else {
		guint _tmp2_;
		guint _tmp3_;
		gboolean _tmp4_;
		gboolean _tmp5_;
		FilesDirectoryState _tmp6_;
		FilesDirectoryState _tmp7_;
		gboolean _tmp8_;
		gboolean _tmp9_;
		_tmp2_ = files_directory_get_displayed_files_count (_data4_->dir);
		_tmp3_ = _tmp2_;
		_vala_assert (_tmp3_ == _data4_->n_files, "dir.displayed_files_count == n_files");
		_tmp4_ = files_directory_get_can_load (_data4_->dir);
		_tmp5_ = _tmp4_;
		_vala_assert (_tmp5_, "dir.can_load");
		_tmp6_ = files_directory_get_state (_data4_->dir);
		_tmp7_ = _tmp6_;
		_vala_assert (_tmp7_ == FILES_DIRECTORY_STATE_LOADED, "dir.state == Directory.State.LOADED");
		_vala_assert (_data4_->file_loaded_signal_count == _data4_->n_files, "file_loaded_signal_count == n_files");
		_tmp8_ = files_directory_get_loaded_from_cache (_data4_->dir);
		_tmp9_ = _tmp8_;
		_vala_assert (_tmp9_, "dir.loaded_from_cache");
		g_main_loop_quit (_data4_->loop);
	}
}

static void
___lambda12__files_directory_done_loading (FilesDirectory* _sender,
                                           gpointer self)
{
	__lambda12_ (self);
}

FilesDirectory*
files_directory_test_load_cached_local_test (const gchar* test_dir_path,
                                             GMainLoop* loop)
{
	Block4Data* _data4_;
	GMainLoop* _tmp0_;
	FilesDirectory* _tmp1_;
	FilesDirectory* _tmp2_;
	FilesDirectory* result;
	g_return_val_if_fail (test_dir_path != NULL, NULL);
	g_return_val_if_fail (loop != NULL, NULL);
	_data4_ = g_slice_new0 (Block4Data);
	_data4_->_ref_count_ = 1;
	_tmp0_ = _g_main_loop_ref0 (loop);
	_g_main_loop_unref0 (_data4_->loop);
	_data4_->loop = _tmp0_;
	_data4_->n_files = (guint) 5;
	_data4_->first_load = TRUE;
	_data4_->file_loaded_signal_count = (guint) 0;
	_tmp1_ = files_directory_test_setup_temp_async (test_dir_path, _data4_->n_files, NULL, NULL);
	_data4_->dir = _tmp1_;
	g_signal_connect_data (_data4_->dir, "done-loading", (GCallback) ___lambda12__files_directory_done_loading, block4_data_ref (_data4_), (GClosureNotify) block4_data_unref, 0);
	_tmp2_ = _g_object_ref0 (_data4_->dir);
	result = _tmp2_;
	block4_data_unref (_data4_);
	_data4_ = NULL;
	return result;
}

static Block5Data*
block5_data_ref (Block5Data* _data5_)
{
	g_atomic_int_inc (&_data5_->_ref_count_);
	return _data5_;
}

static void
block5_data_unref (void * _userdata_)
{
	Block5Data* _data5_;
	_data5_ = (Block5Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data5_->_ref_count_)) {
		_g_object_unref0 (_data5_->dir);
		_g_free0 (_data5_->tmp_pth);
		_g_main_loop_unref0 (_data5_->loop);
		g_slice_free (Block5Data, _data5_);
	}
}

static void
__lambda15_ (Block5Data* _data5_)
{
	gboolean _tmp0_;
	gboolean _tmp1_;
	_tmp0_ = files_directory_get_loaded_from_cache (_data5_->dir);
	_tmp1_ = _tmp0_;
	_vala_assert (!_tmp1_, "!dir.loaded_from_cache");
	if (_data5_->loads == ((guint) 0)) {
		_data5_->ref_count_before_reload = ((GObject*) _data5_->dir)->ref_count;
	}
	if (_data5_->loads < _data5_->n_loads) {
		guint _tmp2_;
		_tmp2_ = _data5_->loads;
		_data5_->loads = _tmp2_ + 1;
		files_directory_cancel (_data5_->dir);
		files_directory_reload (_data5_->dir);
	} else {
		guint _tmp3_;
		guint _tmp4_;
		gboolean _tmp5_;
		gboolean _tmp6_;
		FilesDirectoryState _tmp7_;
		FilesDirectoryState _tmp8_;
		_tmp3_ = files_directory_get_displayed_files_count (_data5_->dir);
		_tmp4_ = _tmp3_;
		_vala_assert (_tmp4_ == _data5_->n_files, "dir.displayed_files_count == n_files");
		_tmp5_ = files_directory_get_can_load (_data5_->dir);
		_tmp6_ = _tmp5_;
		_vala_assert (_tmp6_, "dir.can_load");
		_tmp7_ = files_directory_get_state (_data5_->dir);
		_tmp8_ = _tmp7_;
		_vala_assert (_tmp8_ == FILES_DIRECTORY_STATE_LOADED, "dir.state == Directory.State.LOADED");
		_vala_assert (((GObject*) _data5_->dir)->ref_count == _data5_->ref_count_before_reload, "dir.ref_count == ref_count_before_reload");
		files_directory_test_tear_down_file (_data5_->tmp_pth);
		files_directory_cancel (_data5_->dir);
		_g_object_unref0 (_data5_->dir);
		_data5_->dir = NULL;
		g_main_loop_quit (_data5_->loop);
	}
}

static void
___lambda15__files_directory_done_loading (FilesDirectory* _sender,
                                           gpointer self)
{
	__lambda15_ (self);
}

FilesDirectory*
files_directory_test_reload_populated_local_test (const gchar* test_dir_path,
                                                  GMainLoop* loop)
{
	Block5Data* _data5_;
	GMainLoop* _tmp0_;
	gchar* _tmp1_;
	FilesDirectory* _tmp2_;
	FilesDirectory* _tmp3_;
	FilesDirectory* result;
	g_return_val_if_fail (test_dir_path != NULL, NULL);
	g_return_val_if_fail (loop != NULL, NULL);
	_data5_ = g_slice_new0 (Block5Data);
	_data5_->_ref_count_ = 1;
	_tmp0_ = _g_main_loop_ref0 (loop);
	_g_main_loop_unref0 (_data5_->loop);
	_data5_->loop = _tmp0_;
	_data5_->n_files = (guint) 50;
	_data5_->n_loads = (guint) 5;
	_data5_->loads = (guint) 0;
	_data5_->ref_count_before_reload = (guint) 0;
	_tmp1_ = files_directory_test_get_text_template_path ();
	_data5_->tmp_pth = _tmp1_;
	_tmp2_ = files_directory_test_setup_temp_async (test_dir_path, _data5_->n_files, "txt", _data5_->tmp_pth);
	_data5_->dir = _tmp2_;
	g_signal_connect_data (_data5_->dir, "done-loading", (GCallback) ___lambda15__files_directory_done_loading, block5_data_ref (_data5_), (GClosureNotify) block5_data_unref, 0);
	_tmp3_ = _g_object_ref0 (_data5_->dir);
	result = _tmp3_;
	block5_data_unref (_data5_);
	_data5_ = NULL;
	return result;
}

/*** Helper functions ***/
FilesDirectory*
files_directory_test_setup_temp_async (const gchar* path,
                                       guint n_files,
                                       const gchar* extension,
                                       const gchar* path_to_template)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* extn = NULL;
	gchar* _tmp8_;
	GFile* gfile = NULL;
	GFile* _tmp31_;
	FilesDirectory* dir = NULL;
	FilesDirectory* _tmp32_;
	FilesDirectory* result;
	g_return_val_if_fail (path != NULL, NULL);
	if (extension == NULL) {
		_tmp1_ = TRUE;
	} else {
		gint _tmp2_;
		gint _tmp3_;
		_tmp2_ = strlen (extension);
		_tmp3_ = _tmp2_;
		_tmp1_ = _tmp3_ > 0;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gint _tmp4_;
		gint _tmp5_;
		_tmp4_ = strlen (extension);
		_tmp5_ = _tmp4_;
		_tmp0_ = _tmp5_ < 5;
	}
	_vala_assert (_tmp0_, "extension == null || extension.length > 0 || extension.length < 5");
	_tmp6_ = g_strconcat ("mkdir ", path, NULL);
	_tmp7_ = _tmp6_;
	system (_tmp7_);
	_g_free0 (_tmp7_);
	_tmp8_ = g_strdup ("");
	extn = _tmp8_;
	if (extension != NULL) {
		gchar* _tmp9_;
		_tmp9_ = g_strconcat (".", extension, NULL);
		_g_free0 (extn);
		extn = _tmp9_;
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp10_ = FALSE;
			_tmp10_ = TRUE;
			while (TRUE) {
				gchar* pth = NULL;
				gchar* _tmp12_;
				gchar* _tmp13_;
				gchar* _tmp14_;
				gchar* _tmp15_;
				gchar* _tmp16_;
				gchar* _tmp17_;
				const gchar* _tmp18_;
				gchar* _tmp19_;
				gchar* _tmp20_;
				if (!_tmp10_) {
					gint _tmp11_;
					_tmp11_ = i;
					i = _tmp11_ + 1;
				}
				_tmp10_ = FALSE;
				if (!(((guint) i) < n_files)) {
					break;
				}
				_tmp12_ = g_strconcat (path, G_DIR_SEPARATOR_S, NULL);
				_tmp13_ = _tmp12_;
				_tmp14_ = g_strdup_printf ("%i", i);
				_tmp15_ = _tmp14_;
				_tmp16_ = g_strconcat (_tmp13_, _tmp15_, NULL);
				_tmp17_ = _tmp16_;
				_tmp18_ = extn;
				_tmp19_ = g_strconcat (_tmp17_, _tmp18_, NULL);
				_tmp20_ = _tmp19_;
				_g_free0 (_tmp17_);
				_g_free0 (_tmp15_);
				_g_free0 (_tmp13_);
				pth = _tmp20_;
				if (path_to_template == NULL) {
					const gchar* _tmp21_;
					gchar* _tmp22_;
					gchar* _tmp23_;
					_tmp21_ = pth;
					_tmp22_ = g_strconcat ("touch ", _tmp21_, NULL);
					_tmp23_ = _tmp22_;
					system (_tmp23_);
					_g_free0 (_tmp23_);
				} else {
					gchar* _tmp24_;
					gchar* _tmp25_;
					gchar* _tmp26_;
					gchar* _tmp27_;
					const gchar* _tmp28_;
					gchar* _tmp29_;
					gchar* _tmp30_;
					_tmp24_ = g_strconcat ("cp --no-dereference --no-clobber ", path_to_template, NULL);
					_tmp25_ = _tmp24_;
					_tmp26_ = g_strconcat (_tmp25_, " ", NULL);
					_tmp27_ = _tmp26_;
					_tmp28_ = pth;
					_tmp29_ = g_strconcat (_tmp27_, _tmp28_, NULL);
					_tmp30_ = _tmp29_;
					system (_tmp30_);
					_g_free0 (_tmp30_);
					_g_free0 (_tmp27_);
					_g_free0 (_tmp25_);
				}
				_g_free0 (pth);
			}
		}
	}
	_tmp31_ = g_file_new_for_commandline_arg (path);
	gfile = _tmp31_;
	_vala_assert (g_file_query_exists (gfile, NULL), "gfile.query_exists (null)");
	_tmp32_ = files_directory_from_gfile (gfile);
	dir = _tmp32_;
	_vala_assert (dir != NULL, "dir != null");
	result = dir;
	_g_object_unref0 (gfile);
	_g_free0 (extn);
	return result;
}

gchar*
files_directory_test_get_text_template_path (void)
{
	gchar* test_template_path = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* result;
	_tmp0_ = g_strdup_printf ("%" G_GINT64_FORMAT, g_get_real_time ());
	_tmp1_ = _tmp0_;
	_tmp2_ = g_strconcat ("/tmp/marlin-template-", _tmp1_, NULL);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strconcat (_tmp3_, "txt", NULL);
	_tmp5_ = _tmp4_;
	_g_free0 (_tmp3_);
	_g_free0 (_tmp1_);
	test_template_path = _tmp5_;
	_tmp6_ = g_strconcat ("env > ", test_template_path, NULL);
	_tmp7_ = _tmp6_;
	system (_tmp7_);
	_g_free0 (_tmp7_);
	result = test_template_path;
	return result;
}

void
files_directory_test_tear_down_folder (const gchar* path)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (path != NULL);
	_tmp0_ = g_strconcat ("rm -rf ", path, NULL);
	_tmp1_ = _tmp0_;
	system (_tmp1_);
	_g_free0 (_tmp1_);
}

void
files_directory_test_tear_down_file (const gchar* path)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (path != NULL);
	_tmp0_ = g_strconcat ("rm -f ", path, NULL);
	_tmp1_ = _tmp0_;
	system (_tmp1_);
	_g_free0 (_tmp1_);
}

static gint
_vala_main (gchar** args,
            gint args_length1)
{
	gint result;
	g_test_init ((gint*) (&args_length1), &args, NULL);
	files_directory_test_add_gof_directory_async_tests ();
	result = g_test_run ();
	return result;
}

int
main (int argc,
      char ** argv)
{
	return _vala_main (argv, argc);
}

