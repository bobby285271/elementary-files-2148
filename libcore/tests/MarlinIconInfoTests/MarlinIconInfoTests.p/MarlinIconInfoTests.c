/* MarlinIconInfoTests.c generated by valac 0.56.3, the Vala compiler
 * generated from MarlinIconInfoTests.vala, do not modify */

#include <glib.h>
#include <stdlib.h>
#include <string.h>
#include "config.h"
#include "pantheon-files-core.h"
#include <stdio.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <glib-object.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _Block1Data Block1Data;
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
typedef struct _Block2Data Block2Data;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _Block1Data {
	int _ref_count_;
	GMainLoop* loop;
};

struct _Block2Data {
	int _ref_count_;
	GMainLoop* loop;
};

VALA_EXTERN void add_icon_info_tests (void);
VALA_EXTERN void goffile_icon_update_test (void);
static void _goffile_icon_update_test_gtest_func (void);
VALA_EXTERN void themed_cache_and_ref_test (void);
static void _themed_cache_and_ref_test_gtest_func (void);
VALA_EXTERN void loadable_cache_and_ref_test (void);
static void _loadable_cache_and_ref_test_gtest_func (void);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static gboolean __lambda4_ (Block1Data* _data1_);
static gboolean ___lambda4__gsource_func (gpointer self);
static gboolean __lambda5_ (Block1Data* _data1_);
static gboolean ___lambda5__gsource_func (gpointer self);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static gboolean __lambda6_ (Block2Data* _data2_);
static gboolean ___lambda6__gsource_func (gpointer self);
static gboolean __lambda7_ (Block2Data* _data2_);
static gboolean ___lambda7__gsource_func (gpointer self);
static gint _vala_main (gchar** args,
                 gint args_length1);

/***
    Copyright (c) 2017-2018 elementary LLC <https://elementary.io>

    This file is part of Pantheon Files.

    Pantheon Files is free software: you can redistribute it and/or modify it
    under the terms of the GNU Lesser General Public License version 3, as published
    by the Free Software Foundation.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranties of
    MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
    PURPOSE. See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with Pantheon Files. If not, see <http://www.gnu.org/licenses/>.

    Authored by: Jeremy Wootten <jeremy@elementaryos.org>
***/
static void
_goffile_icon_update_test_gtest_func (void)
{
	goffile_icon_update_test ();
}

static void
_themed_cache_and_ref_test_gtest_func (void)
{
	themed_cache_and_ref_test ();
}

static void
_loadable_cache_and_ref_test_gtest_func (void)
{
	loadable_cache_and_ref_test ();
}

void
add_icon_info_tests (void)
{
	g_test_add_func ("/MarlinIconInfo/goffile_icon_update", _goffile_icon_update_test_gtest_func);
	g_test_add_func ("/MarlinIconInfo/themed_cache_and_ref", _themed_cache_and_ref_test_gtest_func);
	g_test_add_func ("/MarlinIconInfo/loadable_cache_and_ref", _loadable_cache_and_ref_test_gtest_func);
}

void
goffile_icon_update_test (void)
{
	gchar* test_file_path = NULL;
	gchar* _tmp0_;
	FilesFile* file = NULL;
	FilesFile* _tmp1_;
	FILE* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	GdkPixbuf* _tmp5_;
	GdkPixbuf* _tmp6_;
	_tmp0_ = g_build_filename (TESTDATA_DIR, "images", "testimage.png", NULL);
	test_file_path = _tmp0_;
	_tmp1_ = files_file_get_by_uri (test_file_path);
	file = _tmp1_;
	_vala_assert (file != NULL, "file != null");
	_tmp2_ = stderr;
	_tmp3_ = files_file_get_uri (file);
	_tmp4_ = _tmp3_;
	fprintf (_tmp2_, "\n\rquery update file %s\n\r", _tmp4_);
	files_file_query_update (file);
	_tmp5_ = file->pix;
	_vala_assert (_tmp5_ == NULL, "file.pix == null");
	files_file_update_icon (file, 128, 1);
	_tmp6_ = file->pix;
	_vala_assert (_tmp6_ != NULL, "file.pix != null");
	_vala_assert (file->pix_size == 128, "file.pix_size == 128");
	files_file_update_icon (file, 32, 1);
	_vala_assert (file->pix_size == 32, "file.pix_size == 32");
	_g_object_unref0 (file);
	_g_free0 (test_file_path);
}

static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}

static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_main_loop_unref0 (_data1_->loop);
		g_slice_free (Block1Data, _data1_);
	}
}

static gboolean
__lambda4_ (Block1Data* _data1_)
{
	GMainLoop* _tmp0_;
	gboolean result;
	_vala_assert (files_icon_info_themed_icon_cache_info () == ((guint) 1), "Files.IconInfo.themed_icon_cache_info () == 1");
	_tmp0_ = _data1_->loop;
	g_main_loop_quit (_tmp0_);
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
___lambda4__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda4_ (self);
	return result;
}

static gboolean
__lambda5_ (Block1Data* _data1_)
{
	GMainLoop* _tmp0_;
	gboolean result;
	_vala_assert (files_icon_info_themed_icon_cache_info () == ((guint) 0), "Files.IconInfo.themed_icon_cache_info () == 0");
	_tmp0_ = _data1_->loop;
	g_main_loop_quit (_tmp0_);
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
___lambda5__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda5_ (self);
	return result;
}

void
themed_cache_and_ref_test (void)
{
	Block1Data* _data1_;
	guint reap_time_msec = 0U;
	gchar* test_file_path = NULL;
	gchar* _tmp0_;
	FilesFile* file = NULL;
	FilesFile* _tmp1_;
	GdkPixbuf* _tmp2_;
	GMainLoop* _tmp3_;
	GMainLoop* _tmp4_;
	GMainLoop* _tmp5_;
	GMainLoop* _tmp6_;
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	files_icon_info_clear_caches ();
	reap_time_msec = (guint) 20;
	files_icon_info_set_reap_time (reap_time_msec);
	_tmp0_ = g_build_filename (TESTDATA_DIR, "images", "testimage.png", NULL);
	test_file_path = _tmp0_;
	_tmp1_ = files_file_get_by_uri (test_file_path);
	file = _tmp1_;
	_vala_assert (file != NULL, "file != null");
	files_file_query_update (file);
	_g_object_unref0 (file->pix);
	file->pix = NULL;
	files_file_update_icon (file, 128, 1);
	_tmp2_ = file->pix;
	_vala_assert (((GObject*) _tmp2_)->ref_count == ((guint) 2), "file.pix.ref_count == 2");
	_vala_assert (files_icon_info_themed_icon_cache_info () == ((guint) 1), "Files.IconInfo.themed_icon_cache_info () == 1");
	_vala_assert (files_icon_info_loadable_icon_cache_info () == ((guint) 0), "Files.IconInfo.loadable_icon_cache_info () == 0");
	files_file_update_icon (file, 32, 1);
	_vala_assert (files_icon_info_themed_icon_cache_info () == ((guint) 2), "Files.IconInfo.themed_icon_cache_info () == 2");
	_tmp3_ = g_main_loop_new (NULL, FALSE);
	_data1_->loop = _tmp3_;
	g_timeout_add_full (G_PRIORITY_DEFAULT, reap_time_msec * 2, ___lambda4__gsource_func, block1_data_ref (_data1_), block1_data_unref);
	_tmp4_ = _data1_->loop;
	g_main_loop_run (_tmp4_);
	_g_object_unref0 (file->pix);
	file->pix = NULL;
	_tmp5_ = g_main_loop_new (NULL, FALSE);
	_g_main_loop_unref0 (_data1_->loop);
	_data1_->loop = _tmp5_;
	g_timeout_add_full (G_PRIORITY_DEFAULT, reap_time_msec * 12, ___lambda5__gsource_func, block1_data_ref (_data1_), block1_data_unref);
	_tmp6_ = _data1_->loop;
	g_main_loop_run (_tmp6_);
	_g_object_unref0 (file);
	_g_free0 (test_file_path);
	block1_data_unref (_data1_);
	_data1_ = NULL;
}

static Block2Data*
block2_data_ref (Block2Data* _data2_)
{
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}

static void
block2_data_unref (void * _userdata_)
{
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		_g_main_loop_unref0 (_data2_->loop);
		g_slice_free (Block2Data, _data2_);
	}
}

static gboolean
__lambda6_ (Block2Data* _data2_)
{
	GMainLoop* _tmp0_;
	gboolean result;
	_vala_assert (files_icon_info_loadable_icon_cache_info () == ((guint) 1), "Files.IconInfo.loadable_icon_cache_info () == 1");
	_tmp0_ = _data2_->loop;
	g_main_loop_quit (_tmp0_);
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
___lambda6__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda6_ (self);
	return result;
}

static gboolean
__lambda7_ (Block2Data* _data2_)
{
	GMainLoop* _tmp0_;
	gboolean result;
	_vala_assert (files_icon_info_loadable_icon_cache_info () == ((guint) 0), "Files.IconInfo.loadable_icon_cache_info () == 0");
	_tmp0_ = _data2_->loop;
	g_main_loop_quit (_tmp0_);
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
___lambda7__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda7_ (self);
	return result;
}

void
loadable_cache_and_ref_test (void)
{
	Block2Data* _data2_;
	guint reap_time_msec = 0U;
	gchar* test_file_path = NULL;
	gchar* _tmp0_;
	FilesFile* file = NULL;
	FilesFile* _tmp1_;
	gchar* _tmp2_;
	GdkPixbuf* _tmp3_;
	GMainLoop* _tmp4_;
	GMainLoop* _tmp5_;
	GMainLoop* _tmp6_;
	GMainLoop* _tmp7_;
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	files_icon_info_clear_caches ();
	reap_time_msec = (guint) 20;
	files_icon_info_set_reap_time (reap_time_msec);
	_tmp0_ = g_build_filename (TESTDATA_DIR, "images", "testimage.jpg", NULL);
	test_file_path = _tmp0_;
	_tmp1_ = files_file_get_by_uri (test_file_path);
	file = _tmp1_;
	_g_object_unref0 (file->pix);
	file->pix = NULL;
	files_file_query_update (file);
	file->thumbstate = (guint) FILES_FILE_THUMB_STATE_READY;
	_tmp2_ = g_build_filename (TESTDATA_DIR, "images", "testimage.jpg.thumb.png", NULL);
	_g_free0 (file->thumbnail_path);
	file->thumbnail_path = _tmp2_;
	files_file_update_icon (file, 128, 1);
	_tmp3_ = file->pix;
	_vala_assert (((GObject*) _tmp3_)->ref_count == ((guint) 2), "file.pix.ref_count == 2");
	_vala_assert (files_icon_info_themed_icon_cache_info () == ((guint) 0), "Files.IconInfo.themed_icon_cache_info () == 0");
	_vala_assert (files_icon_info_loadable_icon_cache_info () == ((guint) 1), "Files.IconInfo.loadable_icon_cache_info () == 1");
	files_file_update_icon (file, 32, 1);
	_vala_assert (files_icon_info_loadable_icon_cache_info () == ((guint) 2), "Files.IconInfo.loadable_icon_cache_info () == 2");
	_tmp4_ = g_main_loop_new (NULL, FALSE);
	_data2_->loop = _tmp4_;
	g_timeout_add_full (G_PRIORITY_DEFAULT, reap_time_msec * 2, ___lambda6__gsource_func, block2_data_ref (_data2_), block2_data_unref);
	_tmp5_ = _data2_->loop;
	g_main_loop_run (_tmp5_);
	_g_object_unref0 (file->pix);
	file->pix = NULL;
	_tmp6_ = g_main_loop_new (NULL, FALSE);
	_g_main_loop_unref0 (_data2_->loop);
	_data2_->loop = _tmp6_;
	g_timeout_add_full (G_PRIORITY_DEFAULT, reap_time_msec * 12, ___lambda7__gsource_func, block2_data_ref (_data2_), block2_data_unref);
	_tmp7_ = _data2_->loop;
	g_main_loop_run (_tmp7_);
	_g_object_unref0 (file);
	_g_free0 (test_file_path);
	block2_data_unref (_data2_);
	_data2_ = NULL;
}

static gint
_vala_main (gchar** args,
            gint args_length1)
{
	gint result;
	g_test_init ((gint*) (&args_length1), &args, NULL);
	add_icon_info_tests ();
	result = g_test_run ();
	return result;
}

int
main (int argc,
      char ** argv)
{
	return _vala_main (argv, argc);
}

